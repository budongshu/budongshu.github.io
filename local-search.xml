<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>传输层TCP/UDP笔记</title>
    <link href="/2020/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82TCP-UDP%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82TCP-UDP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>传输层里比较重要的两个协议，一个是 TCP，一个是 UDP。对于不从事底层开发的人员来讲，或者对于开发应用的人来讲，最常用的就是这两个协议。由于面试的时候，这俩个是会是一起被问到的</p><h3 id="1-TCP-和-UDP-有哪些区别？"><a href="#1-TCP-和-UDP-有哪些区别？" class="headerlink" title="1 TCP 和 UDP 有哪些区别？"></a>1 TCP 和 UDP 有哪些区别？</h3><p>一般面试的时候我问这两个协议的区别，大部分人会回答，TCP 是面向连接的，UDP 是面向无连接的。什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会。为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？</p><h3 id="2-UDP-协议"><a href="#2-UDP-协议" class="headerlink" title="2  UDP 协议"></a>2  UDP 协议</h3><ul><li><p>不保证不丢失，不保证按照顺序到达 </p></li><li><p>基于数据报的，一个一个发，一个一个收</p></li><li><p>随时想发就发 无状态服务</p></li></ul><h3 id="3-UDP-包头"><a href="#3-UDP-包头" class="headerlink" title="3  UDP 包头"></a>3  UDP 包头</h3><p>我们来看一下UDP 包头</p><p>一个包的传输过程，当我发送一个UDP包到达目标主机后，进行MAC地址匹配，发现匹配，摘下MAC地址头部，将剩下包传输给IP层的代码，摘下IP头，看目标IP是否匹配，如果匹配接下来数据报怎么发送? </p><p>由于IP头会存放8位协议，这里面会存放到底是TCP还是UDP 。这里是UDP，然后我们按UDP头的格式，就能从数据里面，将它解析出来，解析出来数据交给下一层去处理  </p><p>处理完传输层的事情，内核的事情就基本完事，里面的数据交给应用程序去处理，一台机器会有好多个程序 </p><p>无论是TCP和UDP 传数据，应用程序都会监听一个端口，也就是这个端口，用来区分应用程序，所以端口不能冲突，然后根据端口号，将数据交给响应的应用程序 </p><p>通过下面图可以看到UDP 包头非常简单</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205172722741.png" alt="image-20201205172722741"></p><h3 id="4-UDP-特点"><a href="#4-UDP-特点" class="headerlink" title="4 UDP 特点"></a>4 UDP 特点</h3><ul><li>沟通简单，不需要三次握手四次断开</li><li>谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据</li><li>它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</li></ul><h3 id="5-UDP-使用场景"><a href="#5-UDP-使用场景" class="headerlink" title="5 UDP 使用场景"></a>5 UDP 使用场景</h3><p><strong>第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</strong></p><p>前面说的通过PXE自动安装系统 下载使用TFTP ,就是基于UDP协议，占有资源少</p><p><strong>第二，不需要一对一沟通，建立连接，而是可以广播的应用</strong></p><p>UDP 的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP 就是一种广播的形式，就是基于 UDP 协议的，而广播包的格式前面说过了。</p><p>在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。</p><p><strong>第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong></p><p>UDP 简单、处理速度快，不像 TCP 那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而 TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。</p><p>当前很多应用都是要求低时延的，它们可不想用 TCP 如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于 TCP。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达</p><h3 id="6-基于UDP的例子"><a href="#6-基于UDP的例子" class="headerlink" title="6 基于UDP的例子"></a>6 基于UDP的例子</h3><p>列举几种“城会玩”的例子。</p><h4 id="6-1-网页或者app的访问"><a href="#6-1-网页或者app的访问" class="headerlink" title="6.1 网页或者app的访问"></a>6.1 网页或者app的访问</h4><p><code>QUIC</code>（全称 Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</p><h4 id="6-2-流媒体协议"><a href="#6-2-流媒体协议" class="headerlink" title="6.2 流媒体协议"></a>6.2 流媒体协议</h4><p>现在直播比较火，直播协议多使用 RTMP，这个协议我们后面的章节也会讲，而这个 RTMP 协议也是基于 TCP 的。TCP 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着，因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。</p><h4 id="6-3-实时游戏"><a href="#6-3-实时游戏" class="headerlink" title="6.3 实时游戏"></a>6.3 实时游戏</h4><p>游戏有一个特点，要求实时性比较高，慢一秒可能就要被别人干掉或者爆头 </p><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响</p><h4 id="6-4-IoT-物联网"><a href="#6-4-IoT-物联网" class="headerlink" title="6.4 IoT 物联网"></a>6.4 IoT 物联网</h4><p>一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大；另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的。</p><h4 id="6-5-移动通信领域"><a href="#6-5-移动通信领域" class="headerlink" title="6.5 移动通信领域"></a>6.5 移动通信领域</h4><p>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的。因为移动网络协议比较复杂，而 GTP 协议本身就包含复杂的手机上线下线的通信协议。如果基于 TCP，TCP 的机制就显得非常多余，这部分协议我会在后面的章节单独讲解。</p><h3 id="7-TCP-协议"><a href="#7-TCP-协议" class="headerlink" title="7 TCP 协议"></a>7 TCP 协议</h3><p>我们讲的 UDP，基本上包括了传输层所必须的端口字段。它就像我们小时候一样简单，相信“网之初，性本善，不丢包，不乱序”。</p><p>后来呢，我们都慢慢长大，了解了社会的残酷，变得复杂而成熟，就像 TCP 协议一样。它之所以这么复杂，那是因为它秉承的是“性恶论”。它天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。</p><h3 id="8-TCP-协议包头格式"><a href="#8-TCP-协议包头格式" class="headerlink" title="8 TCP 协议包头格式"></a>8 TCP 协议包头格式</h3><p>我们先来看 TCP 头的格式。从这个图上可以看出，它比 UDP 复杂得多。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205181353995.png" alt="image-20201205181353995"></p><p>首先，源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。</p><p>接下来是包的序号。为什么要给包编号呢？当然是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。既然是社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。</p><p>还应该有的就是确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。</p><p>TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。</p><p>这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。</p><p>接下来有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>不像小时候，随便一个不认识的小朋友都能玩在一起，人大了，就变得礼貌，优雅而警觉，人与人遇到会互相热情的寒暄，离开会不舍地道别，但是人与人之间的信任会经过多次交互才能建立。</p><p>还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>作为老司机，做事情要有分寸，待人要把握尺度，既能适当提出自己的要求，又不强人所难。除了做流量控制以外，TCP 还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><p>作为老司机，要会自我控制，知进退，知道什么时候应该坚持，什么时候应该让步。</p><p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：</p><ul><li><p>顺序问题 ，稳重不乱；</p></li><li><p>丢包问题，承诺靠谱；</p></li><li><p>连接维护，有始有终；</p></li><li><p>流量控制，把握分寸；拥塞控制</p></li></ul><h3 id="9-TCP-三次握手"><a href="#9-TCP-三次握手" class="headerlink" title="9 TCP 三次握手"></a>9 TCP 三次握手</h3><p>tcp的连接建立 常常称之为 三次握手，比如 </p><p>A：hello 我是A </p><p>B:   收到A的helo ，然后说 我是B hello </p><p>A： 你好B</p><p>也就是说我们都要保证A，B双方的消息有去也有回，就基本可以了。</p><p>三次握手还沟通了一个重要事情，就是<code>TCP包的序号的问题</code></p><p>A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。</p><p>例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。</p><p>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4 微秒加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 TTL，也即生存时间。</p><p>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205185241457.png" alt="image-20201205185241457"></p><h3 id="10-TCP-四次断开"><a href="#10-TCP-四次断开" class="headerlink" title="10 TCP 四次断开"></a>10 TCP 四次断开</h3><p>现在我们说一下四次断开，大家好聚好散，还是朋友</p><p>A:  B 我们分手吧</p><p>B：好，我知道了，分手就分手</p><p>B：A，你好狠心， 分吧分吧，把你的照片还给你 </p><p>A：好的B，照片收到，祝你幸福</p><p>状态时序图</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205190637906.png" alt="image-20201205190637906"></p><p><strong>最后等待2MSL 的原因</strong></p><ol><li><p>有可能A 最后发的ACK B没有收到，那么B会认为我上次给你发的FIN ACK包 A是不是没有收到，等待2MSL ，为了能够让B 再次重发FIN ACK包给A </p></li><li><p>避免端口被新应用占用，收到上个连接中B发过来的包，避免产生混乱</p></li></ol><p>等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等</p><p>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p><h3 id="11-TCP状态机"><a href="#11-TCP状态机" class="headerlink" title="11 TCP状态机"></a>11 TCP状态机</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205190545913.png" alt="image-20201205190545913"></p><h3 id="12-Socket"><a href="#12-Socket" class="headerlink" title="12 Socket"></a>12 Socket</h3><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket</p><h4 id="12-1-Socket-模拟实现"><a href="#12-1-Socket-模拟实现" class="headerlink" title="12.1 Socket 模拟实现"></a>12.1 Socket 模拟实现</h4><p>在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM</p><h4 id="12-2-基于-TCP-协议的-Socket-程序函数调用过程"><a href="#12-2-基于-TCP-协议的-Socket-程序函数调用过程" class="headerlink" title="12.2 基于 TCP 协议的 Socket 程序函数调用过程"></a>12.2 基于 TCP 协议的 Socket 程序函数调用过程</h4><p>我们可以现看一段代码实现</p><pre><code class="hljs python"><span class="hljs-comment">#通过一段代码模拟socker server服务端</span><span class="hljs-comment">#! /usr/bin/python</span><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> socketsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="hljs-comment">#用的是ipv4 并且是tcp</span>server_address = (<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">12345</span>)<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Staring up on %s:%s&quot;</span> %  server_addresssock.bind(server_address)sock.listen(<span class="hljs-number">5</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;waiting ..........&quot;</span>    connetion,client_address = sock.accept()    <span class="hljs-keyword">try</span>:        <span class="hljs-built_in">print</span>  <span class="hljs-string">&quot;Connection from &quot;</span>,client_address        data = connetion.recv(<span class="hljs-number">1024</span>)        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Receive &#x27;%s&#x27;&quot;</span> % data    <span class="hljs-keyword">finally</span>:        connetion.close()</code></pre><p>一般是先调用bind 函数，给这个Socket赋予一个IP地址和端口 </p><p>然后调用listen函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p><p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p><p>客户端代码实现</p><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/python</span><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> socketsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_tcp_status</span>(<span class="hljs-params">ip,port</span>):</span>    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="hljs-comment">#ipv4 tcp协议</span>    server_address = (ip,port)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;connecting to %s:%s&quot;</span> % server_address,port    sock.connect(server_address)        <span class="hljs-comment">#connect方法</span>    message = raw_input(<span class="hljs-string">&quot;pleas input: &quot;</span>)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Sending &#x27;%s&#x27;&quot;</span> % message    sock.sendall(message)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Closing socket&quot;</span>    sock.close()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-built_in">print</span> check_tcp_status(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">12345</span>)     <span class="hljs-comment">#要访问的服务端ip和端口</span></code></pre><p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p><p>这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。</p><p>连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。</p><p>这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。在这个结构里面，主要的是两个队列，一个是发送队列，一个是接收队列。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205205310237.png" alt="image-20201205205310237"></p><h4 id="12-3-基于UDP协议Socket-程序函数调用过程"><a href="#12-3-基于UDP协议Socket-程序函数调用过程" class="headerlink" title="12.3 基于UDP协议Socket 程序函数调用过程"></a>12.3 基于UDP协议Socket 程序函数调用过程</h4><p>对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口</p><h4 id="12-4-服务器连接数"><a href="#12-4-服务器连接数" class="headerlink" title="12.4 服务器连接数"></a>12.4 服务器连接数</h4><p>我们先来算一下理论值，也就是最大连接数，系统会用一个四元组来标识一个 TCP 连接</p><pre><code class="hljs shell">&#123;本机IP, 本机端口, 对端IP, 对端端口&#125;</code></pre><p>服务器的最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，按照上面的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的</p><h4 id="12-5-如果优化程序资源"><a href="#12-5-如果优化程序资源" class="headerlink" title="12.5 如果优化程序资源"></a>12.5 如果优化程序资源</h4><ul><li><p>多进程  </p></li><li><p>多线程</p></li><li><p>IO 多路复用，一个线程维护多个 Socket</p></li><li><p>IO 多路复用，epoll函数事件通知机制</p></li></ul><p><strong>epoll 被称为解决 C10K 问题的利器</strong></p><p>有个 C10K，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器 ,成本比较高，通过epoll 事件callback机制可以解决</p><h3 id="13-TCP-保证可靠关键"><a href="#13-TCP-保证可靠关键" class="headerlink" title="13 TCP 保证可靠关键"></a>13 TCP 保证可靠关键</h3><p>累计确认： TCP为了保证顺序性，会给每一个包起始一个ID，在建立连接的时候，会计算起始ID是什么，然后按照ID顺序，一个一个发送，为了保证不丢包，对于发送的包要应答，接收端收到包后，不是一个一个应答，而是应答某个之前包的ID，表示包我都收到。这种模式叫做<code>累计应答</code> 或者<code>累计确认</code> </p><h4 id="13-1-滑动窗口"><a href="#13-1-滑动窗口" class="headerlink" title="13.1 滑动窗口"></a>13.1 滑动窗口</h4><p>在 TCP 里，接收端会给发送端报一个窗口的大小，叫 <code>Advertised window</code></p><p>为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p><p>发送端缓存里记录的内容 </p><ul><li><p>第一部分：已经发送并且已经确认的包。 </p></li><li><p>第二部分：已经发送但是尚未确认的包。</p></li><li><p>第三部分：尚未发送但是马上准备发送的包。</p></li><li><p>第四部分：尚未发送但是暂时不准备发送的包。</p></li></ul><p>接收端缓存里记录的内容 </p><ul><li><p>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的。</p></li><li><p>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。</p></li><li><p>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</p></li></ul><h4 id="13-2-顺序问题与丢包问题"><a href="#13-2-顺序问题与丢包问题" class="headerlink" title="13.2 顺序问题与丢包问题"></a>13.2 顺序问题与丢包问题</h4><p><strong>超时重试</strong>： 对于每一个发送的包，还没有进行ACK包确认的，都设置一个定时器，超过时间就重新尝试，时间必须大于往返时间RTT,否则也会引起不必要重传，也不宜过长，时间变长，那么访问时间就会变慢了</p><p><strong>超时间加倍</strong>： 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</p><p><strong>快速重传的机制：</strong> </p><p>第一种办法： </p><p>当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段</p><p>第二种办法： </p><p><code>Selective Acknowledgment （SACK）</code> : 这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。</p><h4 id="13-3-流量控制问题"><a href="#13-3-流量控制问题" class="headerlink" title="13.3 流量控制问题"></a>13.3 流量控制问题</h4><p>发送端发送的每一个数据包，服务端都要给一个确认包（ACK）.确认它收到了。 服务端给发送端发送的确认包（ACK包）中，同时会携带一个窗口的大小。 </p><p>这个窗口的大小就代表目前服务器端的处理能力。（接收端最大缓存量-接收已确认但还未被应用层读取的部分）。 这个窗口的大小也是时时刻刻在变化的，可能接收方再发送数据包4的ACK时，窗口大小为9。</p><p>此时应用层的程序疯狂去接收已接收并且已确认的缓存，没准接收方再发送数据包5的ACK时，窗口的大小就变为了14了呢。</p><p><strong>还要注意</strong>： 当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。</p><h4 id="13-4-拥塞控制问题"><a href="#13-4-拥塞控制问题" class="headerlink" title="13.4 拥塞控制问题"></a>13.4 拥塞控制问题</h4><p>也是通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。</p><p>**拥塞控制作用: ** 就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p><p>指数性的增长,线性增长</p><h4 id="13-5-TCP-BBR-拥塞算法"><a href="#13-5-TCP-BBR-拥塞算法" class="headerlink" title="13.5 TCP BBR 拥塞算法"></a>13.5 TCP BBR 拥塞算法</h4><p>解决拥塞控制带来的俩个问题： </p><p>第一个问题是： 丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。</p><p>第二个问题是：  TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。</p><p>为了优化这两个问题，后来有了 TCP BBR 拥塞算法。它企图找到一个平衡点，就是通过不断地加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二层到三层知识笔记</title>
    <link href="/2020/12/05/%E4%BA%8C%E5%B1%82%E5%88%B0%E4%B8%89%E5%B1%82%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/%E4%BA%8C%E5%B1%82%E5%88%B0%E4%B8%89%E5%B1%82%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>上个笔记我们知道IP地址的诞生，那么机器一旦有了IP，就可以在网络的环境和其他机器进行沟通了</p><p>如果我们宿舍内俩个人需要通过电脑来玩一个游戏比如cs5， 这时候我们就需要建立一个局域网，让俩台</p><p>电脑能够连在这个局域网中</p><h3 id="1-先来说几个词语解释"><a href="#1-先来说几个词语解释" class="headerlink" title="1 先来说几个词语解释"></a>1 先来说几个词语解释</h3><ul><li><p>全双工：可以同时发送和接收信号</p></li><li><p>半双工：互相协调，都可以想对方发，但是需要协调</p></li><li><p>单工： 永远只能是一方发一方收</p></li></ul><h3 id="2-第一层-物理层"><a href="#2-第一层-物理层" class="headerlink" title="2  第一层 物理层"></a>2  第一层 物理层</h3><p>如何来构建一个小的局域网(LAN) ？如果是三台电脑呢？</p><ol><li>我们可以通过用网线的方式把俩台电脑进行连接上（以前需要用交叉线方式，现在网卡自适应）</li><li>Hub集线器：这个设备有多个扣，可以将多个电脑连接，集线器没有大脑 ，会将收到的每个字节，都复制到其他端口上去（采取的是广播模式）</li></ol><h3 id="3-第二层（数据链路层）"><a href="#3-第二层（数据链路层）" class="headerlink" title="3 第二层（数据链路层）"></a>3 第二层（数据链路层）</h3><p>由于hub采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都可以收到，这就比较麻烦 需要我们来解决几个问题</p><h4 id="3-1-大家都在发，包混乱？谁先发，谁后发？"><a href="#3-1-大家都在发，包混乱？谁先发，谁后发？" class="headerlink" title="3.1 大家都在发，包混乱？谁先发，谁后发？"></a>3.1 大家都在发，包混乱？谁先发，谁后发？</h4><p>首先这是一个MAC 层（第二层，数据链路层）需要来解决的  ,<code>MAC</code> 全称 <code>Medium Access Contron</code> ：媒体访问控制。主要是控制谁先发，谁后发的问题，是通过多路访问协议来实现，通过下面三种方式</p><ul><li>信道划分: 每个车一个车道，各走各的</li><li>轮流协议: 相当于单双号出行</li><li>随机接入协议: 先出门上路，发现堵住了，就回去，然后错过高峰再出来，著名的以太网。用的这个方式</li></ul><h4 id="3-2-这个包是发给谁的？谁应该接收？"><a href="#3-2-这个包是发给谁的？谁应该接收？" class="headerlink" title="3.2  这个包是发给谁的？谁应该接收？"></a>3.2  这个包是发给谁的？谁应该接收？</h4><p>解决这个问题就要涉及到第二层的 <code>网络包格式</code> ，对于以太网 第二层的开始就是目标的MAC地址和源的MAC地址</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205111328317.png" alt="image-20201205111328317"></p><p>接下来是类型，大部分的类型是 IP 数据包，然后 IP 里面包含 TCP、UDP，以及 HTTP 等，这都是里层封装的事情。</p><p>有了这个目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80 </p><p>于是将请求提交给 nginx，nginx 返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。</p><h4 id="3-3-如果发送的时候出现了错误，怎么办"><a href="#3-3-如果发送的时候出现了错误，怎么办" class="headerlink" title="3.3 如果发送的时候出现了错误，怎么办"></a>3.3 如果发送的时候出现了错误，怎么办</h4><p>对于以太网，第二层的最后面是 CRC，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。</p><h4 id="3-4-如果不知道MAC地址-怎么办？"><a href="#3-4-如果不知道MAC地址-怎么办？" class="headerlink" title="3.4 如果不知道MAC地址 怎么办？"></a>3.4 如果不知道MAC地址 怎么办？</h4><p>通过<code>ARP协议</code> 就是已知IP地址，求MAC地址的协议 </p><p>前面我们说过，在一个局域网里面，不知道MAC地址怎么办？基本靠吼，发送一个广播包，谁使这个IP，就谁来回答</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205112054706.png" alt="image-20201205112054706"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205112140702.png" alt="image-20201205112140702"></p><p>为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。</p><h4 id="3-5-局域网"><a href="#3-5-局域网" class="headerlink" title="3.5 局域网"></a>3.5 局域网</h4><p>我们需要一个设备能够记住每个口的电脑MAC ，这样子我能以后在发送包的时候，就可以不用广播，避免了浪费，然后检查一下目标MAC地址，根据策略转发，这个设备是个二层设备，称为 交换机 (简单的解释理解)</p><p>交换机是有学习功能的，当第一次发送数据包的时候，会记录一个端口和MAC的映射关系,所以等过了一段时间，整个网络的结构就有了，这时候就不需要广播了。。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。</p><h3 id="4-交换机"><a href="#4-交换机" class="headerlink" title="4 交换机"></a>4 交换机</h3><h4 id="4-1-首先说明下交换机和hub的区别"><a href="#4-1-首先说明下交换机和hub的区别" class="headerlink" title="4.1 首先说明下交换机和hub的区别"></a>4.1 首先说明下交换机和hub的区别</h4><pre><code class="hljs objectivec">Hub：<span class="hljs-number">1.</span>一个广播域，一个冲突域。<span class="hljs-number">2.</span>传输数据的过程中易产生冲突，带宽利用率不高交换机：<span class="hljs-number">1.</span>在划分vlan的前提下可以实现多个广播域，每个接口都是一个单独的冲突域<span class="hljs-number">2.</span>通过自我学习的方法可以构建出<span class="hljs-built_in">CAM</span>表，并基于<span class="hljs-built_in">CAM</span>进行转发数据。<span class="hljs-number">3.</span>支持生成树算法。可以构建出物理有环，逻辑无环的网络，网络冗余和数据传输效率都甩Hub好几条街。SW是目前组网的基本设备之一。</code></pre><h4 id="4-1-拓扑结构"><a href="#4-1-拓扑结构" class="headerlink" title="4.1 拓扑结构"></a>4.1 拓扑结构</h4><p>其实就是由多个交换机组织起来的一种结构，当然交换机多的时候，难免会产生环路</p><p>就是绕了一圈，从起点又回到起点</p><h4 id="4-2-解决常见的环路问题"><a href="#4-2-解决常见的环路问题" class="headerlink" title="4.2 解决常见的环路问题"></a>4.2 解决常见的环路问题</h4><p>在数据结构中有一个方法叫做<code>最小生成树</code> 有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作<code> STP</code>，全称 <code>Spanning Tree Protocol</code>。</p><p>在STP协议里面有很多概念</p><ul><li>Root Bridge: 根交换机 </li><li>Designated Bridges: 指定交换机</li><li>Bridge Protocal Data Units(BPDU)：网桥协议数据单元</li><li>Priority Vector ： 优先级向量 就是一组 ID 数目 <ul><li>Root Bridge ID </li><li>Root Path Cost</li><li>Bridge ID and Port ID</li></ul></li></ul><h4 id="4-3-如何解决广播问题和安全问题？"><a href="#4-3-如何解决广播问题和安全问题？" class="headerlink" title="4.3 如何解决广播问题和安全问题？"></a>4.3 如何解决广播问题和安全问题？</h4><p>如果机器多了 交换机多了 ，也难免会由广播的问题， 由于我们在同一个广播域里面，遇到一个会抓包的脚本小子，就能够抓到这些包，然后进行分析，可能会看到敏感信息 </p><p><strong>我们有俩种办法</strong></p><ul><li><p>物理隔离： 每个部门单独一台交换机，如果部门人少，交换机口多了就会照成浪费</p></li><li><p>虚拟隔离：<code>VLAN</code>虚拟局域网，在一个交换机会连属于多个局域网的机器 </p></li></ul><p><strong>那么是怎么区分那个局域网呢？</strong></p><p>需要在原来的二层头上加一个TAG 里面由<code>VLAN ID</code> 一共是12位，可以划分<code>4096个VLAN</code></p><p>如果在大型云计算平台公司这显然使不够用的，后面就要引入其他的办法来解决。</p><p>这时候需要交换机支持VLAN功能，然后有一种接口叫做<code>Trunk</code>接口，可以转发任何VLAN的口，交换机之间通过这个口进行连接，从而解决广播问题和安全问题</p><h3 id="5-ICMP-协议"><a href="#5-ICMP-协议" class="headerlink" title="5 ICMP 协议"></a>5 ICMP 协议</h3><p><code>ICMP </code>: 全称 <code>Internet Control Message Protocol</code>，就是互联网控制报文协议</p><p>如果遇到网络不通的时候，就会想到一个命令 ping 一下，</p><p>ping 就是基于ICMP 协议工作的 </p><p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱。</p><p>ICMP 报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为 8，主动请求的应答为 0</p><h4 id="5-1-查询报文类型"><a href="#5-1-查询报文类型" class="headerlink" title="5.1 查询报文类型"></a>5.1 查询报文类型</h4><p>常用的ping就是查询报文类型，是一种主动请求，并且获取主动应答的ICMP协议</p><p>ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><ul><li><p>ping主动请求： ICMP ECHO REQUEST</p></li><li><p>ping主动请求回复： ICMP ECHO REPLY</p></li></ul><p>比原生ICMP多的俩个字段，就是字面意思</p><ul><li><p>标识符</p></li><li><p>序号</p></li></ul><h4 id="5-2-差错报文类型"><a href="#5-2-差错报文类型" class="headerlink" title="5.2 差错报文类型"></a>5.2 差错报文类型</h4><p>报错报文的例子： <strong>终点不可达为 3，源抑制为 4，超时为 11，重定向为 5</strong></p><p>这个解释根据具体场景很好： </p><p><strong>第一种是终点不可达</strong>。小兵：报告主公，您让把粮草送到张将军那里，结果没有送到。如果你是主公，你肯定会问，为啥送不到？具体的原因在代码中表示就是 </p><p>网络不可达代码为 0，主机不可达代码为 1，协议不可达代码为 2，端口不可达代码为 3，需要进行分片但设置了不分片位代码为 4。</p><p>具体的场景就像这样：</p><ul><li>网络不可达：主公，找不到地方呀？主机不可达：主公，找到地方没这个人呀？</li><li>协议不可达：主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说 12345！</li><li>端口不可达：主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。</li><li>需要进行分片但设置了不分片位：主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了</li></ul><p><strong>第二种是源站抑制</strong>，也就是让源站放慢发送速度。小兵：报告主公，您粮草送的太多了吃不完。</p><p><strong>第三种是时间超时</strong>，也就是超过网络包的生存时间还是没到。小兵：报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。</p><p><strong>第四种是路由重定向</strong>，也就是让下次发给另一个路由器。小兵：报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。</p><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><h4 id="5-3-ping-查询报文类型的使用"><a href="#5-3-ping-查询报文类型的使用" class="headerlink" title="5.3 ping 查询报文类型的使用"></a>5.3 ping 查询报文类型的使用</h4><p>假定主机 A 的 IP 地址是 192.168.1.1，主机 B 的 IP 地址是 192.168.1.2，它们都在同一个子网。那当你在主机 A 上运行“ping 192.168.1.2”后，会发生什么呢?</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。</p><p>接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205131429891.png" alt="image-20201205131429891"></p><p><strong>1.5.4 Traceroute：差错报文类型的使用</strong></p><p>所以，Traceroute 的第一个作用就是故意设置特殊的 TTL，， 来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。</p><p><strong>注意每次经过一个路由器，TTL值就会减1</strong></p><p>如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。那大军前行就带一顿饭，试一试走多远会被饿死，然后找个哨探回来报告，那我就知道大军只带一顿饭能走多远了。</p><p>接下来，将 TTL 设置为 2。第一关过了，第二关就“牺牲”了，那我就知道第二关有多远。如此反复，直到到达目的主机。这样，Traceroute 就拿到了所有的路由器 IP。当然，有的路由器压根不会回这个 ICMP。这也是 Traceroute 一个公网的地址，看不到中间路由的原因。</p><p>怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。</p><p>这就相当于故意派人去西天如来那里去请一本《道德经》，结果人家信佛不信道，消息就会被打出来。被打的消息传回来，你就知道西天是能够到达的。为什么不去取《心经》呢？因为 UDP 是无连接的。也就是说这人一派出去，你就得不到任何音信。你无法区别到底是半路走丢了，还是真的信佛遁入空门了，只有让人家打出来，你才会得到消息。</p><p><strong>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU</strong>。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，类型为“需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205131351982.png" alt="image-20201205131351982"></p><h3 id="6-网关"><a href="#6-网关" class="headerlink" title="6 网关"></a>6 网关</h3><p>相当于给网络指一个方向</p><h4 id="6-1-网关"><a href="#6-1-网关" class="headerlink" title="6.1 网关"></a>6.1 网关</h4><p>网关往往是一个路由器，是一个三层转发的设备。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备 </p><h4 id="6-2-静态路由"><a href="#6-2-静态路由" class="headerlink" title="6.2 静态路由"></a>6.2 静态路由</h4><p>静态路由 是人手工配置上的一条条规则，是单向的，缺乏灵活性</p><p>下一跳</p><p>是路由器根据路由表将数据转发到下一个端口地址</p><h4 id="6-3-跨局域网通信"><a href="#6-3-跨局域网通信" class="headerlink" title="6.3 跨局域网通信"></a>6.3 跨局域网通信</h4><p>当我们跨局域网通信的时候,比如使一个业务A访问业务B，俩个服务是俩个网段 </p><p>这时候就需要通过路由器(三层ip)来指路，在路由器上配置一条静态路由指明下一跳地址 </p><p>然后我们通过静态路由进入业务B的局域网，找到业务B，在这个期间MAC地址是要改变的，但是IP地址不变</p><h4 id="6-4-访问公网服务的时候"><a href="#6-4-访问公网服务的时候" class="headerlink" title="6.4 访问公网服务的时候"></a>6.4 访问公网服务的时候</h4><p>当我们跨局域网访问的时候，是需要做NAT 转换的</p><p>很多办公室访问外网的时候，也是被 NAT 过的，因为不可能办公室里面的 IP 也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口 IP 地址。你可以通过 <a href="https://www.whatismyip.com/">https://www.whatismyip.com/</a> 查看自己的出口 IP 地址。</p><h3 id="7-路由器"><a href="#7-路由器" class="headerlink" title="7 路由器"></a>7 路由器</h3><h4 id="7-1配置路由"><a href="#7-1配置路由" class="headerlink" title="7.1配置路由"></a>7.1配置路由</h4><p>路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为路由表。</p><p>一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。</p><ul><li>目的网络：这个包想去哪儿？</li><li>出口设备：将包从哪个口扔出去？</li><li>下一跳网关：下一个路由器的地址。</li></ul><h4 id="7-2-配置路由"><a href="#7-2-配置路由" class="headerlink" title="7.2 配置路由"></a>7.2 配置路由</h4><p>通过 route 命令和 ip route 命令都可以进行查询或者配置。例如，我们设置 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p><h4 id="7-3-策略路由"><a href="#7-3-策略路由" class="headerlink" title="7.3  策略路由"></a>7.3  策略路由</h4><p>可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由</p><pre><code class="hljs shell">ip rule add from 192.168.1.0/24 table 10 ip rule add from 192.168.2.0/24 table 20</code></pre><h4 id="7-3-动态路由算法"><a href="#7-3-动态路由算法" class="headerlink" title="7.3 动态路由算法"></a>7.3 动态路由算法</h4><p>网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。</p><p>动态路由好处： <strong>所以使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化</strong></p><h5 id="7-3-1-距离矢量路由算法"><a href="#7-3-1-距离矢量路由算法" class="headerlink" title="7.3.1  距离矢量路由算法"></a>7.3.1  距离矢量路由算法</h5><p>第一大类的算法称为<code>距离矢量路由（distance vector routing）</code>。它是基于<code> Bellman-Ford</code>算法的。</p><p><strong>第一个问题： 好消息传的快，坏消息传的慢</strong>（也就是收敛慢）</p><p>如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去</p><p>但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了</p><p><strong>第二个问题： 每次发送的时候，发送整个全局路由表</strong></p><p>网络大了，谁也受不了，所以最早的路由协议 RIP 就是这个算法。它适用于小型网络（小于 15 跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了</p><h5 id="7-4-2-链路状态路由算法"><a href="#7-4-2-链路状态路由算法" class="headerlink" title="7.4.2 链路状态路由算法"></a>7.4.2 链路状态路由算法</h5><p>第二大类算法是<code>链路状态路由（link state routing）</code>，基于<code>Dijkstra</code>算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径</p><p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p><h4 id="7-5-动态路由协议"><a href="#7-5-动态路由协议" class="headerlink" title="7.5 动态路由协议"></a>7.5 动态路由协议</h4><h5 id="7-4-1-基于链路状态路由算法的-OSPF"><a href="#7-4-1-基于链路状态路由算法的-OSPF" class="headerlink" title="7.4.1  基于链路状态路由算法的 OSPF"></a>7.4.1  基于链路状态路由算法的 OSPF</h5><p><code>OSPF</code>: Open Shortest Path First，开放式最短路径优先</p><p><code>IGP</code>: 内部网关协议 主要是在数据中心内部，用于路由决策的</p><p>内部网关协议重点就是找到最短的路径，在一个组织内部，路径最短为最优 </p><p>但有时候ospf 可以发现多个最短路径。可以在多个路径中进行<code>负载均衡</code>,这常常被称为</p><p><code>等价路由</code></p><p><strong>这里顺便说下一些电商平台前端架构</strong> </p><p>因为有了等价路由，可以分摊流量，还可以一条路不通的时候，走另外一个条</p><p>相当于既有 <code>高可用</code>，还可以<code>负载均衡</code> 这是一个保障公司网络架构稳定的一个好方案</p><p>那么一般大型公司前端架构就会采用<code>lvs + ospf</code> 方式来接入网络中，为了抗住大流量 </p><p><code>网卡</code>还可以做<code>bond</code> 进行流量进行分担</p><h5 id="7-4-2-基于距离矢量路由算法的-BGP"><a href="#7-4-2-基于距离矢量路由算法的-BGP" class="headerlink" title="7.4.2  基于距离矢量路由算法的 BGP"></a>7.4.2  基于距离矢量路由算法的 BGP</h5><p><code>BGP</code>: 外网路由协议（Border Gateway Protocol，简称 BGP ）</p><p>再网络的世界里面 每个公网成为自治系统<code>AS</code>（Autonomous System）自治系统分几种类型。</p><ul><li><code>Stub AS</code>: 对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。</li><li><code>MultiHomed AS</code>: 可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。</li><li><code>Transit AS</code>: 有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。</li></ul><p>每个自治系统都有边界路由器，通过它和外面的世界建立联系。</p><p><strong>BGP分为俩类</strong></p><ul><li><p>eBGP: 自治系统间， 边界路由器之间使用eBGP广播路由</p></li><li><p>iBGP: 自治系统内部，使用iBGP,使内部的路由器能够找到到达外网目的的最好的边界路由器</p></li></ul><p>BGP 协议使用的算法是路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络通信协议笔记</title>
    <link href="/2020/12/05/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成“协议”，通天塔的计划就失败了</p><p>但是千年以后，有一种叫“程序猿”的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打造这互联网世界的通天塔。如今的世界，正是因为互联网，才连接在一起。   </p><p>只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。</p><h3 id="1-1-当我们输入URL-发生了什么？"><a href="#1-1-当我们输入URL-发生了什么？" class="headerlink" title="1.1 当我们输入URL 发生了什么？"></a>1.1 当我们输入URL 发生了什么？</h3><p>首先我们在浏览器里面输入<a href="https://www.budongshu.cn/">https://www.budongshu.cn</a> 这是一个<code>URL</code>，浏览器不知道它要去的具体地点，也不知道如何访问，于是去<code>DNS</code>(相当于地址薄)中去查找，经过查找后，会得到一个<code>IP</code>地址，相当于是互联网的门牌号</p><p>我们知道了目标地址，浏览器就会打包它的请求，普通的浏览器请求一般是使用<code>http</code>协议，但是对于现在来讲比如购物的请求，是需要加密的，会使用<code>https</code>协议，无论什么协议，最后都会里面写清楚<code>你要买什么 和买多少</code></p><p>DNS,HTTP,HTTPS 所在的层是我们称为： <strong>应用层</strong>。经过应用层封装后，浏览器会将应用层包交给下一层去完成</p><p>通过socket 编程来实现，我们就到了下一层是<strong>传输层</strong></p><p>传输层包括俩个协议，一个是tcp一个是udp，那么对于购物支付来讲，肯定是会使用tcp协议，所谓的面相连接就是，tcp会保证这个包能够到达目的地，如果不能够到达，就会重新发送，直至到达</p><p>tcp协议里面会有俩个端口 ,一个是浏览器监听的随机端口，一个是我要访问的目的地址服务器端监听的端口，</p><p>我们服务器端的操作系统会通过内核来判断，它得到的包应该是属于那个进程</p><p>传输层封装完毕后，浏览器会将包交给操作系统的网络层。网络层的协议是 IP 协议。在 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。</p><p>操作系统知道目标ip后，就会进行判断，这个ip地址是在本地，还是外地呢，从ip地址就可以看出来(ip地址每一段都有规划的，所以可以看出来)，它不属于本地，应该在遥远的地方</p><p>我们去远方就需要，比如要去海外就要去海关，我们去远方就要去<code> 网关</code>, 操作系统再启动的时候，会被DHCP协议配置分配一个随机IP地址以及默认的网关的IP地址10.1.1.1。</p><p>那么操作系统如何将IP地址发送给网关呢？ 在本地通信基本靠吼，于是操作系统大吼一声，谁是网关10.1.1.1啊?</p><p>有人回答，他就是，他在本地地址村东头 </p><ul><li>本地地址： <code>MAC地址</code></li><li>大吼一声： <code>ARP协议</code></li></ul><p>于是操作系统将 IP 包交给了下一层，也就是 MAC 层。网卡再将包发出去。由于这个包里面是有 MAC 地址的，因而它能够到达网关。</p><p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。</p><p>路由器相当于怎么讲呢？比如如果我们国家是一个大的局域网，那么连接俩个国家的通信就是路由器，而在我们国家内部，就可以使用本地的地址MAC进行通信（也就是通过交换机）</p><p>一旦我们出国了，手里拿着源ip和目标IP，应该怎么走，这种沟通的协议称为路由协议，常用的有 OSPF 和 BGP。</p><p>当我们网络包到达下一个国家的时候，还是要使用国家内部MAC地址 ，通过下一个国家的MAC地址，找个下一个国家，然后在问下一步怎么走，一直走到最后一个国家。</p><p>最后一个国家知道这个网络包要去的地方，于是对着这个国家本地地址大吼一声，谁是目标IP？目标服务器就会回复一个MAC地址，网络包过关后，通过这个MAC地址就能找到目标服务器。</p><p>目标服务器发现MAC地址对上了，你找的是我，然后去下MAC头，发送给操作系统的网络层，发现IP也对上了，就取下IP头，IP头里面封装的是TCP协议，然后交给传输层，即TCP层</p><p>在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。</p><p>如果过一段时间还是没到，发送端的 TCP 层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。<code>这个重试绝非你的浏览器重新将下单这个动作重新请求一次</code>。对于浏览器来讲，就发送了一次下单请求，TCP 层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。</p><p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。</p><p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。</p><p>然后通过系统调用通知进程,当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功</p><h3 id="1-2-分层模型"><a href="#1-2-分层模型" class="headerlink" title="1.2 分层模型"></a>1.2 分层模型</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204224331654.png" alt="image-20201204224331654"></p><h3 id="1-3-MAC地址知识补充"><a href="#1-3-MAC地址知识补充" class="headerlink" title="1.3 MAC地址知识补充"></a>1.3 MAC地址知识补充</h3><p> 网卡MAC码是由全球惟一的一个固定组织来分配的，未经认证和授权的厂家无权生产网卡。每块网卡都有一个固定的卡号，并且任何正规厂家生产的网卡上都直接标明了卡号，一般为一组12位的16进制数。其中前6位代表网卡的生产厂商。后面的位数是设备号。当然在操作系统级别改Mac地址又是一种说法</p><h3 id="1-4-网络为什么要分层"><a href="#1-4-网络为什么要分层" class="headerlink" title="1.4 网络为什么要分层"></a>1.4 网络为什么要分层</h3><p>复杂的程序都需要分层，比如我们架构网站<code>前端 后端 缓存 中间件 数据库 存储 </code>  ，我们通过分层使每一层各司其职</p><p>明确自己的职责，这样也不会混乱，还很清晰明了</p><h3 id="1-5-层与层之间的关系"><a href="#1-5-层与层之间的关系" class="headerlink" title="1.5 层与层之间的关系"></a>1.5 层与层之间的关系</h3><h4 id="1-5-1-打个比喻来说明层与层之间的关系"><a href="#1-5-1-打个比喻来说明层与层之间的关系" class="headerlink" title="1.5.1 打个比喻来说明层与层之间的关系"></a>1.5.1 打个比喻来说明层与层之间的关系</h4><p>通信协议就像没有天桥的双子楼，要从A座的24层到达B座24层就得先下楼梯再上楼梯，其他协议也是如此，比如4G</p><p>很像你去找你女朋友。 你=&gt;穿内衣=&gt;穿衣服=&gt;坐车=&gt;转车到地方=&gt;脱衣服=&gt;脱内衣=&gt;见女朋友</p><h4 id="1-5-2-第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？"><a href="#1-5-2-第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？" class="headerlink" title="1.5.2 第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？"></a>1.5.2 第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？</h4><p>当然使TCP发送每一个消息，都会带着IP层和MAC层，因为TCP每次发送一个消息，IP层和MAC层的所有机制</p><p>都要运行一遍。其实IP层和MAC层也为此忙活好久。</p><p><strong>这里要记住一点：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</strong></p><p>所以，<strong>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。</strong></p><h4 id="1-5-3-第二个问题-知道IP地址就直接发消息，要MAC地址干啥？"><a href="#1-5-3-第二个问题-知道IP地址就直接发消息，要MAC地址干啥？" class="headerlink" title="1.5.3  第二个问题,知道IP地址就直接发消息，要MAC地址干啥？"></a>1.5.3  第二个问题,知道IP地址就直接发消息，要MAC地址干啥？</h4><ol><li>IP是三层协议，必须封装在二层协议（比如以太网协议）中，MAC工作在二层，然后二层协议再通过硬件设备把网络包发出去，所以需要MAC地址（二层地址）。</li><li>IP，Internet Protocol，网络互联协议，它设计出来是为了互联不同的网络的，他的作用是在不同网络之间做寻址。</li><li>所以没有MAC地址消息是发不出去的。</li></ol><h3 id="1-6-IP地址"><a href="#1-6-IP地址" class="headerlink" title="1.6 IP地址"></a>1.6 IP地址</h3><blockquote><p>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码</p></blockquote><p>比如10.1.1.1 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。这样产生的 IP 地址的数量很快就不够用了。因为当时设计 IP 地址的时候，哪知道今天会有这么多的计算机啊！因为不够用，于是就有了 IPv6，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64。这个有 128 位，现在看来是够了，但是未来的事情谁知道呢？</p><h4 id="1-6-1-ip地址被分为五类"><a href="#1-6-1-ip地址被分为五类" class="headerlink" title="1.6.1 ip地址被分为五类"></a>1.6.1 ip地址被分为五类</h4><p>网络号： 用于识别主机所在的网络</p><p>主机号： 用于识别该网络中的主机</p><p>IP地址分为五类,各类可容纳的地址数目不同。</p><p>A类保留给政府机构</p><p>B类分配给中等规模的公司</p><p>C类分配给任何需要的人</p><p>D类用于<a href="http://baike.baidu.com/view/492256.htm">组播</a>   </p><p>E类用于实验 </p><p>A、B、C三类IP地址的特征：当将IP地址写成<a href="http://baike.baidu.com/view/18536.htm">二进制</a>形式时，A类地址的第一位总是0，B类地址的前两位总是10，C类地址的前三位总是110</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204230758874.png"></p><p>在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是网络号，后面一部分是主机号</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204230821087.png" alt="image-20201204230821087"></p><p>这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B 类地址能包含的最大主机数量又太多了。6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</p><h4 id="1-6-2-无类型域间选路（CIDR）"><a href="#1-6-2-无类型域间选路（CIDR）" class="headerlink" title="1.6.2 无类型域间选路（CIDR）"></a>1.6.2 无类型域间选路（CIDR）</h4><p>10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号</p><p>网络地址:  子网范围内的第一个地址</p><p>广播地址:  子网范围内最后一个地址</p><p>网络号： 将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</p><p>主机号： 32  减去 网络号 = 主机号</p><h4 id="1-6-3-私有地址"><a href="#1-6-3-私有地址" class="headerlink" title="1.6.3 私有地址"></a>1.6.3 私有地址</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204234000602.png" alt="image-20201204234000602"></p><p>公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问。</p><h4 id="1-6-4-CIDR-子网划分"><a href="#1-6-4-CIDR-子网划分" class="headerlink" title="1.6.4 CIDR 子网划分"></a>1.6.4 CIDR 子网划分</h4><p>子网划分(subnetting)的优点:<br>1.减少网络流量<br>2.提高网络性能<br>3.简化管理<br>4.易于扩大地理范围</p><p><strong>2^9 = 512</strong></p><p><strong>2^8 = 256</strong></p><p><strong>2^7 = 128</strong>     </p><p><strong>2^6 = 64</strong></p><p><strong>2^5 = 32</strong></p><p><strong>2^3 = 8</strong></p><p><strong>2^0 = 1</strong></p><p>首先，我们看一个考试中常见的题型：一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址。<br>常规办法是把这个主机地址和子网掩码都换算成二进制数，两者进行逻辑与运算后即可得到网络地址。其实大家只要仔细想想，可以得到另一个方法：255.255.255.224的掩码所容纳的IP地址有256－224＝32个（包括网络地址和广播地址）</p><p>那么具有这种掩码的网络地址一定是32的倍数。而网络地址是子网IP地址的开始，广播地址是结束，可使用的主机地址在这个范围内，因此略小于137而又是32的倍数的只有128，所以得出网络地址是202.112.14.128。而广播地址就是下一个网络的网络地址减1。而下一个32的倍数是160，因此可以得到广播地址为202.112.14.159。</p><p>lo 全称是 loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现 </p><h4 id="1-6-5-MAC地址"><a href="#1-6-5-MAC地址" class="headerlink" title="1.6.5 MAC地址"></a>1.6.5 MAC地址</h4><p>在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。</p><p>MAC 地址是一个很容易让人“误解”的地址。因为 MAC 地址号称全局唯一，不会有两个网卡有相同的 MAC 地址，而且网卡自生产出来，就带着这个地址。很多人看到这里就会想，既然这样，整个互联网的通信，全部用 MAC 地址好了，只要知道了对方的 MAC 地址，就可以把信息传过去。这样当然是不行的。 一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能。 而有门牌号码属性的 IP 地址，才是有远程定位功能的。</p><p>所以MAC通信是有范围的，一般使局限在一个局域网里面，同局域网是可以通过MAC来通信的，一旦跨子网 </p><p>那么MAC地址就需要IP来帮忙了。</p><h4 id="1-6-6-网络设备的状态标识"><a href="#1-6-6-网络设备的状态标识" class="headerlink" title="1.6.6 网络设备的状态标识"></a>1.6.6 网络设备的状态标识</h4><p>UP 表示网卡处于启动的状态；</p><p>BROADCAST 表示这个网卡有广播地址，可以发送广播包；</p><p>MULTICAST 表示网卡可以发送多播包；</p><p>LOWER_UP 表示 L1 是启动的，也即网线插着呢 </p><p><strong>MTU1500 是指什么意思呢？是哪一层的概念呢？最大传输单元 MTU 为 1500，这是以太网的默认值。</strong></p><p>我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p><p><strong>qdisc pfifo_fast</strong>  </p><p>qdisc全称： queueing discipline 中文叫做排队队列，内核如果需要通过某个网络接口发送数据包，它都需要按照</p><p>为这个接口配置的 qdisc（排队规则）把数据报加入队列</p><p><strong>pfifo</strong></p><p>最简单的qdiso使 pfifo 他不对进入的数据做人任何的处理，数据报采用先入先出的方式通过队列，pfifo_fast 稍微复杂一点，他的队列包括三个波段(band),在每个波段里面，使用先进先出的规则</p><p>三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。</p><p>数据包是按照服务类型（Type of Service，TOS）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><h3 id="1-7-动态主机配置协议（DHCP）"><a href="#1-7-动态主机配置协议（DHCP）" class="headerlink" title="1.7 动态主机配置协议（DHCP）"></a>1.7 动态主机配置协议（DHCP）</h3><p>动态主机配置协议（Dynamic Host Configuration Protocol），简称 DHCP。</p><h4 id="1-7-1-解析dhcp工作方式"><a href="#1-7-1-解析dhcp工作方式" class="headerlink" title="1.7.1 解析dhcp工作方式"></a>1.7.1 解析dhcp工作方式</h4><p>当一台机器需要通过自己MAC地址，发送一个广播包，目的IP地址255.255.255.255</p><p>广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205012215824.png" alt="image-20201205012215824"></p><h4 id="1-7-2-如果有多个DHCP-server服务器"><a href="#1-7-2-如果有多个DHCP-server服务器" class="headerlink" title="1.7.2 如果有多个DHCP server服务器"></a>1.7.2 如果有多个DHCP server服务器</h4><p>它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。</p><h4 id="1-7-3-IP-地址的收回和续租"><a href="#1-7-3-IP-地址的收回和续租" class="headerlink" title="1.7.3 IP 地址的收回和续租"></a>1.7.3 IP 地址的收回和续租</h4><p>客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。</p><h4 id="1-7-4-预启动执行环境（PXE）"><a href="#1-7-4-预启动执行环境（PXE）" class="headerlink" title="1.7.4 预启动执行环境（PXE）"></a>1.7.4 预启动执行环境（PXE）</h4><p>我们可以通过pxe来实现自动批量安装系统，这事儿其实仔细一想，还是挺有难度的。安装操作系统，应该有个光盘吧。数据中心里不能用光盘吧，想了一个办法就是，可以将光盘里面要安装的操作系统放在一个服务器上，让客户端去下载。但是客户端放在哪里呢？它怎么知道去哪个服务器上下载呢？客户端总得安装在一个操作系统上呀，可是这个客户端本来就是用来安装操作系统的呀？</p><p>其实，这个过程和操作系统启动的过程有点儿像。首先，启动 BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的 MBR 启动扇区，将 GRUB 启动起来；然后将权力交给 GRUB，GRUB 加载内核、加载作为根文件系统的 initramfs 文件；然后将权力交给内核；最后内核启动，初始化整个操作系统</p><p>我们需要DHCP server 有一段这样的配置</p><pre><code class="hljs shell">ddns-update-style interim;ignore client-updates;allow booting;allow bootp;subnet 192.168.1.0 netmask 255.255.255.0&#123;option routers 192.168.1.1;option subnet-mask 255.255.255.0;option time-offset -18000;default-lease-time 21600;max-lease-time 43200;range dynamic-bootp 192.168.1.240 192.168.1.250;filename &quot;pxelinux.0&quot;;       #需要下载的启动文件filenamenext-server 192.168.1.180;   #指向pxe服务器的地址&#125;</code></pre><p>pxe 工作执行流程</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205011046135.png" alt="image-20201205011046135"></p><p>注意： <strong>安装完成后，将提示重新引导计算机。在重新引导的过程中将BIOS修改回从硬盘启动就可以了。</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp/ip 协议簇笔记</title>
    <link href="/2020/12/04/tcp-ip-%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/04/tcp-ip-%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>tcp/ip 协议簇它是基于tcp/ip协议，但是它并不仅限于tcp/ip 俩种协议,他是一个协议的泛指 </p><p>它还包括很多其他的协议,同时也分为好多层，同层之间使用相同的协议，这样体现了分层的好处</p><p>每一层只是处理自己层的协议</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204002233544.png" alt="image-20201204002233544"></p><h3 id="网络协议群"><a href="#网络协议群" class="headerlink" title="网络协议群"></a>网络协议群</h3><table><thead><tr><th>协议名称</th><th>具体协议</th></tr></thead><tbody><tr><td>应用协议</td><td>HTTP,SMTP, FTP,TELNET</td></tr><tr><td>传输协议</td><td>TCP/UDP</td></tr><tr><td>网络协议</td><td>IP/ICMP/ARP</td></tr><tr><td>路由控制协议</td><td>RIP/OSPF/BGP</td></tr></tbody></table><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位；</li></ul><p>每个层都会对所发送的数据附加一个首部，在这个首部包含了该层的必要信息，在下一层的角度看，从上一层</p><p>收到的包全部都被认为是本层的数据 </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204002515998.png" alt="image-20201204002515998"></p><h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP</p><p>TCP 提供一种面向连接的，可靠的字节流服务，流就是指不间断的数据结构</p><p>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下</p><p>虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><h3 id="TCP协议机制"><a href="#TCP协议机制" class="headerlink" title="TCP协议机制"></a>TCP协议机制</h3><ol><li><p>在一个tcp连接中，仅仅有俩方进行彼此通信，应用数据被分割成tcp认为最适合发送的数据块</p></li><li><p>当tcp发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段</p></li><li><p>当tcp收到发自tcp连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常推迟几分之一秒 deplayed ack</p></li><li><p>tcp 将保持它首部和数据的检验和 </p></li><li><p>既然tcp报文段作为ip数据报来传输，而IP数据报的到达可能会失序，如果有必要，tcp将对收到的数据进行重新排序</p></li><li><p>将收到的数据以正确的顺序交给应用层</p></li><li><p>基于全双工来进行工作</p></li></ol><h3 id="端口号和通信识别"><a href="#端口号和通信识别" class="headerlink" title="端口号和通信识别"></a>端口号和通信识别</h3><p>用于标记进程 范围在0-65535,通过五元组来识别一个通信</p><ul><li><p>知名端口号： 分布在 0~1023 之间 </p></li><li><p>端口号被正式注册：它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</p></li><li><p>Socket： 是由ip和port组合而成</p></li><li><p>五元组： 源地址，源端口，协议号，目标地址，目标端口</p></li><li><p>MTU: 网络最大传输单元</p></li></ul><h3 id="ip-header-首部"><a href="#ip-header-首部" class="headerlink" title="ip header 首部"></a>ip header 首部</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204005020380.png"></p><ul><li>Version： ip版本号</li><li>HeaderLength： 首部长度，每四个字节当做一个单位，最大位60</li><li>TypeofServer(TOS): 确保某些紧急报文可以优先到达，服务类型 (8bits)</li><li>TotalLength: 报文总长度</li><li>Identification: 每一个ip包都有一个唯一id，如果IP包被再次拆分 那么被拆分的ip包 id都是一致的</li><li>Fragment Offset: 偏移量，分片后，片与片之间的 片偏移量<ul><li>MF: 这个片已经分了好多片</li><li>DF：别分片，说明报文不允许分片</li></ul></li><li>TTL： 定义一个生命周期</li><li>Protocol：标记IP包内层协议类型,TCP 协议号6 ,UDP 的协议号17,ICMP 的协议号1,IGMP 协议号2</li><li>HeaderChecksum： 首部校验，靠tcp重转</li></ul><h3 id="tcp-header-首部"><a href="#tcp-header-首部" class="headerlink" title="tcp header 首部"></a>tcp header 首部</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204005815968.png" alt="image-20201204005815968"></p><ul><li>SequenceNumber: 每次发送报文号码，等待对方进行确认 </li><li>ACknowlegement： 确认报文号码</li><li>Reserved： 预留位</li><li>FIN： 结束标记</li><li>SYN：发送进行同步</li><li>RST: 重置</li><li>PSH： 推送</li><li>ACK:   回复确认报文</li><li>URG: 不缓冲，尽快发送到内核处理</li><li>Urgent Pointer：紧急指针 值为1代表URG生效，值为0代表不生效</li><li>TcpChecksum： tcp的校验码</li><li>有限状态机 FSM Finite State Machine</li></ul><h2 id="tcp-三次握手四次断开"><a href="#tcp-三次握手四次断开" class="headerlink" title="tcp 三次握手四次断开"></a>tcp 三次握手四次断开</h2><p>tcp连接是全双工的，俩个信道，各自断开各自的信道，所以需要四次断开</p><p>最后断开会等待2ml时间,一般是120s</p>]]></content>
    
    
    <categories>
      
      <category>tcp/ip</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 自定义域名和主题</title>
    <link href="/2020/12/03/hexo-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/"/>
    <url>/2020/12/03/hexo-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>在之前已经部署博客环境，用hexo初始化博客项目，并且已经把博客托管到了github上，通过github提供的二级域名进行访问</p><p>我们自己如果有域名，还可以绑定自己的域名进行访问博客，域名可以通过阿里云进行购买</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>这里我们通过阿里云进行购买吧，因为阿里云收购了万网，万网算是国内最大的域名注册商</p><p>购买地址: <a href="https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com">https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com</a></p><p>我这里之前购买过域名 budongshu.cn ,下面准备想使用budongshu.cn来访问这个博客</p><p><code>注意</code>: <strong>现在大部门域名都是需要 实名认证和备案的，备案的话一般需要3天到7天左右</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203102813448.png" alt="image-20201203102813448"></p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>这里面有俩种配置方法，但是原理都是一样的</p><p>通过cname 来配置 我们现在配置一个@的cname解析和www的cname解析 这样我再浏览器里面输入budongshu.cn(配置@的cname解析起的作用)和<a href="http://www.budongshu.cn/">www.budongshu.cn</a> 都会解析到budongshu.github.io 也符合我们的预期效果</p><h3 id="第一种通过cname方式"><a href="#第一种通过cname方式" class="headerlink" title="第一种通过cname方式"></a>第一种通过cname方式</h3><p>配置@的cname解析 ，解析记录值是我现在用的访问域名budongshu.github.io </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203102904219.png"></p><p>配置www的cname解析 ，解析记录值是我现在用的访问域名budongshu.github.io </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103112447.png" alt="image-20201203103112447"></p><p>最后的配置效果</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103333548.png" alt="image-20201203103333548"></p><h3 id="第二种通过解析出来的ip来配置，A记录方式"><a href="#第二种通过解析出来的ip来配置，A记录方式" class="headerlink" title="第二种通过解析出来的ip来配置，A记录方式"></a>第二种通过解析出来的ip来配置，A记录方式</h3><p>先通过ping budongshu.github.io 看一下解析ip是多少，我们这里看到是185.199.111.153 ,那么我们同样可以通过A记录的方式</p><p>来配置跳转</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103428622.png" alt="image-20201203103428622"></p><p>做一个www配置的演示 </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103636825.png" alt="image-20201203103636825"></p><h2 id="在hexo项目里面设置CNAME"><a href="#在hexo项目里面设置CNAME" class="headerlink" title="在hexo项目里面设置CNAME"></a>在hexo项目里面设置CNAME</h2><h3 id="1-1-新建文件CNAME"><a href="#1-1-新建文件CNAME" class="headerlink" title="1.1  新建文件CNAME"></a>1.1  新建文件CNAME</h3><p>在项目下，进入你的博客项目目录，在source 文件夹下面创建 CNAME 文件（没有后缀名的），填写上域名</p><p>可以通过编辑器进行编辑</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104545764.png" alt="image-20201203104545764"></p><h3 id="1-2-部署博客项目到github"><a href="#1-2-部署博客项目到github" class="headerlink" title="1.2 部署博客项目到github"></a>1.2 部署博客项目到github</h3><p> 然后我们部署hexo，通过项目里面的配置会上传到github，这里不明白可以看看我之前hexo 部署文章</p><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g -d</code></pre><h3 id="1-3-Github-要把https选项勾上"><a href="#1-3-Github-要把https选项勾上" class="headerlink" title="1.3 Github 要把https选项勾上"></a>1.3 Github 要把https选项勾上</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203105005191.png" alt="image-20201203105005191"></p><h2 id="用自定义的域名访问"><a href="#用自定义的域名访问" class="headerlink" title="用自定义的域名访问"></a>用自定义的域名访问</h2><p>完成上述步骤之后就可以在浏览器输入自己的域名访问了,因为我们配置了@ 和www 所以通过下面俩种方式访问</p><p><a href="https://budongshu.cn/">https://budongshu.cn</a> 和 <a href="https://www.budongshu.cn/">https://www.budongshu.cn</a> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203105252124.png" alt="image-20201203105252124"></p><h2 id="找一款自己喜欢的主题"><a href="#找一款自己喜欢的主题" class="headerlink" title="找一款自己喜欢的主题"></a>找一款自己喜欢的主题</h2><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a> ,这个里面有很多主题，可以任意挑选一个自己喜欢的主题，点击进去通常都有github地址</p><p>上面有安装和使用方法介绍，我这里选了一个名叫“fluid” 的主题，这是使用地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>下面截图是fluid使用介绍的部分内容</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104039041.png" alt="image-20201203104039041"></p><p> 主题效果</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104225967.png" alt="image-20201203104225967"></p><p>可以看到已经实现自定义主题了，主题这里还有很多可以自己设置的地方呢~</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 切片笔记</title>
    <link href="/2020/12/03/Go-%E5%88%87%E7%89%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/Go-%E5%88%87%E7%89%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是切片-slice"><a href="#什么是切片-slice" class="headerlink" title="什么是切片(slice)"></a>什么是切片(slice)</h2><p>slice和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生panic，但是它比数组更加的灵活，可以自动的进行扩容</p><h2 id="切片本质"><a href="#切片本质" class="headerlink" title="切片本质"></a>切片本质</h2><p>切片是由指针，长度，容量组成，切片并不是数组或者数组指针，它是通过内部指针和相关属性引用数组片段，来实现变长的方案</p><p><code>指针</code>：指向底层数组</p><p><code>长度</code>：表示切片可用元素的个数，也就是会用下标对slice进行访问时候，下标不能超过的长度 </p><p><code>容量</code>:   底层数组的元素个数，容量&gt;=长度，在底层数组不进行扩容的情况下，容量也是slice可以扩张的最大限度</p><h2 id="切片特点"><a href="#切片特点" class="headerlink" title="切片特点"></a>切片特点</h2><p>一个slice 是一个轻量级的数据结构，提供了访问数组子序列元素的功能</p><p>底层引用了一个数组对象，指针指向第一个slice元素对象的底层数组元素的地址 </p><p><code>注意</code>：底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice ,</p><p><strong>两个slice不能用==比较</strong></p><h2 id="切片和数组的区别"><a href="#切片和数组的区别" class="headerlink" title="切片和数组的区别"></a>切片和数组的区别</h2><p>slice切片底层是数组，slice是对数组的封装，它描述了一个数组的片段，俩者都可以用下标来访问元素</p><p>数组是固定长度的，长度定义好后，不能更改 </p><p>切片非常灵活，它可以动态扩容，切片的类型和长度无关</p><h2 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h2><ul><li><p>直接声明： var slice []int </p></li><li><p>字面量： slice1 := []int{1,2,3}</p></li><li><p>make:     slice1 :=make([]int,3,5)</p></li><li><p>new:       slice1 := *new([]int)</p></li><li><p>切片或者数组截取： slice1 := array1[1:4] or slice1 := slice2[1:3]</p></li></ul><h3 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h3><p>第一种直接声明创建的slice 是nil slice ，它的长度和容量都为0，和nil 比较的结果为true</p><pre><code class="hljs go"><span class="hljs-keyword">package</span>  main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s1 []<span class="hljs-keyword">int</span>fmt.Println(s1 == <span class="hljs-literal">nil</span>)&#125;<span class="hljs-comment">//result</span><span class="hljs-literal">true</span></code></pre><p><strong>空切片</strong></p><pre><code class="hljs go">silce := <span class="hljs-built_in">make</span>( []<span class="hljs-keyword">int</span> , <span class="hljs-number">0</span> )slice := []<span class="hljs-keyword">int</span>&#123; &#125;</code></pre><p><code>注意</code>：空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素</p><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code class="hljs go">s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>:<span class="hljs-number">10</span>&#125;s3 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;s4 := []<span class="hljs-keyword">int</span>&#123;&#125;  <span class="hljs-comment">//创建空切片</span>s5 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-number">99</span>: <span class="hljs-number">100</span>&#125;   <span class="hljs-comment">//初始化第100个元素</span>fmt.Println(s2,<span class="hljs-built_in">len</span>(s2),<span class="hljs-built_in">cap</span>(s2))<span class="hljs-comment">//</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>] <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-comment">//s2</span><span class="hljs-comment">//唯一值得注意的是上面的代码例子中使用了索引号,直接赋值 ,这样其他未注明的元素则默认 0 值</span></code></pre><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p><code>make</code>函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等</p><p>如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 <code>make</code> 关键字</p><p>创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 长度为5，容量为10</span>slice[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 索引为2的元素赋值为2</span>fmt.Println(slice)&#125;</code></pre><p>数组切片和切片的切片</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">//定义一个数组</span><span class="hljs-keyword">var</span> s6  = array[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">//[2,3,4] 左闭右开</span><span class="hljs-keyword">var</span> s7  = array[<span class="hljs-number">4</span>:] <span class="hljs-comment">//[5,6,0,0,0,0] </span><span class="hljs-keyword">var</span> s8 = array[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] <span class="hljs-comment">//data[low, high, max] low表示索引开始处闭区间，high表示len开区间，max表示容量开区间 结果分析 [3,4] -&gt; len=2,cap=4 </span>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">//定义一个切片</span>s10 := slice[:<span class="hljs-number">4</span>]  <span class="hljs-comment">//beginIndex如果为空则表示从0开始</span>s11 := slice[<span class="hljs-number">4</span>:]  <span class="hljs-comment">//endIndex如果为空则表示到数组最后一个元素</span><span class="hljs-keyword">var</span> <span class="hljs-number">12</span> = slice[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] <span class="hljs-comment">//data[low, high, max] low表示索引开始处闭区间，high表示len开区间，max表示容量开区间 </span></code></pre><h2 id="append追加元素"><a href="#append追加元素" class="headerlink" title="append追加元素"></a>append追加元素</h2><p>append会返回新的slice，append返回值必须使用否则编译器会报错</p><pre><code class="hljs go">slice := <span class="hljs-built_in">append</span>(slice, elem1, elem2)    <span class="hljs-comment">//可以传入多个元素</span>slice := <span class="hljs-built_in">append</span>(slice, slice_other...)  <span class="hljs-comment">//可以传入一个切片 切片后面要加三个点 ...</span></code></pre><h2 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice1 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>&#125;out := slice1[:]out1 := slice1fmt.Printf(<span class="hljs-string">&quot;out=%v,p=%p\n&quot;</span>,out,&amp;out)fmt.Printf(<span class="hljs-string">&quot;out1=%v,p=%p&quot;</span>,out1,&amp;out1)&#125;<span class="hljs-comment">//output</span>out=[a n],p=<span class="hljs-number">0xc00000c0a0</span>out1=[a n],p=<span class="hljs-number">0xc00000c0c0</span></code></pre><h2 id="copy切片"><a href="#copy切片" class="headerlink" title="copy切片"></a>copy切片</h2><pre><code class="hljs go">由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;array := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">6</span>)n := <span class="hljs-built_in">copy</span>(slice, array)fmt.Println(n,slice)&#125;</code></pre><h2 id="for-range"><a href="#for-range" class="headerlink" title="for- range"></a>for- range</h2><p>for循环会对slice元素值一次拷贝到item。更改item中的值不会改变原slice的元素值</p><pre><code class="hljs go">slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> slice &#123;    item++&#125;fmt.Println(slice)<span class="hljs-comment">//output: [1,2,3]</span></code></pre><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>函数传slice是引用传参，修改被调函数的值，调用函数的slice也会改变。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;    test(slice)    fmt.Println(slice)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span></span> &#123;    a[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>&#125;<span class="hljs-comment">//output [1,100,3]</span></code></pre><h2 id="切片坑和困惑"><a href="#切片坑和困惑" class="headerlink" title="切片坑和困惑"></a>切片坑和困惑</h2><ul><li>切片做函数参数是传引用</li><li>append扩容问题，append 函数会创建一个新的底层数组,拷贝已存在的值和将要被附加的新值</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">s</span><span class="hljs-params">(s []<span class="hljs-keyword">string</span>)</span></span> &#123;    <span class="hljs-comment">//切片是引用传参</span>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;bds:234&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 :=[]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;123&quot;</span>&#125;s(s1)fmt.Println(s1)&#125; <span class="hljs-comment">//output</span>[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>][bds:<span class="hljs-number">234</span>]<span class="hljs-comment">/*</span><span class="hljs-comment">切片做函数参数的时候，是使用传引用（也就是传地址）</span><span class="hljs-comment">相当于是指针指向的内存地址这个引用，由于指向的是同一块内存地址，</span><span class="hljs-comment">所以在函数内部通过s[0] = &quot;bds:234&quot; 修改切片，最后修改成功</span><span class="hljs-comment">*/</span></code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;   y := s[:<span class="hljs-number">1</span>]   <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s  &#123;      y = <span class="hljs-built_in">append</span>(y,v)   &#125;   <span class="hljs-keyword">return</span> y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;   newS := myAppend(s)   fmt.Println(s)   fmt.Println(newS)&#125;<span class="hljs-comment">//output: </span>[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>][<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add2Slice</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, t <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span>&#123;s[<span class="hljs-number">0</span>]++s1 := <span class="hljs-built_in">append</span>(s, t)<span class="hljs-comment">//fmt.Println(&quot;s1&quot;,s1)</span>s[<span class="hljs-number">0</span>]++<span class="hljs-keyword">return</span> s1&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;c := Add2Slice(a, <span class="hljs-number">4</span>)fmt.Println(c)fmt.Println(<span class="hljs-string">&quot;a&quot;</span>, a)b := Add2Slice(a, <span class="hljs-number">5</span>)fmt.Println(b)d := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>&#125;nd := <span class="hljs-built_in">append</span>(d, <span class="hljs-number">3</span>)fmt.Printf(<span class="hljs-string">&quot;d=%v,P = %p\n&quot;</span>, d, &amp;d)fmt.Printf(<span class="hljs-string">&quot;nd=%v,P = %p &quot;</span>, nd, &amp;nd)&#125;<span class="hljs-comment">//output</span>[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]a [<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>][<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>]d=[<span class="hljs-number">1</span>],P = <span class="hljs-number">0xc0000a6080</span>nd=[<span class="hljs-number">1</span> <span class="hljs-number">3</span>],P = <span class="hljs-number">0xc0000a60a0</span> </code></pre><h3 id="群里热心大佬分享一个考题"><a href="#群里热心大佬分享一个考题" class="headerlink" title="群里热心大佬分享一个考题"></a>群里热心大佬分享一个考题</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/17631606914834_.pic_hd.jpg" alt="17631606914834_.pic_hd"></p><pre><code class="hljs go">我的思路：s2 = s1 此时 是相同的内存地址 相当于复制拷贝一份<span class="hljs-built_in">append</span> 操作了 s2 按照<span class="hljs-keyword">go</span>的扩容规则，内存地址改变，指针指向随之发生改变 进入函数s  = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">0</span>) 操作s1 时候， s1被扩容，地址发生改变，所以后面s[i]++操作的是扩容后新地址切片 所以s1 还是 <span class="hljs-number">12</span> slice 形参是传引用 相当于指针变量进行复制一份，但是指针指向的内存地址是相同的 ，所以后面操作s[<span class="hljs-number">0</span>]++ 相当于通过修改了内存地址里面的变量值，所以会s[i]++生效进入函数s  = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">0</span>) 操作s2的时候，根据扩容规则，容量满足，地址没有发生改变，所有后面操作的是原地址切片，值s[i]++ s2 变成<span class="hljs-number">234</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go map笔记</title>
    <link href="/2020/12/03/Go-map%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/Go-map%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a>map类型</h2><p>无序的基于key-value的数据结构，复合数据类型，map是引用类型，必须初始化才能使用</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p><code>map[KeyType]ValueType</code></p><p>直接声明</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;username&quot;</span> = <span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>  = <span class="hljs-string">&quot;20&quot;</span>,&#125;</code></pre><p>字面量</p><pre><code class="hljs go">userinfo := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;username&quot;</span> = <span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>  = <span class="hljs-string">&quot;20&quot;</span>,&#125;</code></pre><p>make关键字</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>,<span class="hljs-number">10</span>) #指定长度Userinfo[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span>   <span class="hljs-comment">//初始化赋值操作</span>Userinfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-string">&quot;20&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubadm1.18部署笔记</title>
    <link href="/2020/12/03/kubadm1-18%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/kubadm1-18%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>系统: CentOS Linux release 7.8.2003 (Core)</p><p>内核:  4.4.241-1.el7.elrepo.x86_64</p><p>k8s版本： 1.18  </p><p>calico：3.17</p><h2 id="升级内核脚本"><a href="#升级内核脚本" class="headerlink" title="升级内核脚本"></a>升级内核脚本</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 载入公钥</span>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<span class="hljs-meta">#</span><span class="bash"> 安装ELRepo</span>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="hljs-meta">#</span><span class="bash"> 载入elrepo-kernel元数据</span>yum --disablerepo=\* --enablerepo=elrepo-kernel repolist<span class="hljs-meta">#</span><span class="bash"> 查看可用的rpm包</span>yum --disablerepo=\* --enablerepo=elrepo-kernel list kernel*<span class="hljs-meta">#</span><span class="bash"> 安装长期支持版本的kernel</span>yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt.x86_64<span class="hljs-meta">#</span><span class="bash"> 删除旧版本工具包</span>yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64 -y<span class="hljs-meta">#</span><span class="bash"> 安装新版本工具包</span>yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64<span class="hljs-meta">#</span><span class="bash">查看默认启动顺序</span>awk -F\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print $2&#125;&#x27; /etc/grub2.cfg<span class="hljs-meta">#</span><span class="bash">默认启动的顺序是从0开始，新内核是从头插入（目前位置在0，而4.4.4的是在1），所以需要选择0。</span>grub2-set-default 0</code></pre><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">yum</span>yum install wget curl openssl openssh lrzsz<span class="hljs-meta">#</span><span class="bash"> 关掉防火墙</span>systemctl stop firewalld &amp;&amp; systemctl disable firewalld<span class="hljs-meta">#</span><span class="bash"> 关掉NetManager网络管理</span>systemctl stop NetworkManager &amp;&amp; systemctl disable NetworkManager <span class="hljs-meta">#</span><span class="bash"> selinux</span>setenforce 0sed -i &quot;s#=enforcing#=disabled#g&quot; /etc/selinux/config<span class="hljs-meta">#</span><span class="bash"> 关闭swap</span>swapoff -a &amp;&amp; sysctl -w vm.swappiness=0sed -ri &#x27;/^[^#]*swap/s@^@#@&#x27; /etc/fstab<span class="hljs-meta">#</span><span class="bash"> 修改yum源</span>sed -e &#x27;s!^#baseurl=!baseurl=!g&#x27;        -e  &#x27;s!^mirrorlist=!#mirrorlist=!g&#x27;        -e &#x27;s!mirror.centos.org!mirrors.ustc.edu.cn!g&#x27;        -i  /etc/yum.repos.d/CentOS-Base.repo<span class="hljs-meta">#</span><span class="bash"> epel源</span>yum install -y epel-release sed -e &#x27;s!^mirrorlist=!#mirrorlist=!g&#x27; -e &#x27;s!^#baseurl=!baseurl=!g&#x27; -e &#x27;s!^metalink!#metalink!g&#x27; -e &#x27;s!//download\.fedoraproject\.org/pub!//mirrors.ustc.edu.cn!g&#x27; -e &#x27;s!http://mirrors\.ustc!https://mirrors.ustc!g&#x27; -i /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel-testing.repo</code></pre><h2 id="yum-安装依赖和工具"><a href="#yum-安装依赖和工具" class="headerlink" title="yum 安装依赖和工具"></a>yum 安装依赖和工具</h2><pre><code class="hljs shell">yum install ipvsadm ipset sysstat conntrack libseccomp  curl git conntrack-tools  psmisc     nfs-utils jq socat  bash-completion ipset ipvsadm  conntrack  libseccomp net-tools crontabs  sysstat  unzip iftop  nload  strace  bind-utils  tcpdump  telnet  lsof htop -y</code></pre><h2 id="系统优化配置"><a href="#系统优化配置" class="headerlink" title="系统优化配置"></a>系统优化配置</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">---ipvs模式需要开机加载下列模块---</span>echo &quot;ipvs模式需要开机加载下列模块&quot;<span class="hljs-meta">cat&gt;</span><span class="bash">/etc/modules-load.d/ipvs.conf&lt;&lt;<span class="hljs-string">EOF</span></span>ip_vsip_vs_rrip_vs_wrrip_vs_shnf_conntrackbr_netfilterEOFsystemctl daemon-reloadsystemctl enable --now systemd-modules-load.service<span class="hljs-meta">#</span><span class="bash">---内核参数</span>cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 10net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1net.ipv4.neigh.default.gc_stale_time = 120net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2net.ipv4.ip_forward = 1net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-arptables = 1net.netfilter.nf_conntrack_max = 2310720fs.inotify.max_user_watches=89100fs.may_detach_mounts = 1fs.file-max = 52706963fs.nr_open = 52706963vm.swappiness = 0vm.overcommit_memory=1vm.panic_on_oom=0EOFsysctl --system<span class="hljs-meta">#</span><span class="bash">---优化设置 journal 日志相关---</span>sed -ri &#x27;s/^\$ModLoad imjournal/#&amp;/&#x27; /etc/rsyslog.confsed -ri &#x27;s/^\$IMJournalStateFile/#&amp;/&#x27; /etc/rsyslog.confsed -ri &#x27;s/^#(DefaultLimitCORE)=/\1=100000/&#x27; /etc/systemd/system.confsed -ri &#x27;s/^#(DefaultLimitNOFILE)=/\1=100000/&#x27; /etc/systemd/system.confsed -ri &#x27;s/^#(UseDNS )yes/\1no/&#x27; /etc/ssh/sshd_config<span class="hljs-meta">#</span><span class="bash">---优化文件最大打开数---</span><span class="hljs-meta">cat&gt;</span><span class="bash">/etc/security/limits.d/kubernetes.conf&lt;&lt;<span class="hljs-string">EOF</span></span>*       soft    nproc   131072*       hard    nproc   131072*       soft    nofile  131072*       hard    nofile  131072root    soft    nproc   131072root    hard    nproc   131072root    soft    nofile  131072root    hard    nofile  131072EOF</code></pre><h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> add yum 源</span>curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.reposed -i &#x27;s#download.docker.com#mirrors.ustc.edu.cn/docker-ce#g&#x27; /etc/yum.repos.d/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> yum</span> yum -y install docker-ce bash-completioncp /usr/share/bash-completion/completions/docker /etc/bash_completion.d/<span class="hljs-meta">#</span><span class="bash"> check 脚本</span>curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh &gt; check-config.shbash ./check-config.sh<span class="hljs-meta">#</span><span class="bash">---设置user_namespace.enable=1---</span>grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</code></pre><h3 id="docker-daemon-json"><a href="#docker-daemon-json" class="headerlink" title="docker daemon.json"></a>docker daemon.json</h3><pre><code class="hljs shell">&#123;    &quot;log-driver&quot;: &quot;json-file&quot;,    &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;,        &quot;max-file&quot;: &quot;3&quot;    &#125;,    &quot;live-restore&quot;: true,    &quot;max-concurrent-downloads&quot;: 10,    &quot;max-concurrent-uploads&quot;: 10,    &quot;storage-driver&quot;: &quot;overlay2&quot;,    &quot;storage-opts&quot;: [        &quot;overlay2.override_kernel_check=true&quot;    ],    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],    &quot;registry-mirrors&quot;: [        &quot;https://docker.mirrors.ustc.edu.cn/&quot;    ]&#125;</code></pre><h3 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h3><pre><code class="hljs shell">systemctl enable --now dockersystemctl start docker</code></pre><h2 id="k8s-安装"><a href="#k8s-安装" class="headerlink" title="k8s 安装"></a>k8s 安装</h2><pre><code class="hljs shell">cat &gt; /etc/yum.repos.d/k8s.repo &lt;&lt;EOF[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF<span class="hljs-meta">#</span><span class="bash"> yum 1.18版本</span>yum install  kubelet-1.18* kubadm-1.18* kubctl-1.18*  -y<span class="hljs-meta">#</span><span class="bash"> k8s 服务启动</span>systemctl daemon-reloadsystemctl restart dockersystemctl enable kubeletsystemctl start kubelet<span class="hljs-meta">#</span><span class="bash"> k8s env</span>export MASTER_IP=10.1.1.21 export APISERVER_NAME=k8s-api<span class="hljs-meta">#</span><span class="bash"> 如果想重置，重新初始化请用下面命令</span> kubeadm reset</code></pre><h2 id="k8s-master节点初始化"><a href="#k8s-master节点初始化" class="headerlink" title="k8s master节点初始化"></a>k8s master节点初始化</h2><pre><code class="hljs shell">kubeadm init       --apiserver-advertise-address 0.0.0.0         --apiserver-bind-port 6443         --cert-dir /etc/kubernetes/pki         --control-plane-endpoint k8s-api         --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers         --kubernetes-version 1.18.12         --pod-network-cidr 10.11.0.0/16         --service-cidr 10.20.0.0/16         --service-dns-domain cluster.local         --upload-certs<span class="hljs-meta">#</span><span class="bash"> </span>rm -f ~/.kube &amp;&amp; mkdir ~/.kubecp -i /etc/kubernets/admin.conf ~/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config</code></pre><h2 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h2><pre><code class="hljs css"><span class="hljs-selector-tag">wget</span> <span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">docs</span><span class="hljs-selector-class">.projectcalico</span><span class="hljs-selector-class">.org</span>/<span class="hljs-selector-tag">v3</span>.17/<span class="hljs-selector-tag">manifests</span>/<span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span><span class="hljs-selector-tag">sed</span> <span class="hljs-selector-tag">-i</span> &quot;<span class="hljs-selector-tag">s</span><span class="hljs-selector-id">#192</span>\.168\.0\.0/16<span class="hljs-selector-id">#10</span>\.10\.0\.0/16#&quot; <span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">apply</span> <span class="hljs-selector-tag">-f</span> <span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span></code></pre><h2 id="kuboard"><a href="#kuboard" class="headerlink" title="kuboard"></a>kuboard</h2><pre><code class="hljs shell">kubectl apply -f https://kuboard.cn/install-script/kuboard.yamlkubectl get pods -l name=kuboard -n kube-systemkubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d &gt; admin-token.txt</code></pre><h2 id="k8s-check"><a href="#k8s-check" class="headerlink" title="k8s check"></a>k8s check</h2><pre><code class="hljs crmsh">kubelet get <span class="hljs-keyword">node</span> <span class="hljs-title"></span><span class="hljs-title">kubelet</span> get pods -A</code></pre><pre><code class="hljs shell">[root@k8s-01-21 ~]# kubectl get nodesNAME        STATUS     ROLES    AGE    VERSIONk8s-01-21   Ready      master   2d1h   v1.18.12k8s-02-22   NotReady   &lt;none&gt;   2d     v1.18.12k8s-03-23   NotReady   &lt;none&gt;   2d     v1.18.12<span class="hljs-meta">#</span><span class="bash"> </span>[root@k8s-01-21 ~]# kubectl get pods -ANAMESPACE     NAME                                       READY   STATUS        RESTARTS   AGEkube-system   calico-kube-controllers-8586758878-9z69l   1/1     Running       2      2dkube-system   calico-node-6wtfx                          1/1     Running       2      2dkube-system   calico-node-9qh4k                          0/1     Running       2      2dkube-system   calico-node-j7qqb                          1/1     Running       0      2dkube-system   coredns-546565776c-bfxtm                   1/1     Running       2      2d1hkube-system   coredns-546565776c-qx9h8                   1/1     Running       2      2d1hkube-system   etcd-k8s-01-21                             1/1     Running       4      2d1hkube-system   kube-apiserver-k8s-01-21                   1/1     Running       6      2d1hkube-system   kube-controller-manager-k8s-01-21          1/1     Running       11     2dkube-system   kube-proxy-28m7c                           1/1     Running       0      2dkube-system   kube-proxy-d6f6h                           1/1     Running       4      2d1hkube-system   kube-proxy-zmvkg                           1/1     Running       0      2dkube-system   kube-scheduler-k8s-01-21                   1/1     Running       11     2d1hkube-system   kuboard-7986796cf8-h8vjt                   1/1     Terminating   0      2dkube-system   kuboard-7986796cf8-k57jj                   1/1     Running       1      7m19skube-system   metrics-server-7f96bbcc66-7pzgp            0/1     Pending       0      7m19skube-system   metrics-server-7f96bbcc66-p48m9            1/1     Terminating   0      2d</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go介绍笔记</title>
    <link href="/2020/12/02/Go%E4%BB%8B%E7%BB%8D%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/02/Go%E4%BB%8B%E7%BB%8D%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-概述"><a href="#Go-概述" class="headerlink" title="Go 概述"></a>Go 概述</h2><p>Go 语言是一门需要编译才能运行的编程语言，也就是说代码在运行之前需要通过编译器生成二进制机器码，包含二进制机器码的文件才能在目标机器上运行，如果我们想要了解 Go 语言的实现原理，理解它的编译过程就是一个没有办法绕过的事情。</p><p>这一节会先对 Go 语言编译的过程进行概述，从顶层介绍编译器执行的几个步骤，随后的几节会分别剖析各个步骤完成的工作和实现原理，同时也会对一些需要预先掌握的知识进行介绍，确保后面的章节能够被更好的理解。</p><h2 id="Go程序规范"><a href="#Go程序规范" class="headerlink" title="Go程序规范"></a>Go程序规范</h2><p>go语言以包作为管理单位</p><p>每个文件必须声明包</p><p>程序必须有一个main包(重要)</p><h2 id="Go工程规范"><a href="#Go工程规范" class="headerlink" title="Go工程规范"></a>Go工程规范</h2><p>go入口，go有且只有一个入口函数main</p><pre><code>一个文件里面只能有一个main函数</code></pre><p>干活 执行函数</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//入口函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-comment">//打印</span><span class="hljs-comment">//&quot;hello go&quot;打印到屏幕，PrintLn()会自动换行</span><span class="hljs-comment">//调用函数，大部分都需要导入包</span><span class="hljs-comment">/*</span><span class="hljs-comment">这也是注释，这是块注释</span><span class="hljs-comment">*/</span>fmt.PrintLn(<span class="hljs-string">&quot;hello go&quot;</span>) <span class="hljs-comment">//go语言语句结尾是没有分号的</span>fmt.PirintLn(<span class="hljs-string">&quot;hello bds&quot;</span>)&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">go</span> build xxx.<span class="hljs-keyword">go</span>  <span class="hljs-comment">//通过编译xxx.go文件 然后生成一个以xx为名字的程序 直接执行xxx程序 输出程序结果</span><span class="hljs-keyword">go</span> run   xxx.<span class="hljs-keyword">go</span>  <span class="hljs-comment">//通过run 不生成程序 执行运行 一次性输出程序结果</span></code></pre><pre><code class="hljs go">###示例➜  main <span class="hljs-keyword">go</span> build hello.<span class="hljs-keyword">go</span>➜  main ./hellohello.中国➜  main lshello     hello.<span class="hljs-keyword">go</span>  value1    value1.<span class="hljs-keyword">go</span>➜  main rm -fr hello➜  main lltotal <span class="hljs-number">3744</span>-rw-r--r--  <span class="hljs-number">1</span> budongshu  staff    <span class="hljs-number">74</span>B <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">04</span> hello.<span class="hljs-keyword">go</span>-rwxr-xr-x  <span class="hljs-number">1</span> budongshu  staff   <span class="hljs-number">1.8</span>M <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span> value1-rw-r--r--  <span class="hljs-number">1</span> budongshu  staff   <span class="hljs-number">124</span>B <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">46</span> value1.<span class="hljs-keyword">go</span>➜  main <span class="hljs-keyword">go</span> run hello.<span class="hljs-keyword">go</span>hello.中国➜  main lshello.<span class="hljs-keyword">go</span>  value1    value1.<span class="hljs-keyword">go</span></code></pre><h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><pre><code class="hljs go">export GOPROXY=https:<span class="hljs-comment">//goproxy.io </span>or$env:GOPROXY = <span class="hljs-string">&quot;https://goproxy.io&quot;</span></code></pre><h2 id="Go数据类型"><a href="#Go数据类型" class="headerlink" title="Go数据类型"></a>Go数据类型</h2><p>计算机用来计算，计算前需要存数，如何存一个数呢</p><p> 数据类型作用: 告诉编译器这个数(变量) 应该以多大的内存存储</p><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>go 语言中函数名 变量名 常量名 类型名 语句标号和包名等所有的命名，都遵循一个简单的</p><p>命名规则: 一个名字必须以一个字母或者下划线开头，后面可以跟任意数量的字母，数字</p><p>或者下划线。大写字母和小写字母是不同的，heapSort Heapsort 是俩个不同的变量名字</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <span class="hljs-comment">//导入包的时候必须要使用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//变量，程序运行期间，可以改变的量</span><span class="hljs-comment">//声明格式: var 变量名 类型; 变量声明了，必须要使用</span><span class="hljs-comment">//声明变量没有初始化的变量，默认值为0</span><span class="hljs-comment">//同一个函数的&#123;&#125;里，声明的变量名是唯一的，不允许同名</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a)<span class="hljs-comment">//可以同时声明多个变量</span><span class="hljs-comment">//var b,c int</span>a = <span class="hljs-number">10</span>     <span class="hljs-comment">//变量的赋值</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a)<span class="hljs-comment">//变量的初始化： 声明变量时候，同时赋值</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span> <span class="hljs-comment">//初始化: 声明变量时，同时赋值(一步到位)</span>b = <span class="hljs-number">20</span>         <span class="hljs-comment">//赋值: 先声明，后赋值</span>fmt.Println(<span class="hljs-string">&quot;b = &quot;</span>,b)<span class="hljs-comment">// 自动推导类型，必须初始化，因为它是通过初始化的值来确定类型</span>c := <span class="hljs-number">30</span><span class="hljs-comment">//%T 打印变量的所属类型</span>fmt.Printf(<span class="hljs-string">&quot;c type is %T\n&quot;</span>,c)&#125;</code></pre><h2 id="Go-基本单元"><a href="#Go-基本单元" class="headerlink" title="Go 基本单元"></a>Go 基本单元</h2><p>Go 语言本身只有 25 个关键字，涵盖了包管理、常量与变量、流程控制、函数调用、数据结构 和并发控制六个方面的语言特性。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>func return</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(argc <span class="hljs-keyword">int</span>, argv []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">float64</span></span> &#123;...<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre><h4 id="内建的打印函数"><a href="#内建的打印函数" class="headerlink" title="内建的打印函数"></a>内建的打印函数</h4><pre><code class="hljs autoit"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print</span><span class="hljs-params">(args ...T)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">println</span><span class="hljs-params">(args ...T)</span></span></code></pre><h4 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h4><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">er</span></span>主函数</code></pre><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><pre><code class="hljs javascript">条件控制<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">continue</span> <span class="hljs-keyword">switch</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">default</span> fallthrough</code></pre><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><pre><code class="hljs ada"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span></code></pre><h4 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h4><pre><code class="hljs ada"><span class="hljs-keyword">goto</span></code></pre><h2 id="Go-基本类型"><a href="#Go-基本类型" class="headerlink" title="Go 基本类型"></a>Go 基本类型</h2><h3 id="原始的数值类型包括"><a href="#原始的数值类型包括" class="headerlink" title="原始的数值类型包括"></a>原始的数值类型包括</h3><pre><code class="hljs go"><span class="hljs-keyword">bool</span>, <span class="hljs-keyword">uint</span>, <span class="hljs-keyword">uint8</span>, <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span>, <span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span></code></pre><h3 id="常量-const-与变量-var"><a href="#常量-const-与变量-var" class="headerlink" title="常量 const 与变量 var"></a>常量 const 与变量 var</h3><pre><code class="hljs go"><span class="hljs-keyword">const</span> (    name       = <span class="hljs-string">&quot;val&quot;</span>    PI <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.1415926</span>)<span class="hljs-keyword">var</span> (    age = <span class="hljs-number">18</span>)</code></pre><p>变量除了使用 <code>var</code> 来进行声明外，还可以在函数内部通过 <code>:=</code> 进行声明</p><h2 id="数据容器与高级类型"><a href="#数据容器与高级类型" class="headerlink" title="数据容器与高级类型"></a>数据容器与高级类型</h2><ul><li>字符串</li><li>切片和数组</li><li>接口</li><li>指针与零值</li></ul><h2 id="Go-并发与同步"><a href="#Go-并发与同步" class="headerlink" title="Go 并发与同步"></a>Go 并发与同步</h2><ul><li>Channel</li><li>Select</li><li>Go 块</li></ul><h2 id="Go-错误处理"><a href="#Go-错误处理" class="headerlink" title="Go 错误处理"></a>Go 错误处理</h2><pre><code class="hljs routeros">type <span class="hljs-builtin-name">error</span><span class="hljs-built_in"> interface </span>&#123;<span class="hljs-builtin-name">Error</span>() string&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo+Gitee写博客和个人博客图床</title>
    <link href="/2020/11/26/Typora-PicGo-Gitee%E5%86%99%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/11/26/Typora-PicGo-Gitee%E5%86%99%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>： 在我们编写个人博客的时候，针对图片的保存一直是一个问题，因为图片是保存在本地，一旦博客进行分享，那么图片就会丢失，所以这里给大家介绍一个靠谱，稳定，又方便的方式实现个人图床，就是Picgo + Gitee 还有结合Typora进行写markdown博客，Typora支持PicGo上传图片，学会使用这几个工具，写博客会方便，简单很多。</p><h3 id="软件需知"><a href="#软件需知" class="headerlink" title="软件需知"></a>软件需知</h3><blockquote><p>首先电脑必须安装nodejs环境(node ,npm)</p></blockquote><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><ul><li><code>Typora</code>: Markdown工具，写Markdown文件的神器，简洁、方便、免费</li><li><code>PicGo</code> 开源的图片管理工具，可以自己上传图片到各种图床</li><li><code>gitee-uploader</code>: PicGo依赖这个插件进行上传到<code>gitee</code> 仓库</li><li><code>gitee码云</code>: 借助<code>gitee</code> 码云建立自己的仓库，构建<strong>免费</strong>图床，国内速度快</li></ul><h4 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h4><ul><li><p><code>Typora</code>:  Typora Beta 0.9.9.35.2</p></li><li><p><code>Picgo</code>:  v2.3.0-beta.3 + </p></li><li><p><code>gitee-uploader</code>:  1.1.2 </p></li><li><p><code>gitee</code>: 申请 gitee 码云平台账号 </p></li></ul><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p><code>nodejs</code> 下载地址: <a href="https://npm.taobao.org/mirrors/node/v12.20.0/">https://npm.taobao.org/mirrors/node/v12.20.0/</a></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126000352762.png" alt="image-20201126000352762"></p><h3 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h3><p>详情请看github地址： <a href="https://github.com/Molunerfinn/">https://github.com/Molunerfinn/</a></p><h4 id="Picgo下载"><a href="#Picgo下载" class="headerlink" title="Picgo下载"></a>Picgo下载</h4><ul><li>稳定版本</li></ul><p><a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.2.2">https://github.com/Molunerfinn/PicGo/releases/tag/v2.2.2</a>   </p><ul><li>测试体验版本，可能存在bug </li></ul><p><a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.3/PicGo-2.3.0-beta.3.dmg">https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.3/PicGo-2.3.0-beta.3.dmg</a></p><ul><li>百度云地址（上面俩个版本我都放到了百度云，提供下载）</li></ul><p>链接: <a href="https://pan.baidu.com/s/1KmgzO6PzUFeehAec6R8LeQ">https://pan.baidu.com/s/1KmgzO6PzUFeehAec6R8LeQ</a> 提取码: gwhg </p><h4 id="Picgo-安装"><a href="#Picgo-安装" class="headerlink" title="Picgo 安装"></a>Picgo 安装</h4><blockquote><p>我这里安装版本是最新Picgo-2.3.0</p></blockquote><p>如果遇到下面报错，请根据提示，进行安装nodejs  </p><p><code>nodejs</code> 下载地址：<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201125235825678.png" alt="image-20201125235825678"></p><h4 id="Picgo-安装成功后，然后右键打开详细窗口"><a href="#Picgo-安装成功后，然后右键打开详细窗口" class="headerlink" title="Picgo 安装成功后，然后右键打开详细窗口"></a>Picgo 安装成功后，然后右键打开详细窗口</h4><blockquote><p> 选择gitee</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003056438.png"></p><p><strong>然后右键点击软件(mac),打开详细窗口,然后选择插件设置 安装gitee-uploader</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126011800964.png" alt="image-20201126011800964"></p><p><strong>这里需要填写上传到gitee仓库的一些认证条件，下面会进行讲解</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003043875.png" alt="image-20201126003043875"></p><h3 id="gitee-注册申请"><a href="#gitee-注册申请" class="headerlink" title="gitee 注册申请"></a>gitee 注册申请</h3><p><code>gitee</code> 地址： <a href="https://gitee.com/login">https://gitee.com/login</a> </p><h4 id="gitee注册登录"><a href="#gitee注册登录" class="headerlink" title="gitee注册登录"></a>gitee注册登录</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126001439621.png" alt="image-20201126001439621"></p><h4 id="gitee-建立自己的图片仓库"><a href="#gitee-建立自己的图片仓库" class="headerlink" title="gitee 建立自己的图片仓库"></a>gitee 建立自己的图片仓库</h4><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126001652453.png" alt="image-20201126001652453"  /><h4 id="gitee-设置仓库信息"><a href="#gitee-设置仓库信息" class="headerlink" title="gitee 设置仓库信息"></a>gitee 设置仓库信息</h4><blockquote><p> 最后选择进行创建</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002327936.png" alt="image-20201126002327936"></p><h4 id="gitee的私人令牌token-生成"><a href="#gitee的私人令牌token-生成" class="headerlink" title="gitee的私人令牌token 生成"></a>gitee的私人令牌token 生成</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003911644.png" alt="image-20201126003911644"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002749069.png" alt="image-20201126002749069"></p><p>这是我的token令牌，进行复制后面会PicGo会用到</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002859007.png" alt="image-20201126002859007"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126011329717.png" alt="image-20201126011329717"></p><ul><li><p><code>repo</code>:  比如我的仓库地址: <a href="https://gitee.com/budongshu/blogimage">https://gitee.com/budongshu/blogimage</a>     去掉<a href="https://gitee.com/">https://gitee.com/</a>   </p></li><li><p><code>token</code>: 就是上面获取的私人令牌token  </p></li><li><p><code>path</code>：建立一个文件夹来保存图片，这里设置好后，仓库里面会自动创建这个目录</p></li></ul><p><strong>现在就可以上传图片了</strong></p><h3 id="Typora-设置支持PicGo"><a href="#Typora-设置支持PicGo" class="headerlink" title="Typora 设置支持PicGo"></a>Typora 设置支持PicGo</h3><blockquote><p>设置Typora工具，当插入图片的时候，触发上传图片操作，然后上传服务选择PicGo.app来支持</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126101750352.png" alt="image-20201126101750352"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126101135224.png" alt="image-20201126101135224"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 小白搭建自己个人博客</title>
    <link href="/2020/11/26/hexo%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/11/26/hexo%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>通过hexo 可以搭建属于的免费博客，不需要敲代码，不需要花钱，并且还很好看，但是需要稍稍花上一点时间，当然只要按照文档，一步一步操作，就可以收获属于自己的博客啦</p><h3 id="需要的工具介绍"><a href="#需要的工具介绍" class="headerlink" title="需要的工具介绍"></a>需要的工具介绍</h3><p><code>nodejs</code>: 包含俩个命令 <code>node</code> <code>npm</code></p><p><code>hexo</code>: 快速、简洁且高效的博客框架,支持markdown 插件和扩展性很好</p><p><code>git</code>：需要安装git 通过git 命令来操作github </p><p><code>github</code>账号：申请注册一个github账号，github提供了一个github pages功能可以支持站点</p><p>软件版本： </p><p><code>nodejs</code>： v12.20.0 建立使用这个版本，最新版本使用hexo的时候，可能会有bug</p><h3 id="开始搭建并部署博客"><a href="#开始搭建并部署博客" class="headerlink" title="开始搭建并部署博客"></a>开始搭建并部署博客</h3><h4 id="nodejs-操作"><a href="#nodejs-操作" class="headerlink" title="nodejs 操作"></a>nodejs 操作</h4><h5 id="windows-用户-安装nodejs"><a href="#windows-用户-安装nodejs" class="headerlink" title="windows 用户 安装nodejs"></a>windows 用户 安装nodejs</h5><blockquote><p> windows用户这里需要安装git来操作</p></blockquote><p>Git的官方下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> </p><p>下载完成之后点击安装，然后通过打开Git Bash 这个软件来敲下面的命令</p><p><strong>临时更换npm 源 (为了后面快速下载安装hexo，更换为国内的源)</strong></p><pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span>npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">get</span> registry看看终端显示信息，如果看到这行信息，说明配置成功: https:<span class="hljs-comment">//registry.npm.taobao.org/</span></code></pre><h5 id="mac-用户-打开终端-安装nodejs"><a href="#mac-用户-打开终端-安装nodejs" class="headerlink" title="mac 用户 打开终端 安装nodejs"></a>mac 用户 打开终端 安装nodejs</h5><p><strong>下载安装 然后通过命令检测下安装版本</strong></p><p>下载地址： <a href="https://npm.taobao.org/mirrors/node/v12.20.0/">https://npm.taobao.org/mirrors/node/v12.20.0/</a></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node -v</span>v12.20.0(base)<span class="hljs-meta">$</span><span class="bash"> npm -v</span>6.14.8</code></pre><p><strong>临时更换npm 源 (为了后面快速下载安装hexo，更换为国内的源)</strong></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org</span><span class="hljs-meta">$</span><span class="bash"> npm config get registry</span>https://registry.npm.taobao.org/</code></pre><h4 id="hexo-操作"><a href="#hexo-操作" class="headerlink" title="hexo 操作"></a>hexo 操作</h4><h5 id="windows用户-安装初始化hexo"><a href="#windows用户-安装初始化hexo" class="headerlink" title="windows用户 安装初始化hexo"></a>windows用户 安装初始化hexo</h5><blockquote><p> 通过npm来安装hexo，下面前俩个命令安装需要一点时间，blog目录就是博客目录，根据自己情况选择目录</p></blockquote><pre><code class="hljs shell">npm install hexo-cli -g  hexo init blog            cd blognpm install       hexo server</code></pre><p>然后会看到这样的信息</p><pre><code class="hljs pgsql"><span class="hljs-keyword">INFO</span>  Validating config<span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.</code></pre><p>本地访问<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客网站了</p><h5 id="mac-用户-打开终端-安装初始化hexo"><a href="#mac-用户-打开终端-安装初始化hexo" class="headerlink" title="mac 用户 打开终端 安装初始化hexo"></a>mac 用户 打开终端 安装初始化hexo</h5><blockquote><p> 通过npm来安装hexo(mac用户加上sudo),下面前俩个命令安装需要一点时间，blog目录就是博客目录,根据自己情况选择目录</p></blockquote><pre><code class="hljs shell">sudo npm install hexo-cli -g  #安装需要一点时间hexo init blog   #hexo 初始化安装 需要一点时间 这个blog以后就是自己的博客目录啦 文章都会放在这里面cd blog          #进入博客目录npm install      #npm 安装一些插件hexo server      #启动hexo服务INFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126122858805.png" alt="image-20201126122858805"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126122742048.png" alt="image-20201126122742048"></p><p>本地访问<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客网站了</p><p><strong>注意： 后面不在区分windows和 mac 用户，只要是敲命令的操作，命令都是通用的，命令不要敲错就OK。</strong></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了</p><h4 id="github-操作"><a href="#github-操作" class="headerlink" title="github 操作"></a>github 操作</h4><h5 id="github-申请账号注册"><a href="#github-申请账号注册" class="headerlink" title="github 申请账号注册"></a>github 申请账号注册</h5><p>github 注册地址： <a href="https://github.com/join?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/&amp;source=header-home">https://github.com/join?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=%2F&amp;source=header-home</a></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126113312838.png" alt="image-20201126113312838"></p><h5 id="github-登录-新建仓库"><a href="#github-登录-新建仓库" class="headerlink" title="github 登录 新建仓库"></a><strong>github 登录 新建仓库</strong></h5><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126113604379.png" alt="image-20201126113604379"></p><p><strong>github 只能是托管同名代码下 一个静态站点</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126114123119.png" alt="image-20201126114123119"></p><p><strong>这里要注意： 我们要更改下默认仓库分支名字 由 main 改为master</strong> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126133223895.png" alt="image-20201126133223895"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126133359800.png" alt="image-20201126133359800"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如: 你能看到我 说明部署成功~</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126114759280.png" alt="image-20201126114759280"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115032215.png" alt="image-20201126115032215"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115049350.png" alt="image-20201126115049350"></p><p>这个时候打开 <a href="http://你的用户名.github.io/">http://你的用户名.github.io</a> 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 <a href="http://你的用户名.github.io/">http://你的用户名.github.io</a> 看到你自己的博客啦！ 比如我的就是 <a href="http://budongshu.github.io/">http://budongshu.github.io</a> 了。</p><p>![image-20201126115126800](<a href="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115126800.png">https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115126800.png</a></p><h4 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h4><p>首先windows用户打开Git-Bash工具 mac 用户打开终端 操作命令都是一样的</p><p>执行以下命令全局配置一下本地账户</p><pre><code class="hljs shell">git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot;</code></pre><p>生成一对密钥 SSH key</p><pre><code class="hljs shell">ssh-keygen -t rsa</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126120840429.png" alt="image-20201126120840429"></p><p>首次使用还需要确认并添加主机到本机ssh 信任列表 下面可以看到success 返回成功</p><pre><code class="hljs shell">ssh -T git@github.com</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121227120.png" alt="image-20201126121227120"></p><p>查看刚刚生成公钥 最后要把这个公钥复制粘贴到github上去</p><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121614857.png" alt="image-20201126121614857"></p><p>然后登录github 在github 上添加刚刚生成的ssh key 把公钥复制粘贴上去</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121337851.png" alt="image-20201126121337851"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121412755.png" alt="image-20201126121412755"></p><h4 id="部署到github-仓库"><a href="#部署到github-仓库" class="headerlink" title="部署到github 仓库"></a>部署到github 仓库</h4><p>这个时候我们把本地hexo 和github pages部署已经完成了，接下来我们要把本地的hexo静态站点部署到github pages中，然后通过github pages 我们就可以在互联网上浏览到博客了。</p><h4 id="部署之前需要更改hexo-配置-和安装部署插件"><a href="#部署之前需要更改hexo-配置-和安装部署插件" class="headerlink" title="部署之前需要更改hexo 配置 和安装部署插件"></a>部署之前需要更改hexo 配置 和安装部署插件</h4><p>第一: 进入blog 目录，打开仓库_config.yml 配置文件，拉到文件末尾，填上如下配置（也可同时部署到多个仓库，比如也可以支持gitee ）：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意: 这个文件是有格式的，不同层级按照缩进俩个空格，比如： 下面github 根据上面repo 就是俩个空格</span><span class="hljs-meta">#</span><span class="bash"> Deployment</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span>deploy:  type: git  branch: main  repo:     github: https://github.com/budongshu/budongshu.github.io.git #仓库名字改成自己的</code></pre><p>第二: 要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><pre><code class="hljs shell">npm install hexo-deployer-git --save</code></pre><p>第三: 最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><pre><code class="hljs shell">hexo g -d</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126123828399.png" alt="image-20201126123828399"></p><p>稍等一会，在浏览器访问网址： <a href="https://你的用户名.github.io/">https://你的用户名.github.io</a> 就会看到你的博客 </p><h4 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h4><table><thead><tr><th align="left">命令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">hexo clean</td><td align="left">清除所有生成的页面文件</td></tr><tr><td align="left">hexo g</td><td align="left">生成页面</td></tr><tr><td align="left">hexo deploy</td><td align="left">推送部署到远程服务器</td></tr><tr><td align="left">hexo n xxx</td><td align="left">新建一篇名为xxx的文章</td></tr></tbody></table><h4 id="写一遍博客-发布到网上"><a href="#写一遍博客-发布到网上" class="headerlink" title="写一遍博客 发布到网上"></a>写一遍博客 发布到网上</h4><pre><code class="hljs shell">hexo new &#x27;第一遍文章&#x27;</code></pre><p>执行完成后可以在 /source/_posts 下看到一个“<code>第一遍文章.md</code>” 的文章文件 .md 就是 Markdown 格式的文件 </p><p>具体用法可以在网上找一下，语法还是比较简单的。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135451904.png" alt="image-20201126135451904"></p><p>然后按照markdown语法 编辑<code>第一遍文章.md</code> ，推荐markdown 工具: <code>Typora</code> 进行编辑</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135355292.png" alt="image-20201126135355292"></p><p>编辑完成保存，然后进行发布，注意： 一定要在blog目录下执行命令</p><pre><code class="hljs shell">cd ~/blog hexo clean &amp;&amp; hexo g -d</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135245477.png" alt="image-20201126135245477"></p><h3 id="更换主题fluid"><a href="#更换主题fluid" class="headerlink" title="更换主题fluid"></a>更换主题fluid</h3><pre><code class="hljs shell">cd ~/bloggit clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</code></pre><p>在_config.yml 配置文件中，替换theme 参数，我们 把原来的注释掉加#，然后新增一行theme:  fluid</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Extensions</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Plugins: https://hexo.io/plugins/</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Themes: https://hexo.io/themes/</span></span><span class="hljs-meta">#</span><span class="bash">theme: landscape</span>theme: fluid</code></pre><h4 id="配置主题fluid"><a href="#配置主题fluid" class="headerlink" title="配置主题fluid"></a>配置主题fluid</h4><p>新建about 关于页面</p><pre><code class="hljs shell">hexo new page about</code></pre><h4 id="随便编写介绍自己的about-页面内容"><a href="#随便编写介绍自己的about-页面内容" class="headerlink" title="随便编写介绍自己的about 页面内容"></a>随便编写介绍自己的about 页面内容</h4><pre><code class="hljs shell">---title: aboutdate: 2020-11-26 16:47:37layout: about---`email`: bdstravel@126.com</code></pre>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
