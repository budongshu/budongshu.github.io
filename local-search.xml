<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go 反射</title>
    <link href="/2020/12/20/Go-%E5%8F%8D%E5%B0%84/"/>
    <url>/2020/12/20/Go-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>有时候我们需要写一个函数，这个函数有能力统一处理各种值类型。而这些类型可能无法共享同一个接口，也可能布局位置，也有课呢呢个这个类型在我们设计函数时候还不存咋，这个时候，我们就可以使用反射</p><p>1 空接口可以存储任意类型的变量，那我们如何知道这个接口保存的数据的类型是什么？值是什么？</p><ul><li>可以使用类型断言</li><li>可以使用反射实现，也就是在程序运行时动态的获取一个变量的类型信息和值信息</li></ul><p>2 把结构体序列化成json 字符串，自定义结构体Tab标签的时候 就用到了反射</p><h2 id="反射的介绍"><a href="#反射的介绍" class="headerlink" title="反射的介绍"></a>反射的介绍</h2><p>反射是指在程序运行期间对程序本身进行访问和修改的能力，正常情况程序在编译时候，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时候，程序无法获取自身的信息，支持反射的语言可以在程序编译期间将变量的发射信息。如字段信息，类型信息，结构体信息，等 整合到可执行文件中，并给程序员提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改他们</p><h2 id="反射实现的功能"><a href="#反射实现的功能" class="headerlink" title="反射实现的功能"></a>反射实现的功能</h2><ul><li>反射可以在程序运行期间动态的获取变量的各种信息， 比如变量的类型</li><li>如果是结构体，通过反射还可以获取结构体本身的信息， 比如结构体的字段结构体的方法</li><li>通过反射， 可以修改变量的值，可以调用关联的方法</li></ul><h3 id="Go-语言中的变量是分为俩部分的"><a href="#Go-语言中的变量是分为俩部分的" class="headerlink" title="Go 语言中的变量是分为俩部分的"></a>Go 语言中的变量是分为俩部分的</h3><ul><li>类型信息：预先定义好的元信息</li><li>值信息： 程序运行过程中可动态变化的</li></ul><p>在Go语言中的反射机制中，任何接口值都是由一个具体类型和具体类型的值俩部分组成的</p><p>在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type 和 reflect.Value</p><p>并且reflect包提供了reflect.TypeOf 和 reflect.ValueOf 俩个重要函数来获取任意对象的Value和Type</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>Age  <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectFunc</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v := reflect.TypeOf(x)fmt.Println(v)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-number">23.4</span>c := <span class="hljs-literal">true</span>d := <span class="hljs-string">&quot;hello golang&quot;</span>reflectFunc(a)reflectFunc(b)reflectFunc(c)reflectFunc(d)<span class="hljs-keyword">var</span> e myInt = <span class="hljs-number">1</span>reflectFunc(e)<span class="hljs-keyword">var</span> s1 = Stu&#123;Name: <span class="hljs-string">&quot;bds&quot;</span>,Age:  <span class="hljs-number">19</span>,&#125;reflectFunc(s1)&#125;<span class="hljs-comment">/*package main</span><span class="hljs-comment"></span><span class="hljs-comment">import (</span><span class="hljs-comment">&quot;fmt&quot;</span><span class="hljs-comment">&quot;reflect&quot;</span><span class="hljs-comment">)</span><span class="hljs-comment"></span><span class="hljs-comment">type myInt int</span><span class="hljs-comment">type Stu struct &#123;</span><span class="hljs-comment">Name string</span><span class="hljs-comment">Age  int</span><span class="hljs-comment">&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">func reflectFunc(x interface&#123;&#125;) &#123;</span><span class="hljs-comment">v := reflect.TypeOf(x)</span><span class="hljs-comment">fmt.Println(v)</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">func main() &#123;</span><span class="hljs-comment">a := 10</span><span class="hljs-comment">b := 23.4</span><span class="hljs-comment">c := true</span><span class="hljs-comment">d := &quot;hello golang&quot;</span><span class="hljs-comment">reflectFunc(a)</span><span class="hljs-comment">reflectFunc(b)</span><span class="hljs-comment">reflectFunc(c)</span><span class="hljs-comment">reflectFunc(d)</span><span class="hljs-comment">var e myInt = 1</span><span class="hljs-comment"></span><span class="hljs-comment">reflectFunc(e)</span><span class="hljs-comment">var s1 = Stu&#123;</span><span class="hljs-comment">Name: &quot;bds&quot;,</span><span class="hljs-comment">Age:  19,</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">reflectFunc(s1)</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre><h3 id="type-Name-和type-Kind"><a href="#type-Name-和type-Kind" class="headerlink" title="type Name 和type Kind"></a>type Name 和type Kind</h3><p>在反射中关于类型划分为俩种： 类型（Type） 和 种类（Kind）。因为在Go语言中我们可以使用Type 关键字构造很多自定义类型，而种类（Kind) 就是底层数据类型，但是在反射中 当需要却分指针，结构体等大品种的类型时，就会用到种类(Kind) </p><p>举个列子我们定义了俩个指针类型和俩个结构体类型 通过反射查看他们的类型和种类。 </p><p><strong>Go语言中的反射 像数组 切牌呢 Map 指针等类型的变量 他们.Name()都是返回空</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>Age  <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectFunc</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v := reflect.TypeOf(x)fmt.Printf(<span class="hljs-string">&quot;类型：%v类型名称：%v 底层类型种类：%v\n&quot;</span>, v, v.Name(), v.Kind())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-number">23.4</span>c := <span class="hljs-literal">true</span>d := <span class="hljs-string">&quot;hello golang&quot;</span>reflectFunc(a)reflectFunc(b)reflectFunc(c)reflectFunc(d)<span class="hljs-keyword">var</span> e myInt = <span class="hljs-number">1</span>reflectFunc(e)<span class="hljs-keyword">var</span> s1 = Stu&#123;Name: <span class="hljs-string">&quot;bds&quot;</span>,Age:  <span class="hljs-number">19</span>,&#125;reflectFunc(s1)<span class="hljs-keyword">var</span> p1 = <span class="hljs-number">1</span>reflectFunc(&amp;p1)  <span class="hljs-keyword">var</span> i = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">var</span> j = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;reflectFunc(i)reflectFunc(j)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">类型：int类型名称：int 底层类型种类：int</span><span class="hljs-comment">类型：float64类型名称：float64 底层类型种类：float64</span><span class="hljs-comment">类型：bool类型名称：bool 底层类型种类：bool</span><span class="hljs-comment">类型：string类型名称：string 底层类型种类：string</span><span class="hljs-comment">类型：main.myInt类型名称：myInt 底层类型种类：int</span><span class="hljs-comment">类型：main.Stu类型名称：Stu 底层类型种类：struct</span><span class="hljs-comment">类型：*int类型名称： 底层类型种类：ptr</span><span class="hljs-comment">类型：[3]int类型名称： 底层类型种类：array</span><span class="hljs-comment">类型：[]int类型名称： 底层类型种类：slice</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre><h3 id="通过ValueOf判断类型"><a href="#通过ValueOf判断类型" class="headerlink" title="通过ValueOf判断类型"></a>通过ValueOf判断类型</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectFunc</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-comment">//我们直接进行想加 会报错</span><span class="hljs-comment">//c := x + 10    // invalid operation: x + 10 (mismatched types interface &#123;&#125; and int</span><span class="hljs-comment">//通过类型断言的方式 求值</span>b, _ := x.(<span class="hljs-keyword">int</span>)c := b + <span class="hljs-number">10</span>fmt.Println(c)<span class="hljs-comment">//通过反射的方式   求值</span>v := reflect.ValueOf(x)c1 := v.Int() + <span class="hljs-number">11</span> <span class="hljs-comment">//通过v.Int()获取原始值， 还支持其他类型 类型名称首字母大写</span>fmt.Println(c1)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>reflectFunc(a)&#125;</code></pre><h3 id="通过ValueOf-和Kind-判断类型-获取变量的值"><a href="#通过ValueOf-和Kind-判断类型-获取变量的值" class="headerlink" title="通过ValueOf 和Kind 判断类型 获取变量的值"></a>通过ValueOf 和Kind 判断类型 获取变量的值</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectFunc</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v := reflect.ValueOf(x)kind := v.Kind()<span class="hljs-keyword">switch</span> kind &#123;<span class="hljs-keyword">case</span> reflect.String:fmt.Printf(<span class="hljs-string">&quot;string类型原始值：%v\n&quot;</span>, v.String())<span class="hljs-keyword">case</span> reflect.Int:fmt.Printf(<span class="hljs-string">&quot;int类型的原始值：%v\n&quot;</span>, v.Int()+<span class="hljs-number">10</span>)<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">&quot;没有匹配&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>reflectFunc(a)b := <span class="hljs-string">&quot;你好 golang&quot;</span>reflectFunc(b)&#125;</code></pre><h3 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setFunc</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v := reflect.ValueOf(x)  <span class="hljs-comment">//如果是指针类型的变量 获取底层数据类型需要加Elem方法</span>kind := v.Elem().Kind()<span class="hljs-keyword">if</span> kind == reflect.Int &#123;    <span class="hljs-comment">//设置值的时候 也需要加上Elem </span>v.Elem().SetInt(<span class="hljs-number">100</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span>  <span class="hljs-comment">//修改值的话 我们这里传入指针类型变量</span>setFunc(&amp;a)fmt.Println(a)&#125;</code></pre><h2 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h2><p>任意值通过reflect.TypeOf() 获取反射对象信息后，如果他的类型是结构体，可以通过反射值对象（reflect.Type)的NumFiled()和Field()方法获的结构体成员的详细信息</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> Stu1 <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name1&quot;`</span>Age  <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;age1&quot;`</span>Sex  <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;sex1&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Stu1)</span> <span class="hljs-title">GetInfo</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;str := fmt.Sprintf(<span class="hljs-string">&quot;姓名：%v, 年龄：%v，性别： %v&quot;</span>, s.Name, s.Age, s.Sex)<span class="hljs-keyword">return</span> str&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stu1)</span> <span class="hljs-title">SetInfo</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>, sex <span class="hljs-keyword">string</span>)</span></span> &#123;s.Name = names.Age = ages.Sex = sex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Stu1)</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;我是一个Print打印方法&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectStruct</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-comment">//判断传入的参数是不是结构体</span>t := reflect.TypeOf(s)v := reflect.ValueOf(s)fmt.Println(t.Kind())<span class="hljs-keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct &#123;fmt.Println(<span class="hljs-string">&quot;传入的不是结构体类型&quot;</span>)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">//通过类型变量里面的Field可以获取结构体的字段</span>field0 := t.Field(<span class="hljs-number">0</span>)fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, field0)fmt.Printf(<span class="hljs-string">&quot;字段名称：%v\n&quot;</span>, field0.Name)fmt.Printf(<span class="hljs-string">&quot;字段类型：%v\n&quot;</span>, field0.Type)fmt.Printf(<span class="hljs-string">&quot;tag标签：%v\n&quot;</span>, field0.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<span class="hljs-comment">//通过类型变量里面的FieldByName可以获取结构体的字段</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)field1, ok := t.FieldByName(<span class="hljs-string">&quot;Age&quot;</span>)<span class="hljs-keyword">if</span> ok &#123;fmt.Println(<span class="hljs-string">&quot;字段名称：&quot;</span>, field1.Name)fmt.Println(<span class="hljs-string">&quot;字段类型：&quot;</span>, field1.Type)fmt.Println(<span class="hljs-string">&quot;字段Tag：&quot;</span>, field1.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))&#125;<span class="hljs-comment">//通过类型变量里面的NumField获取该结构体有几个字段</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)<span class="hljs-keyword">var</span> count = t.NumField()fmt.Printf(<span class="hljs-string">&quot;结构体有 %v 个属性\n&quot;</span>, count)<span class="hljs-comment">//通过值变量 获取结构体属性对应的值</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)fmt.Println(v.FieldByName(<span class="hljs-string">&quot;Name&quot;</span>))fmt.Println(v.FieldByName(<span class="hljs-string">&quot;Age&quot;</span>))fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;fmt.Printf(<span class="hljs-string">&quot;属性名称：%v,属性的值：%v，属性类型：%v，属性Tag值：%v\n&quot;</span>, t.Field(i).Name, v.Field(i), t.Field(i).Type, t.Field(i).Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pStruct</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;t := reflect.TypeOf(s)v := reflect.ValueOf(s)fmt.Println(t.Kind())<span class="hljs-keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct &#123;fmt.Println(<span class="hljs-string">&quot;传入的不是结构体&quot;</span>)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">//通过类型变量里面的Method方法可以获取结构体的方法</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)m0 := t.Method(<span class="hljs-number">0</span>)fmt.Println(m0.Name)fmt.Println(m0.Type)<span class="hljs-comment">//通过类型变量获取这个结构体有多少方法</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)m1, ok := t.MethodByName(<span class="hljs-string">&quot;Print&quot;</span>)<span class="hljs-keyword">if</span> ok &#123;fmt.Println(m1.Name)fmt.Println(m1.Type)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;none&quot;</span>)&#125;<span class="hljs-comment">//通过&lt;&lt;值变量&gt;&gt; 执行方法 (注意需要使用值变量，并且要注意参数）v.Method(0).Call(nil)</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)v.Method(<span class="hljs-number">1</span>).Call(<span class="hljs-literal">nil</span>)info := v.MethodByName(<span class="hljs-string">&quot;GetInfo&quot;</span>).Call(<span class="hljs-literal">nil</span>)fmt.Println(info)<span class="hljs-comment">//执行方法传入参数，（注意需要值变量，并且要注意参数，接收的参数是[]reflect.Value的切片）</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)<span class="hljs-keyword">var</span> params []reflect.Valueparams = <span class="hljs-built_in">append</span>(params, reflect.ValueOf(<span class="hljs-string">&quot;李四&quot;</span>))params = <span class="hljs-built_in">append</span>(params, reflect.ValueOf(<span class="hljs-number">19</span>))params = <span class="hljs-built_in">append</span>(params, reflect.ValueOf(<span class="hljs-string">&quot;girl&quot;</span>))v.MethodByName(<span class="hljs-string">&quot;SetInfo&quot;</span>).Call(params) <span class="hljs-comment">//给方法函数 传入参数</span>info2 := v.MethodByName(<span class="hljs-string">&quot;GetInfo&quot;</span>).Call(<span class="hljs-literal">nil</span>)<span class="hljs-comment">//再次通过GetInfo 方法打印 结构体 看看是上面修改值 是否 已经改变</span>fmt.Println(info2)<span class="hljs-comment">//获取方法的数量</span>fmt.Println(<span class="hljs-string">&quot;--------&quot;</span>)fmt.Printf(<span class="hljs-string">&quot;方法数量：%v\n&quot;</span>, t.NumMethod())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeStruct</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;t := reflect.TypeOf(s)v := reflect.ValueOf(s)<span class="hljs-keyword">if</span> t.Kind() != reflect.Ptr &#123;fmt.Println(<span class="hljs-string">&quot;传入的不是结构体指针&quot;</span>)<span class="hljs-keyword">return</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.Elem().Kind() != reflect.Struct &#123;fmt.Println(<span class="hljs-string">&quot;传入的不是结构体&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;----change struct-----&quot;</span>)<span class="hljs-comment">//修改结构体属性的值 （通过值变量）</span>name := v.Elem().FieldByName(<span class="hljs-string">&quot;Name&quot;</span>)name.SetString(<span class="hljs-string">&quot;李武&quot;</span>)age := v.Elem().FieldByName(<span class="hljs-string">&quot;Age&quot;</span>)age.SetInt(<span class="hljs-number">20</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s1 = Stu1&#123;Name: <span class="hljs-string">&quot;bds&quot;</span>,Age:  <span class="hljs-number">18</span>,Sex:  <span class="hljs-string">&quot;man&quot;</span>,&#125;fmt.Println(<span class="hljs-string">&quot;--- main1 -----&quot;</span>)reflectStruct(s1)fmt.Println(<span class="hljs-string">&quot;--- main2 -----&quot;</span>)pStruct(&amp;s1) <span class="hljs-comment">//因为要修改结构体 ，所以要传入指针类型</span>fmt.Println(<span class="hljs-string">&quot;--- main3 -----&quot;</span>)fmt.Println(s1)fmt.Println(<span class="hljs-string">&quot;--- main4 -----&quot;</span>)changeStruct(&amp;s1)fmt.Println(s1)  <span class="hljs-comment">//再次打印 看值 是否修改成功</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">--- main1 -----</span><span class="hljs-comment">struct</span><span class="hljs-comment">reflect.StructField&#123;Name:&quot;Name&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x10d1760), Tag:&quot;json:\&quot;name1\&quot;&quot;, Offset:0x0, Index:[]int&#123;0&#125;, Anonymous:false&#125;</span><span class="hljs-comment">字段名称：Name</span><span class="hljs-comment">字段类型：string</span><span class="hljs-comment">tag标签：name1</span><span class="hljs-comment">--------</span><span class="hljs-comment">字段名称： Age</span><span class="hljs-comment">字段类型： int</span><span class="hljs-comment">字段Tag： age1</span><span class="hljs-comment">--------</span><span class="hljs-comment">结构体有 3 个属性</span><span class="hljs-comment">--------</span><span class="hljs-comment">bds</span><span class="hljs-comment">18</span><span class="hljs-comment">--------</span><span class="hljs-comment">属性名称：Name,属性的值：bds，属性类型：string，属性Tag值：name1</span><span class="hljs-comment">属性名称：Age,属性的值：18，属性类型：int，属性Tag值：age1</span><span class="hljs-comment">属性名称：Sex,属性的值：man，属性类型：string，属性Tag值：sex1</span><span class="hljs-comment">--- main2 -----</span><span class="hljs-comment">ptr</span><span class="hljs-comment">--------</span><span class="hljs-comment">GetInfo</span><span class="hljs-comment">func(*main.Stu1) string</span><span class="hljs-comment">--------</span><span class="hljs-comment">Print</span><span class="hljs-comment">func(*main.Stu1)</span><span class="hljs-comment">--------</span><span class="hljs-comment">我是一个Print打印方法</span><span class="hljs-comment">[姓名：bds, 年龄：18，性别： man]</span><span class="hljs-comment">--------</span><span class="hljs-comment">[姓名：李四, 年龄：19，性别： girl]</span><span class="hljs-comment">--------</span><span class="hljs-comment">方法数量：3</span><span class="hljs-comment">--- main3 -----</span><span class="hljs-comment">&#123;李四 19 girl&#125;</span><span class="hljs-comment">--- main4 -----</span><span class="hljs-comment">----change struct-----</span><span class="hljs-comment">&#123;李武 20 girl&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Channel管道</title>
    <link href="/2020/12/19/Go-channel%E7%AE%A1%E9%81%93/"/>
    <url>/2020/12/19/Go-channel%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<pre><code>管道是golang语言级别上提供的goroutine之间的通信方式，可以使用channel在多个goroutine之间传递消息，如果说goroutine是Go程序并发的执行体，channel就是他们之间的连接，channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</code></pre><p>​    golang的并发模型是CSP（Communicating Sequential Processes) 提倡通过通信共享内存，而不是通过共享内存而实现通信</p><p>​    Go语言中的管道 channel 是一种特殊的类型，管道想一个传达带和队列，总是遵循先入先出（FIFO）的规则，保证收发数据的顺序，每个管道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h2 id="1-channel-管道"><a href="#1-channel-管道" class="headerlink" title="1 channel 管道"></a>1 channel 管道</h2><p>channel是一种类型，而且是<code> 引用类型</code> </p><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span></code></pre><h2 id="2-创建管道make"><a href="#2-创建管道make" class="headerlink" title="2 创建管道make"></a>2 创建管道make</h2><p>声明的管道后需要使用make函数来 初始化之后才能使用</p><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> 元素类型 ,容量）</code></pre><h3 id="3-channel操作"><a href="#3-channel操作" class="headerlink" title="3 channel操作"></a>3 channel操作</h3><p>管道发送（send) ，接收（recevie） 和关闭（close） 三种类型</p><h3 id="3-1-发送和接收："><a href="#3-1-发送和接收：" class="headerlink" title="3.1 发送和接收："></a>3.1 发送和接收：</h3><p> <code>发送和接收都是用 &lt;- 符号  </code></p><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">3</span>)ch &lt;<span class="hljs-number">-10</span>    <span class="hljs-comment">//把10 发送给 ch 管道中</span>x := &lt;- ch <span class="hljs-comment">//从ch管道中接收值 赋值给x</span>&lt;- ch      <span class="hljs-comment">//也是从ch管道接收值 但是忽略结果</span></code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)ch1 &lt;- <span class="hljs-number">10</span>ch1 &lt;- <span class="hljs-number">20</span>ch1 &lt;- <span class="hljs-number">30</span>x := &lt;-ch1&lt;-ch1y := &lt;-ch1fmt.Println(x, y)ch1 &lt;- <span class="hljs-number">40</span>  <span class="hljs-comment">//再次赋值，这样管道中就存储一个值 </span>fmt.Printf(<span class="hljs-string">&quot;值%v,容量%v,长度%v&quot;</span>, ch1, <span class="hljs-built_in">cap</span>(ch1), <span class="hljs-built_in">len</span>(ch1))&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">10 30</span><span class="hljs-comment">值0xc00013a000,容量3,长度1</span><span class="hljs-comment">*/</span></code></pre><h3 id="3-2-管道阻塞"><a href="#3-2-管道阻塞" class="headerlink" title="3.2 管道阻塞"></a>3.2 管道阻塞</h3><p>就是管道容量已经满了，再插入值 或者 管道已经空了，再次取数据 就会阻塞，一边存一边取管道就会里面数据是流动的，就不会阻塞</p><h3 id="3-3-关闭管道"><a href="#3-3-关闭管道" class="headerlink" title="3.3 关闭管道"></a>3.3 关闭管道</h3><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">11</span>)ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">11</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;ch1 &lt;- i&#125;<span class="hljs-built_in">close</span>(ch1)   <span class="hljs-comment">//注意一定要关闭管道 否则会发生死锁</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;ch2 &lt;- i&#125;<span class="hljs-built_in">close</span>(ch2) <span class="hljs-comment">//注意一定要关闭管道 否则会发生死锁</span><span class="hljs-keyword">for</span> y := <span class="hljs-number">1</span>; y &lt; <span class="hljs-number">10</span>; y++ &#123;y := &lt;-ch2fmt.Println(y)&#125;<span class="hljs-comment">//可以通过range 循环遍历channel</span><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch2 &#123;v1 := &lt;-ch2fmt.Println(v, v1)&#125;&#125;</code></pre><h2 id="3-Goroutine-结合channel-管道"><a href="#3-Goroutine-结合channel-管道" class="headerlink" title="3 Goroutine 结合channel 管道"></a>3 Goroutine 结合channel 管道</h2><p>我们定义俩个方法 一个进行写数据 一个进行读数据 ，要求同步进行</p><p>如果写入比较慢，读取比较快，读取会进行等待，因为管道是安全也不会出现问题的</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;ch &lt;- itime.Sleep(time.Millisecond * <span class="hljs-number">500</span>)fmt.Println(<span class="hljs-string">&quot;写入数据&quot;</span>, i)&#125;<span class="hljs-built_in">close</span>(ch)wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> ch &#123;time.Sleep(time.Millisecond * <span class="hljs-number">50</span>)fmt.Println(<span class="hljs-string">&quot;读取数据&quot;</span>, x)&#125;wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> fn1(ch)wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> fn2(ch)wg.Wait()fmt.Println(<span class="hljs-string">&quot;exit...&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">读取数据 1</span><span class="hljs-comment">写入数据 1</span><span class="hljs-comment">读取数据 2</span><span class="hljs-comment">写入数据 2</span><span class="hljs-comment">读取数据 3</span><span class="hljs-comment">写入数据 3</span><span class="hljs-comment">读取数据 4</span><span class="hljs-comment">写入数据 4</span><span class="hljs-comment">读取数据 5</span><span class="hljs-comment">写入数据 5</span><span class="hljs-comment">读取数据 6</span><span class="hljs-comment">写入数据 6</span><span class="hljs-comment">读取数据 7</span><span class="hljs-comment">写入数据 7</span><span class="hljs-comment">读取数据 8</span><span class="hljs-comment">写入数据 8</span><span class="hljs-comment">读取数据 9</span><span class="hljs-comment">写入数据 9</span><span class="hljs-comment">exit...</span><span class="hljs-comment">*/</span></code></pre><h2 id="4-统计素数"><a href="#4-统计素数" class="headerlink" title="4 统计素数"></a>4 统计素数</h2><p>结合goroutine 协程  和 channel   来实现</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-comment">//向intChan中存放数据</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">putNum</span><span class="hljs-params">(intChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100000</span>; i++ &#123;intChan &lt;- i&#125;<span class="hljs-built_in">close</span>(intChan)wg.Done()&#125;<span class="hljs-comment">//从initChan中取出数据，进行判断是否为素数，如果是，就把得到的素数放在primeChan中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">primeNum</span><span class="hljs-params">(intChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, primeChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, exitChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> intChan &#123;<span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; num; i++ &#123;<span class="hljs-keyword">if</span> num%i == <span class="hljs-number">0</span> &#123;flag = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-keyword">if</span> flag &#123;primeChan &lt;- num <span class="hljs-comment">//num 是素数</span>&#125;&#125;<span class="hljs-comment">//在统计素数的时候 我们用了16个协程，所以需要知道什么时候16个协程执行完成后，在关闭channel</span>exitChan &lt;- <span class="hljs-literal">true</span>wg.Done()<span class="hljs-comment">//close(primeChan)  //如果一个channel关闭了就没有办法给这个channel发送数据了。</span>&#125;<span class="hljs-comment">//打印素数的方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printPrime</span><span class="hljs-params">(primeChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//for v := range primeChan &#123;</span><span class="hljs-comment">//fmt.Println(&quot;primechan&quot;, v)</span><span class="hljs-comment">//&#125;</span>wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;start := time.Now().Unix()intChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>)primeChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100000</span>)exitChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>, <span class="hljs-number">16</span>)<span class="hljs-comment">//往整数管道中打印数字 协程</span>wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> putNum(intChan)<span class="hljs-comment">//统计整数管道中的素数 ，然后写入素数管道,使用16个协程</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> primeNum(intChan, primeChan, exitChan)&#125;<span class="hljs-comment">//通过匿名函数来实现一个协程 判断exitChan是否存满16个值</span>wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++ &#123;&lt;-exitChan&#125;<span class="hljs-comment">//满足16个值 相当于上面16个统计素数的协程已经执行完毕。</span><span class="hljs-built_in">close</span>(primeChan)wg.Done()&#125;()<span class="hljs-comment">//打印素数协程，从素数管道中取值</span>wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> printPrime(primeChan)wg.Wait()stop := time.Now().Unix()fmt.Println(<span class="hljs-string">&quot;exec:&quot;</span>, stop-start)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">exec: 2</span><span class="hljs-comment">*/</span></code></pre><h2 id="5-单向管道"><a href="#5-单向管道" class="headerlink" title="5 单向管道"></a>5 单向管道</h2><p>有的时候 我们会将管道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用管道都会对其进行限制，比如限制管道在函数中只能发送或者只能接收</p><p>默认情况下 管道是双向的</p><pre><code class="hljs go">双向管道<span class="hljs-keyword">var</span> chan1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span> 只写管道<span class="hljs-keyword">var</span> chan2 <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span> 只读管道<span class="hljs-keyword">var</span> chan3 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span></code></pre><h2 id="6-select"><a href="#6-select" class="headerlink" title="6 select"></a>6 select</h2><p>在某些场景下 我们需要同时从多个通道接收数据，这个时候，就可以用到golang中给我们提供的select多路复用</p><p>通常情况下 通道在接收数据时候， 如果没有数据可以接收将会发生阻塞</p><p>语法如下： 可以结合for 循环来实现</p><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123; <span class="hljs-keyword">case</span> &lt;-ch1:  ...<span class="hljs-keyword">case</span>  data := &lt;-ch2:  ...<span class="hljs-keyword">case</span> ch3 &lt;- data:   ...<span class="hljs-keyword">default</span>:  ...</code></pre><p>案例</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;intChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;intChan &lt;- i&#125;stringChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;stringChan &lt;- <span class="hljs-string">&quot;hello&quot;</span> + fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, i)&#125;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">//使用select获取管道数据的时候，不需要close通道</span><span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> v := &lt;-intChan:fmt.Printf(<span class="hljs-string">&quot;from intChan data: %d\n&quot;</span>, v)<span class="hljs-keyword">case</span> v := &lt;-stringChan:fmt.Printf(<span class="hljs-string">&quot;from intChan data: %s\n&quot;</span>, v)<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">&quot;读取数据完毕\n&quot;</span>)<span class="hljs-keyword">return</span> <span class="hljs-comment">//退出for循环</span>&#125;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">from intChan data: 0</span><span class="hljs-comment">from intChan data: hello0</span><span class="hljs-comment">from intChan data: hello1</span><span class="hljs-comment">from intChan data: 1</span><span class="hljs-comment">from intChan data: hello2</span><span class="hljs-comment">from intChan data: hello3</span><span class="hljs-comment">from intChan data: 2</span><span class="hljs-comment">from intChan data: hello4</span><span class="hljs-comment">from intChan data: 3</span><span class="hljs-comment">from intChan data: 4</span><span class="hljs-comment">from intChan data: hello5</span><span class="hljs-comment">from intChan data: hello6</span><span class="hljs-comment">from intChan data: hello7</span><span class="hljs-comment">from intChan data: hello8</span><span class="hljs-comment">from intChan data: 5</span><span class="hljs-comment">from intChan data: 6</span><span class="hljs-comment">from intChan data: 7</span><span class="hljs-comment">from intChan data: 8</span><span class="hljs-comment">from intChan data: hello9</span><span class="hljs-comment">from intChan data: 9</span><span class="hljs-comment">读取数据完毕</span><span class="hljs-comment">*/</span></code></pre><h2 id="7-解决协程出现的panic"><a href="#7-解决协程出现的panic" class="headerlink" title="7 解决协程出现的panic"></a>7 解决协程出现的panic</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;test() 发生异常错误&quot;</span>, err)wg.Done()&#125;&#125;()<span class="hljs-keyword">var</span> myMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>myMap[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;golang&quot;</span> <span class="hljs-comment">//这里故意写错 发生error </span>wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> test()wg.Wait()fmt.Println(<span class="hljs-string">&quot;status2 ...&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">test() 发生异常错误 assignment to entry in nil map</span><span class="hljs-comment">status2 ...</span><span class="hljs-comment">*/</span></code></pre><h2 id="8-Go并发安全锁"><a href="#8-Go并发安全锁" class="headerlink" title="8 Go并发安全锁"></a>8 Go并发安全锁</h2><h3 id="8-1-互斥锁"><a href="#8-1-互斥锁" class="headerlink" title="8.1 互斥锁"></a>8.1 互斥锁</h3><p>互斥锁是传统并发编程中共享资源进行访问控制的主要手段，他由标准库sync中的Mutex 结构体类型表示，sync.Mutex类型中只有俩个公开的指针方法，Lock和Unlock ,Lock锁定当前的共享资源，Unlock进行解锁</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup   <span class="hljs-keyword">var</span> mutex sync.Mutex  <span class="hljs-comment">//声明一把锁</span><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;mutex.Lock()<span class="hljs-comment">//添加一个互斥锁</span>count++fmt.Println(count)mutex.Unlock()     <span class="hljs-comment">//释放互斥锁</span>wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> test()&#125;wg.Wait()fmt.Println(<span class="hljs-string">&quot;exit...&quot;</span>)&#125;<span class="hljs-comment">// 这个时候我们可以通过 &quot;go run -race 程序代码.go&quot; 执行来查看一个执行流程和最后是否显示报错信息</span><span class="hljs-comment">/*</span><span class="hljs-comment">1</span><span class="hljs-comment">2</span><span class="hljs-comment">3</span><span class="hljs-comment">4</span><span class="hljs-comment">5</span><span class="hljs-comment">6</span><span class="hljs-comment">7</span><span class="hljs-comment">8</span><span class="hljs-comment">9</span><span class="hljs-comment">10</span><span class="hljs-comment">exit...</span><span class="hljs-comment">*/</span></code></pre><p>使用互斥锁能够保证同一时间去有且只有一个gouroutine 进入临界区，其他的goroutine则在等待。当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的</p><h3 id="8-2-读写互斥锁"><a href="#8-2-读写互斥锁" class="headerlink" title="8.2 读写互斥锁"></a>8.2 读写互斥锁</h3><p>互斥锁的本质是当一个goroutine访问的时候，其他goroutinge都不能访问，这样在资源同步避免了竞争的同时也降低了程序的并发性能，程序由原来的的并行变成了串行执行</p><p>其实 当我们对一个不回变化的数据只做<code>读</code>操作的话，是不存在资源的竞争的问题，因为数据是不变的，不管怎么读取 多个goroutine同时读取，都是可以的</p><p>所以问题不是出在<code>读</code>上，主要是修改，也就是<code>写</code>，修改的数据要同步，这样其他goroutine才可以感知到，所以真正的互斥影视读取和修改，修改和修改之间，读和读是没有互斥操作的必要的，因此 衍生出了另外一种锁 叫做读写锁 </p><p>读写锁可以让你多个读操作进行并发 同时读取，但是对于写操作是完全互斥的，也就是说当一个goroutine进行写操作的时候， 其他goroutine 是既不能够写也不能够读取，也不能进行写操作。 </p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-keyword">var</span> mutex sync.RWMutex   <span class="hljs-comment">//读写互斥锁</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> &#123;mutex.Lock()fmt.Printf(<span class="hljs-string">&quot;&lt;--写入数据：\n&quot;</span>)time.Sleep(time.Second * <span class="hljs-number">1</span>)mutex.Unlock()wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;mutex.RLock()<span class="hljs-comment">//可以同时读取</span>fmt.Printf(<span class="hljs-string">&quot;--&gt;读取数据：\n&quot;</span>)time.Sleep(time.Second * <span class="hljs-number">1</span>)mutex.RUnlock()wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> write()&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> read()&#125;wg.Wait()&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go goroutine协程</title>
    <link href="/2020/12/15/Go-goroutine%E5%8D%8F%E7%A8%8B/"/>
    <url>/2020/12/15/Go-goroutine%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-关于进程和线程"><a href="#1-关于进程和线程" class="headerlink" title="1 关于进程和线程"></a>1 关于进程和线程</h2><p><code>进程（Process)</code>·就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个过程都有一个自己的地址空间，一个进程至少有5种基本状态，他们是： 初始态，执行态，等待状态，就绪状态，终止状态</p><p><code>线程</code>： 是进程中的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行 的基本单位</p><p>一个进程可以创建多个线程，同一个进程中的多个线程可以并发执行。一个程序要运行的话至少有一个进程</p><h2 id="2-关于并发和并行"><a href="#2-关于并发和并行" class="headerlink" title="2 关于并发和并行"></a>2 关于并发和并行</h2><p><code>并发</code>： 多个线程竞争一个位置，竞争到的才可以执行， 每个时间段只有一个线程在执行</p><p><code>并行</code>： 多个线程可以同时执行， 每个时间段可以有多个线程同时执行</p><p><code>通俗的讲</code>： 多线程程序在单核CPU上面运行就是<code>并发</code>，多程序程序在多核CPU上运行就是<code>并行</code>，如果线程数大于cpu核心数，则多线程序在多个cpu上面运行既有并行又有并发</p><h2 id="3-Golang中的协程（goroutine）以及主线程"><a href="#3-Golang中的协程（goroutine）以及主线程" class="headerlink" title="3 Golang中的协程（goroutine）以及主线程"></a>3 Golang中的协程（goroutine）以及主线程</h2><p><code>golang中的主线程</code>： (可以理解为线程/也可以理解为进程)，在一个Golang程序的主线程上可以起多个协程，Golang中多协程可以实现并行或者并发</p><p><code>协程</code>： 可以理解为用户级别线程，这是对内核透明的，也就是操作系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。Golang的一大特色就是从语言层面原生支持协程，在函数或者方法前面go 关键字就可以创建一个协程， 可以说Golang中的协程就是goroutine </p><p><code>多协程特点</code>： Golang中每个goroutine默认占用内存远比java c的线程少，一个goroutine协程占用的内存非常小，只有2kb左右，多协程goroutine切换调度开销方面远比线程要少，这也是为什么越来越多的大公司使用Golang原因之一</p><h2 id="4-通过代码演示"><a href="#4-通过代码演示" class="headerlink" title="4 通过代码演示"></a>4 通过代码演示</h2><p>并行执行需求： </p><p>​    在主线程开启一个goroutine 该协程每隔50毫秒输出 “你好Golang”,在主线程中也每隔50毫秒输出”你好golang”，输出10次后，退出程序，要求主线程和goroutine 同时进行</p><p>首先我们只是开启一个协程，发现有一个bug 就是main函数不会等待协程执行完成后退出，而是自己执行完成就退出，因为main本身也是一个协程</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Println(<span class="hljs-string">&quot;sum() 你好golang &quot;</span>, i)time.Sleep(time.Millisecond * <span class="hljs-number">10</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> Sum()  <span class="hljs-comment">//开启一个协程</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Println(<span class="hljs-string">&quot;main() 你好py&quot;</span>, i)time.Sleep(time.Millisecond)&#125;&#125;</code></pre><pre><code class="hljs go">main() 你好py <span class="hljs-number">1</span>sum() 你好golang  <span class="hljs-number">1</span>main() 你好py <span class="hljs-number">2</span>main() 你好py <span class="hljs-number">3</span>main() 你好py <span class="hljs-number">4</span>main() 你好py <span class="hljs-number">5</span>main() 你好py <span class="hljs-number">6</span>main() 你好py <span class="hljs-number">7</span>main() 你好py <span class="hljs-number">8</span>main() 你好py <span class="hljs-number">9</span>sum() 你好golang  <span class="hljs-number">2</span></code></pre><p>使用sync.waitGroup来实现，等待所有协程执行完毕</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">//定义一个sync.waitGroup</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Println(<span class="hljs-string">&quot;sum() 你好golang &quot;</span>, i)&#125;wg.Done() <span class="hljs-comment">//协程计算减1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum1</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Println(<span class="hljs-string">&quot;sum1() 你好shell&quot;</span>, i)&#125;wg.Done()  <span class="hljs-comment">//协程计算减1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;wg.Add(<span class="hljs-number">1</span>)  <span class="hljs-comment">//协程计算加1</span><span class="hljs-keyword">go</span> Sum()   <span class="hljs-comment">//开启一个协程</span>wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> sum1()  <span class="hljs-comment">//开启一个协程</span>wg.Wait()  <span class="hljs-comment">//等待所有协程执行完成</span>fmt.Println(<span class="hljs-string">&quot;main主线程退出&quot;</span>)&#125;</code></pre><pre><code class="hljs go">sum1() 你好shell <span class="hljs-number">1</span>sum1() 你好shell <span class="hljs-number">2</span>sum1() 你好shell <span class="hljs-number">3</span>sum1() 你好shell <span class="hljs-number">4</span>sum1() 你好shell <span class="hljs-number">5</span>sum1() 你好shell <span class="hljs-number">6</span>sum1() 你好shell <span class="hljs-number">7</span>sum1() 你好shell <span class="hljs-number">8</span>sum1() 你好shell <span class="hljs-number">9</span>sum() 你好golang  <span class="hljs-number">1</span>sum() 你好golang  <span class="hljs-number">2</span>sum() 你好golang  <span class="hljs-number">3</span>sum() 你好golang  <span class="hljs-number">4</span>sum() 你好golang  <span class="hljs-number">5</span>sum() 你好golang  <span class="hljs-number">6</span>sum() 你好golang  <span class="hljs-number">7</span>sum() 你好golang  <span class="hljs-number">8</span>sum() 你好golang  <span class="hljs-number">9</span>main主线程退出</code></pre><h2 id="5-设置golang-运行时占的cpu"><a href="#5-设置golang-运行时占的cpu" class="headerlink" title="5 设置golang 运行时占的cpu"></a>5 设置golang 运行时占的cpu</h2><p>golang程序默认占有所有核心cpu</p><pre><code class="hljs go">cpuNum := runtime.NumCPU()<span class="hljs-comment">//获取当前cpu个数</span>runtime.GOMAXPROCS(cpuNum - <span class="hljs-number">1</span> ) <span class="hljs-comment">//设置程序占有的cpu数量</span></code></pre><h2 id="6-开启多协程执行"><a href="#6-开启多协程执行" class="headerlink" title="6 开启多协程执行"></a>6 开启多协程执行</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">//最后执行wg.Done 计算器减1</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;fmt.Printf(<span class="hljs-string">&quot;协程（%v）,数据%v\n&quot;</span>, num, i)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> test(i)&#125;wg.Wait()fmt.Println(<span class="hljs-string">&quot;main退出&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">协程（4）,数据1</span><span class="hljs-comment">协程（4）,数据2</span><span class="hljs-comment">协程（4）,数据3</span><span class="hljs-comment">协程（1）,数据1</span><span class="hljs-comment">协程（1）,数据2</span><span class="hljs-comment">协程（1）,数据3</span><span class="hljs-comment">协程（3）,数据1</span><span class="hljs-comment">协程（3）,数据2</span><span class="hljs-comment">协程（3）,数据3</span><span class="hljs-comment">协程（2）,数据1</span><span class="hljs-comment">协程（2）,数据2</span><span class="hljs-comment">协程（2）,数据3</span><span class="hljs-comment">main退出</span><span class="hljs-comment">*/</span></code></pre><h2 id="7-统计素数"><a href="#7-统计素数" class="headerlink" title="7 统计素数"></a>7 统计素数</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumS</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> num := <span class="hljs-number">2</span>; num &lt; <span class="hljs-number">120000</span>; num++ &#123;flag := <span class="hljs-literal">true</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; num; i++ &#123;<span class="hljs-keyword">if</span> num%i == <span class="hljs-number">0</span> &#123;flag = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-keyword">if</span> flag &#123;<span class="hljs-comment">//fmt.Println(num)</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Println(i)&#125;timeStart := time.Now().Unix()sumS()timeStop := time.Now().Unix()fmt.Println(timeStop - timeStart)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Cobra笔记</title>
    <link href="/2020/12/14/Go-Cobra/"/>
    <url>/2020/12/14/Go-Cobra/</url>
    
    <content type="html"><![CDATA[<p>Cobra 是一个 Golang 包，它提供了简单的接口来创建命令行程序。同时，Cobra 也是一个应用程序，用来生成应用框架，从而开发以 Cobra 为基础的应用</p><h2 id="Cobra-介绍"><a href="#Cobra-介绍" class="headerlink" title="Cobra 介绍"></a>Cobra 介绍</h2><ul><li>Cobra 是一个功能强大的现代化CLI应用程序库</li><li>有很多知名的Go项目使用Cobra进行构建，比如k8s，Docker，Hugo等</li><li>比默认的flag包强大很多</li></ul><h2 id="Cobra-概念"><a href="#Cobra-概念" class="headerlink" title="Cobra 概念"></a>Cobra 概念</h2><p>Cobra是由Commands，arguments，flags组成的 比如下面例子：</p><pre><code class="hljs go">kubelet get pods -n kube-system</code></pre><ul><li>app应用程序： kubelet </li><li>command: get 表示具体的操作</li><li>args: pods 表示参数</li><li>flags:  是这些操作的修饰符 比如 -n</li><li>args： kube-system </li></ul><h2 id="Corbra-安装和应用"><a href="#Corbra-安装和应用" class="headerlink" title="Corbra 安装和应用"></a>Corbra 安装和应用</h2><p>获取第三方包的时候，通过代理，可以加速下载访问</p><pre><code class="hljs go">export GOPROXY=https:<span class="hljs-comment">//goproxy.cn</span></code></pre><h3 id="cobra-安装"><a href="#cobra-安装" class="headerlink" title="cobra 安装"></a>cobra 安装</h3><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod init my-calc <span class="hljs-keyword">go</span> get -u github.com/spf13/cobra/cobra</code></pre><h3 id="cobra-初始化项目"><a href="#cobra-初始化项目" class="headerlink" title="cobra 初始化项目"></a>cobra 初始化项目</h3><pre><code class="hljs applescript">(base) ➜  <span class="hljs-keyword">my</span>-calc cobra init  <span class="hljs-comment">--pkg-name my-calc </span>Your Cobra <span class="hljs-built_in">application</span> <span class="hljs-keyword">is</span> ready <span class="hljs-keyword">at</span>/Users/budongshu/go/<span class="hljs-keyword">my</span>-calc</code></pre><h3 id="cobra-执行流程"><a href="#cobra-执行流程" class="headerlink" title="cobra 执行流程"></a>cobra 执行流程</h3><p>修改root.go代码</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201214002612850.png" alt="image-20201214002612850"></p><p>![image-20201214002630682](/Users/budongshu/Library/Application Support/typora-user-images/image-20201214002630682.png)</p><p>修改main.go 代码</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201214002657535.png" alt="image-20201214002657535"></p><p>下面可以看到输出流程</p><pre><code class="hljs go">#  <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> I am init I am main I am initConfig</code></pre><h3 id="cobra-添加一个命令sum"><a href="#cobra-添加一个命令sum" class="headerlink" title="cobra 添加一个命令sum"></a>cobra 添加一个命令sum</h3><p>sum子命令实现把后面的参数args 跟的int 数字进行 求和</p><pre><code class="hljs go"><span class="hljs-comment">//通过cobra 添加一个子命令  会生成sum.go 代码 </span># cobra add sum<span class="hljs-comment">// sum 1 2 3 </span># <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> sum <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> sum calledSum of num: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] is  <span class="hljs-number">6</span></code></pre><p>上面生成的sum.go代码 我们通过修改sum.go来实现</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum</span><span class="hljs-params">(args []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> _,val := <span class="hljs-keyword">range</span> args &#123;temp,err := strconv.Atoi(val)<span class="hljs-keyword">if</span> err  != <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;convert %s to int is error; %v\n&quot;</span>,val,err)<span class="hljs-keyword">continue</span>&#125;sum += temp&#125;fmt.Printf(<span class="hljs-string">&quot;Sum of num: %s is  %d\n&quot;</span>,args,sum)&#125;</code></pre><p>在sum.go 上面这里引用</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201214003227592.png" alt="image-20201214003227592"></p><p>在sum 基础上添加支持float 数据类型的 求和</p><pre><code class="hljs go"><span class="hljs-comment">//在sum.go 下面添加floatSum函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">floatSum</span><span class="hljs-params">(args []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">var</span> sum1 <span class="hljs-keyword">float64</span><span class="hljs-keyword">for</span> _,valf := <span class="hljs-keyword">range</span> args&#123;tempf,errf := strconv.ParseFloat(valf,<span class="hljs-number">64</span>)<span class="hljs-keyword">if</span> errf  != <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;convert %s to float is error %v\n&quot;</span>,valf,errf)<span class="hljs-keyword">continue</span>&#125;sum1 += tempf&#125;fmt.Printf(<span class="hljs-string">&quot;sum float64 num: %s is %f\n&quot;</span>,args,sum1)&#125;</code></pre><pre><code class="hljs go"><span class="hljs-comment">//在 sum.go中 加入sum 命令本地使用的args 是一个布尔类型的判断</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;rootCmd.AddCommand(sumCmd)sumCmd.Flags().BoolP(<span class="hljs-string">&quot;float&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;Sum float numbers&quot;</span>)  <span class="hljs-comment">//新添加</span></code></pre><pre><code class="hljs go"><span class="hljs-comment">//在sum.go 中 </span>Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-keyword">string</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;sum called&quot;</span>)<span class="hljs-comment">//以下新添加代码，因为上面加一个布尔值，默认是false，可以用来使用,返回的布尔值进行判断</span>fStatus,_ := cmd.Flags().GetBool(<span class="hljs-string">&quot;float&quot;</span>)<span class="hljs-keyword">if</span> fStatus &#123;   <span class="hljs-comment">//如果是True 那就是float ，false 为int</span>floatSum(args)&#125; <span class="hljs-keyword">else</span> &#123;intSum(args)&#125;&#125;,&#125;</code></pre><h3 id="在sum基础上添加子命令"><a href="#在sum基础上添加子命令" class="headerlink" title="在sum基础上添加子命令"></a>在sum基础上添加子命令</h3><p>在sum基础上，加入一个子命令，进行求偶数和的功能</p><pre><code class="hljs go"># cobra add even</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> cmd<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-string">&quot;github.com/spf13/cobra&quot;</span>)<span class="hljs-comment">// evenCmd represents the even command</span><span class="hljs-keyword">var</span> evenCmd = &amp;cobra.Command&#123;Use:   <span class="hljs-string">&quot;even&quot;</span>,Short: <span class="hljs-string">&quot;A brief description of your command&quot;</span>,Long: <span class="hljs-string">`A longer description that spans multiple lines and likely contains examples</span><span class="hljs-string">and usage of using your command. For example:</span><span class="hljs-string"></span><span class="hljs-string">Cobra is a CLI library for Go that empowers applications.</span><span class="hljs-string">This application is a tool to generate the needed files</span><span class="hljs-string">to quickly create a Cobra application.`</span>,Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-keyword">string</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;even called&quot;</span>)evenSum(args)  <span class="hljs-comment">//新加入代码</span>&#125;,&#125;<span class="hljs-comment">//下面为新加入函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//这里面要改成sumCmd 这样才可以做为sum的子命令</span>sumCmd.AddCommand(evenCmd)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">evenSum</span><span class="hljs-params">( args []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> _,val := <span class="hljs-keyword">range</span> args &#123;temp,_ := strconv.Atoi(val)<span class="hljs-keyword">if</span> temp % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;sum += temp&#125;&#125;fmt.Printf(<span class="hljs-string">&quot;%s even %v\n&quot;</span>,args,sum)&#125;</code></pre><p>执行结果</p><pre><code class="hljs go">(base) ➜  my-calc <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> sum  even <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span>  even called[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span>] even <span class="hljs-number">8</span></code></pre><h3 id="最后看帮助信息"><a href="#最后看帮助信息" class="headerlink" title="最后看帮助信息"></a>最后看帮助信息</h3><pre><code class="hljs GO"><span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> -h</code></pre><pre><code class="hljs GO">Usage:  my-calc [command]Available Commands:  help        Help about any command  sum         A brief description of your commandFlags:      --config <span class="hljs-keyword">string</span>   config file (<span class="hljs-keyword">default</span> is $HOME/.my-calc.yaml)  -h, --help            help <span class="hljs-keyword">for</span> my-calc  -t, --toggle          Help message <span class="hljs-keyword">for</span> toggleUse <span class="hljs-string">&quot;my-calc [command] --help&quot;</span> <span class="hljs-keyword">for</span> more information about a command.</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go string和字符类型</title>
    <link href="/2020/12/14/Go-String%E5%92%8C%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/12/14/Go-String%E5%92%8C%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go 语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int,bool,float32,float64等）一样。Go 语言里的字符串的内部实现使用utf-8编码，字符串的值为双引号的内容，可以在Go语言的源码中直接添加非ASCII码子符。例如: </p><pre><code class="hljs GO">s1 := <span class="hljs-string">&quot;hello&quot;</span>s2: = <span class="hljs-string">&quot;你好&quot;</span></code></pre><h2 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h2><pre><code class="hljs go">\r: 回车符（返回行首）\n: 换行符（直接跳到下一行的同列位置\t: 制表符\<span class="hljs-string">&#x27;: 单引号</span><span class="hljs-string">\&quot;: 双引号</span><span class="hljs-string">\\: 反斜杠</span></code></pre><h2 id="字符串定义"><a href="#字符串定义" class="headerlink" title="字符串定义"></a>字符串定义</h2><pre><code class="hljs go"><span class="hljs-keyword">var</span> str1 <span class="hljs-keyword">string</span> <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;你好&quot;</span>str3 := <span class="hljs-string">&quot;你好&quot;</span></code></pre><h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><pre><code class="hljs go">str1 := <span class="hljs-string">`</span><span class="hljs-string">this a 1</span><span class="hljs-string">this a 2</span><span class="hljs-string">this a 3</span><span class="hljs-string">`</span></code></pre><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><pre><code class="hljs go"><span class="hljs-built_in">len</span>(str)                      ：求长度+,fmt.Sprintf：拼接字符串strings.Split：切割字符串strings.contains：是否包含strings.HasPrefix,strings.HasSuffix  ：前缀和尾缀strings.Index(),strings.LastIndex()   ：索引strings.Join(a[]<span class="hljs-keyword">string</span>,sep <span class="hljs-keyword">string</span>)：Join组合</code></pre><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做字符，可以通过遍历字符串元素获得字符，字符用单引号包裹起来 ，golang中定义字符 ，字符属于int类型</p><ul><li><p>字节（byte）： 是计算机中 数据处理的基本单位，习惯上用大写的B来表示1B 表示（byte，字节）= 8bit（位）</p></li><li><p>字符： 是指计算机中使用的字母，数字，字和符号</p></li></ul><h2 id="Go-语言的字符类型"><a href="#Go-语言的字符类型" class="headerlink" title="Go 语言的字符类型"></a>Go 语言的字符类型</h2><ul><li>uint8 类型或者叫做byte型，代表了ASCII码的一个字符</li><li>rune 类型，代表一个UTF-8类型</li></ul><p>当需要处理中文，日本，或者其他复合字符的时候，则需要用到rune类型，rune类型实际是一个int32</p><p>Go 使用投了特殊的rune类型来处理Unicode，让基于Unicode的文本处理更为方便</p><p>也可以使用byte类型进行默认字符串处理，性能和扩展性都有照顾</p><h2 id="Go-修改字符串"><a href="#Go-修改字符串" class="headerlink" title="Go 修改字符串"></a>Go 修改字符串</h2><p>要修改字符串，需要先将其转换成[]rune或者[]byte ，完成后在转换为string,无论那种转换都会重新分配内存，并复制字节数组</p><h2 id="代码演示案例"><a href="#代码演示案例" class="headerlink" title="代码演示案例"></a>代码演示案例</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;unsafe&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//1 2 定义一个字符</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;a&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;ASCII码值：%v 类型：%T，原始值：%c\n&quot;</span>, a, a, a)<span class="hljs-comment">//3 定义一个字符串输出字符串里面的字符</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;this&quot;</span>fmt.Printf(<span class="hljs-string">&quot;值：%v, 类型： %T,原始值 %c \n&quot;</span>, str[<span class="hljs-number">2</span>], str[<span class="hljs-number">2</span>], str[<span class="hljs-number">2</span>])<span class="hljs-comment">//4 一个汉子占用3个字符（utf-8) 一个字母占用一个字符</span><span class="hljs-comment">//unsafe.Sizeof() ： string类型比较特殊 底层是依赖结构体和指针来实现 ，所以Sizeof输出值 不准确</span><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;this&quot;</span>fmt.Println(unsafe.Sizeof(str1))fmt.Println(<span class="hljs-built_in">len</span>(str1)) <span class="hljs-comment">//通过len()来获取字符串长度</span><span class="hljs-comment">//5 定义一个字符 字符的值是汉字</span><span class="hljs-keyword">var</span> a1 = <span class="hljs-string">&#x27;国&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;值：%v,类型：%T\n&quot;</span>, a1, a1)<span class="hljs-comment">//6 通过循环输出字符串里面的字符</span>s := <span class="hljs-string">&quot;你好 golang&quot;</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123; <span class="hljs-comment">//表示通过byte类型循环</span>fmt.Printf(<span class="hljs-string">&quot;%v,%c\n&quot;</span>, s[i], s[i])&#125;fmt.Println(<span class="hljs-string">&quot;-------&quot;</span>)<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123; <span class="hljs-comment">//表示通过rune类型循环</span>fmt.Printf(<span class="hljs-string">&quot;%v,%c\n&quot;</span>, v, v)&#125;<span class="hljs-comment">//7 修改字符串</span>s1 := <span class="hljs-string">&quot;big&quot;</span>byteStr := []<span class="hljs-keyword">byte</span>(s1)byteStr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span>fmt.Println(<span class="hljs-keyword">string</span>(byteStr))s2 := <span class="hljs-string">&quot;hello 中国&quot;</span>runeStr := []<span class="hljs-keyword">rune</span>(s2)runeStr[<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;某&#x27;</span>fmt.Println(<span class="hljs-keyword">string</span>(runeStr))&#125;</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h3><p>数值类型包括： 整形和浮点型</p><p>注意： <strong>转换的时候建议从地位转为高位，因为转换不成功可能会溢出 比如int8 转为 int16</strong>    </p><pre><code class="hljs go"><span class="hljs-comment">//1 int类型之间转换</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int8</span> = <span class="hljs-number">20</span><span class="hljs-keyword">var</span> b0 <span class="hljs-keyword">int16</span> = <span class="hljs-number">10</span>fmt.Println(<span class="hljs-keyword">int16</span>(a) + b0)<span class="hljs-comment">//2 浮点类型之间转换</span><span class="hljs-keyword">var</span> a1 <span class="hljs-keyword">float32</span> = <span class="hljs-number">10.1</span><span class="hljs-keyword">var</span> b1 <span class="hljs-keyword">float64</span> = <span class="hljs-number">10.2</span>fmt.Println(<span class="hljs-keyword">float32</span>(b1) + a1)<span class="hljs-comment">//3 整形和浮点型之间的转换</span><span class="hljs-keyword">var</span> a2 <span class="hljs-keyword">float32</span> = <span class="hljs-number">20.3</span><span class="hljs-keyword">var</span> b2 <span class="hljs-keyword">int</span> = <span class="hljs-number">30</span>fmt.Println(a2 + <span class="hljs-keyword">float32</span>(b2))</code></pre><h3 id="把其他类型转为string类型"><a href="#把其他类型转为string类型" class="headerlink" title="把其他类型转为string类型"></a>把其他类型转为string类型</h3><p>注意： <code>Sprintf </code>使用中需要注意转换的额格式：<code>int -&gt; %d</code> ,<code>float -&gt; %f</code> ,<code>bool -&gt; %t</code>, <code>byte -&gt;%c</code></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> = <span class="hljs-number">12.1</span>str1 := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, i)fmt.Printf(<span class="hljs-string">&quot;值：%v，类型： %T\n&quot;</span>, str1, str1)str2 := fmt.Sprintf(<span class="hljs-string">&quot;%.2f&quot;</span>, f) <span class="hljs-comment">//.2 代表保留俩位小数</span>fmt.Printf(<span class="hljs-string">&quot;值：%v，类型： %T\n&quot;</span>, str2, str2)</code></pre><h3 id="使用strconv包转换"><a href="#使用strconv包转换" class="headerlink" title="使用strconv包转换"></a>使用strconv包转换</h3><p>把整形转为string类型 </p><pre><code class="hljs go"> <span class="hljs-comment">//参数1 ： int64的数值</span> <span class="hljs-comment">//参数2 ： int类型的进制</span><span class="hljs-keyword">var</span> i1 <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span>str3 := strconv.FormatInt(<span class="hljs-keyword">int64</span>(i1), <span class="hljs-number">10</span>)fmt.Printf(<span class="hljs-string">&quot;值：%v，类型：%T&quot;</span>, str3, str3)</code></pre><p>把浮点数转为string类型</p><pre><code class="hljs go"><span class="hljs-comment">//参数1： 要转换的值</span><span class="hljs-comment">//参数2： 格式化类型 &#x27;f&#x27;(-ddd.ddd)</span><span class="hljs-comment">//参数3： 保留的小数值 (-1,不对小数点做格式化）</span><span class="hljs-comment">//参数4：格式化的类型（ 32 64 ）</span><span class="hljs-keyword">var</span> f1 <span class="hljs-keyword">float32</span> = <span class="hljs-number">20.3333</span>str4 := strconv.FormatFloat(<span class="hljs-keyword">float64</span>(f1), <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">64</span>)fmt.Printf(<span class="hljs-string">&quot;值：%v，类型：%T\n&quot;</span>, str4, str4)</code></pre><p>把string类型转为数值类型</p><pre><code class="hljs go"><span class="hljs-comment">// string -&gt; 数值 int 转换失败返回0 </span><span class="hljs-comment">/*</span><span class="hljs-comment">参数1: string数据</span><span class="hljs-comment">参数2: 进制</span><span class="hljs-comment">参数3: 位数 32 64 16</span><span class="hljs-comment">*/</span>str5 := <span class="hljs-string">&quot;123456&quot;</span>num, _ := strconv.ParseInt(str5, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)fmt.Printf(<span class="hljs-string">&quot;值：%v，类型：%T\n&quot;</span>, num, num)</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go beego介绍笔记</title>
    <link href="/2020/12/14/Go-beego-MVC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/12/14/Go-beego-MVC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>bee 和beego</p><p>安装</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> get</code></pre><p>新建项目</p><p>初始化</p><p>启动</p><p>bee run</p><p>mvc 简单介绍</p><p>MVC 全名是Model View Controller 是模型(model) - 视图(view) - 控制器(controller) 的缩写，一种软件设计模式的典范，用一种业务逻辑，数据，界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面以及用户交互的同时，不需要重新编写业务逻辑</p><p>Beego 是一个MVC 框架</p><p>Model（模型）： 主要用于处理应用程序的业务逻辑，以及和数据库进行打交道</p><p>View （识图）： 是应用程序中数据显示和渲染展示</p><p>Controller (控制器)： 控制器作用于模型和视图上，它可以把我们在Model模型上面获取到的数据显示到View识图上面，也可以把View传递的数据流向到模型对象，它使视图与模型分离开</p><p>Beego 中的控制器</p><p>beego 中的控制器本质上是一个结构体，这个结构体里买呢内嵌了beego.Controller，这样的话我们自定义的控制器就继承了beego.controller,继承以后自动拥有了所有beego.controller里面的属性和方法</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go http标准库</title>
    <link href="/2020/12/13/Go-http%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/2020/12/13/Go-http%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>待完成</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go interface接口</title>
    <link href="/2020/12/13/Go-interface%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/12/13/Go-interface%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-接口的介绍"><a href="#1-接口的介绍" class="headerlink" title="1 接口的介绍"></a>1 接口的介绍</h2><h3 id="1-1-现实生活中的接口"><a href="#1-1-现实生活中的接口" class="headerlink" title="1.1 现实生活中的接口"></a>1.1 现实生活中的接口</h3><p>比如手机电脑相机，都是可以通过接口来进行连接的，我们不需要关注卡槽的大小，因为所有的usb接口都是按照统一的标准来设计的</p><h3 id="1-2-Golang的接口"><a href="#1-2-Golang的接口" class="headerlink" title="1.2 Golang的接口"></a>1.2 Golang的接口</h3><p>在Golang中<code>接口（interface）</code>是一种类型，一种抽象的类型，接口是一组函数method的结合，Golang中的接口不能包含任何变量，可以认为它是一种定义接口的规范。</p><h3 id="1-3-Goalng-接口的定义"><a href="#1-3-Goalng-接口的定义" class="headerlink" title="1.3 Goalng 接口的定义"></a>1.3 Goalng 接口的定义</h3><p>在Golang中接口中的所有方法都没有方法体，接口定义了一个对象的行为规范，只是定义规范不实现，接口体现了程序设计的多态和高内聚低耦合的思想</p><p>Gloang中的接口也是一种数据类型，不需要显示实现，只需要一个变量含有接口类型的所有方法，那么这个变量就是实现了这个接口</p><p>Golang中每个接口由数个方法组成，接口的定义格式如下： </p><pre><code class="hljs go"><span class="hljs-keyword">type</span> 接口名字 <span class="hljs-keyword">interface</span> &#123;方法名字<span class="hljs-number">1</span>(参数列表<span class="hljs-number">1</span>)  返回值列表<span class="hljs-number">1</span>方法名字<span class="hljs-number">2</span>(参数列表<span class="hljs-number">2</span>)  返回值列表<span class="hljs-number">2</span>...&#125;</code></pre><ul><li>接口名字： 使用type 关键字将接口定义为自定义的类型名， Go语言的接口在命名的时候，一般会在单词后面添加er，如写操作的接口叫做Writer，有字符串功能的接口叫Stinger等，接口名字最好可以见名知意</li><li>方法名字： 当方法名字首字母大写且接口类型首字母大写的时候，可以被接口所在的包之外的代码访问</li><li>参数列表，返回值列表： 这个是可以省略的，跟函数的是一样的。</li></ul><h3 id="1-4-接口的使用"><a href="#1-4-接口的使用" class="headerlink" title="1.4 接口的使用"></a>1.4 接口的使用</h3><p>代码演示</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Usber <span class="hljs-keyword">interface</span> &#123;start()stop()&#125;<span class="hljs-keyword">type</span> iphone <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> camera <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">//iphone 结构体实现 Usber接口的俩个方法 一个start 一个stop</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 插入usb 成功\n&quot;</span>, i.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone)</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 拔出usb 成功\n&quot;</span>, i.name)&#125;<span class="hljs-comment">//camera 结构体实现 Usber接口的俩个方法 一个start 一个stop</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c camera)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 插入usb 成功\n&quot;</span>, c.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c camera)</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 拔出usb 成功\n&quot;</span>, c.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i1 = iphone&#123;name: <span class="hljs-string">&quot;xiaomi&quot;</span>,&#125;<span class="hljs-keyword">var</span> c1 = camera&#123;name: <span class="hljs-string">&quot;canon&quot;</span>,&#125;<span class="hljs-keyword">var</span> u1 Usberu1 = i1u1.start()u1.stop()<span class="hljs-keyword">var</span> u2 Usberu2 = c1u2.start()u2.stop()&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">xiaomi 插入usb 成功</span><span class="hljs-comment">xiaomi 拔出usb 成功</span><span class="hljs-comment"></span><span class="hljs-comment">canon 插入usb 成功</span><span class="hljs-comment">canon 拔出usb 成功</span><span class="hljs-comment">*/</span></code></pre><p>通过电脑空结构体实现调用接口方法</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Usber1 <span class="hljs-keyword">interface</span> &#123;start()stop()&#125;<span class="hljs-keyword">type</span> computer <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-keyword">type</span> iphone <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> camera <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(com computer)</span> <span class="hljs-title">worker</span><span class="hljs-params">(usb Usber1)</span></span> &#123;usb.start()usb.stop()&#125;<span class="hljs-comment">//iphone 结构体实现 Usber接口的俩个方法 一个start 一个stop</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 插入电脑usb 成功\n&quot;</span>, i.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone)</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 拔出电脑usb 成功\n&quot;</span>, i.name)&#125;<span class="hljs-comment">//camera 结构体实现 Usber接口的俩个方法 一个start 一个stop</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c camera)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 插入电脑usb 成功\n&quot;</span>, c.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c camera)</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 拔出电脑usb 成功\n&quot;</span>, c.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i1 = iphone&#123;name: <span class="hljs-string">&quot;ihpone12&quot;</span>,&#125;<span class="hljs-keyword">var</span> c1 = camera&#123;name: <span class="hljs-string">&quot;sony 50D&quot;</span>,&#125;<span class="hljs-keyword">var</span> com1 computer<span class="hljs-keyword">var</span> inter1 Usber1 = i1<span class="hljs-keyword">var</span> inter2 Usber1 = c1com1.worker(inter1)com1.worker(inter2)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">ihpone12 插入电脑usb 成功</span><span class="hljs-comment">ihpone12 拔出电脑usb 成功</span><span class="hljs-comment"></span><span class="hljs-comment">sony 50D 插入电脑usb 成功</span><span class="hljs-comment">sony 50D 拔出电脑usb 成功</span><span class="hljs-comment">*/</span></code></pre><h2 id="2-空接口介绍"><a href="#2-空接口介绍" class="headerlink" title="2 空接口介绍"></a>2 空接口介绍</h2><p>golang中的空接口，可以通过接口方式定义，也可以直接当做类型来使用，可以表示任意数据类型</p><h3 id="2-1-通过接口的方式定义"><a href="#2-1-通过接口的方式定义" class="headerlink" title="2.1 通过接口的方式定义"></a>2.1 通过接口的方式定义</h3><pre><code class="hljs go"><span class="hljs-keyword">type</span> Aer <span class="hljs-keyword">interface</span>&#123;&#125;  <span class="hljs-comment">//表示一个空接口</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-keyword">var</span> A1 AerA1  := strfmt.Printf(<span class="hljs-string">&quot;值：%v 类型： %T&quot;</span>,A1,A1) <span class="hljs-comment">//值：hello 类型： string</span></code></pre><h3 id="2-2-直接通过类型来定义"><a href="#2-2-直接通过类型来定义" class="headerlink" title="2.2 直接通过类型来定义"></a>2.2 直接通过类型来定义</h3><pre><code class="hljs go"><span class="hljs-keyword">var</span> a  <span class="hljs-keyword">interface</span>&#123;&#125;a = <span class="hljs-number">20</span> fmt.Printf(<span class="hljs-string">&quot;值：%v 类型： %T&quot;</span>,a,a)a = <span class="hljs-string">&quot;你好&quot;</span>fmt.Printf(<span class="hljs-string">&quot;值：%v 类型： %T&quot;</span>,a,a)a = <span class="hljs-literal">true</span>fmt.Printf(<span class="hljs-string">&quot;值：%v 类型： %T&quot;</span>,a,a)</code></pre><h2 id="3-空接口的使用"><a href="#3-空接口的使用" class="headerlink" title="3 空接口的使用"></a>3 空接口的使用</h2><h3 id="3-1-空接口作为函数的使用"><a href="#3-1-空接口作为函数的使用" class="headerlink" title="3.1 空接口作为函数的使用"></a>3.1 空接口作为函数的使用</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;值：%v 类型： %T&quot;</span>, a, a)&#125;</code></pre><h3 id="3-2-map的值实现空接口"><a href="#3-2-map的值实现空接口" class="headerlink" title="3.2 map的值实现空接口"></a>3.2 map的值实现空接口</h3><p>这样我们map类型的值，就可以是接收任意值（不像以前必须是定义死的，比如string）</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> UserInfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)UserInfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span>UserInfo[<span class="hljs-string">&quot;married&quot;</span>] = <span class="hljs-literal">false</span>UserInfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span></code></pre><h3 id="3-3-切片实现空接口"><a href="#3-3-切片实现空接口" class="headerlink" title="3.3  切片实现空接口"></a>3.3  切片实现空接口</h3><p>切片同理也可以接收任意类型</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice = []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">true</span>&#125;</code></pre><h2 id="4-类型断言"><a href="#4-类型断言" class="headerlink" title="4 类型断言"></a>4 类型断言</h2><p>一个接口的值（接口值） 是由一个具体类型和具体类型的值俩部分组成，这俩个部分分别称为接口的动态类型和动态值</p><p>如果我们想要判断空接口中值的类型到底是什么类型 ，这个时候我们就要使用类型断言</p><pre><code class="hljs go">x(T)</code></pre><ul><li>x: 表示类型为interface{}的变量</li><li>T：表示断言x 可能是的类型</li></ul><p>该语法返回俩个值，第一个参数是x转化为T类型后的变量，第二值是一个布尔值 ，返回true表示断言成功，否则失败</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//第一种方法通过i.(T)实现</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">if</span> _, ok := i.(<span class="hljs-keyword">string</span>); ok &#123;fmt.Printf(<span class="hljs-string">&quot;%v是%T\n&quot;</span>, i, i)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := i.(<span class="hljs-keyword">int</span>); ok &#123;fmt.Printf(<span class="hljs-string">&quot;%v是%T\n&quot;</span>, i, i)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := i.(<span class="hljs-keyword">bool</span>); ok &#123;fmt.Printf(<span class="hljs-string">&quot;%v是%T\n&quot;</span>, i, i)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;断言失败&quot;</span>)&#125;&#125;<span class="hljs-comment">//第二种方法通过i.(type) 只能结合switch 使用 </span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyPrint2</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">switch</span> i.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:fmt.Printf(<span class="hljs-string">&quot;%v是%T\n&quot;</span>, i, i)<span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:fmt.Printf(<span class="hljs-string">&quot;%v是%T\n&quot;</span>, i, i)<span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:fmt.Printf(<span class="hljs-string">&quot;%v是%T\n&quot;</span>, i, i)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;对不起,我不认识&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;bds&quot;</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> c <span class="hljs-keyword">bool</span> = <span class="hljs-literal">true</span>MyPrint(a)MyPrint(b)MyPrint(c)<span class="hljs-keyword">var</span> d = <span class="hljs-number">12.23</span>MyPrint2(a)MyPrint2(b)MyPrint2(c)MyPrint2(d)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">bds是string</span><span class="hljs-comment">10是int</span><span class="hljs-comment">true是bool</span><span class="hljs-comment"></span><span class="hljs-comment">bds是string</span><span class="hljs-comment">10是int</span><span class="hljs-comment">true是bool</span><span class="hljs-comment">对不起,我不认识</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre><p>上面我们通过电脑调用接口方法我们可以来通过断言判断, 比如是如果手机结构体 值调用start 方法。</p><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(com computer)</span> <span class="hljs-title">worker</span><span class="hljs-params">(usb Usber1)</span></span> &#123;<span class="hljs-keyword">if</span> _, ok := usb.(iphone); ok &#123;usb.start()&#125; <span class="hljs-keyword">else</span> &#123;usb.stop()&#125;&#125;</code></pre><h2 id="5-结构体-值和指针-接收者的区别"><a href="#5-结构体-值和指针-接收者的区别" class="headerlink" title="5 结构体 值和指针 接收者的区别"></a>5 结构体 值和指针 接收者的区别</h2><h3 id="5-1-值接收者"><a href="#5-1-值接收者" class="headerlink" title="5.1 值接收者"></a>5.1 值接收者</h3><p>实例化后的结构体 <code>值类型</code> 和<code>指针类型</code>都可以赋值给 接口变量</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Usber3 <span class="hljs-keyword">interface</span> &#123;start()stop()&#125;<span class="hljs-keyword">type</span> iphone1 <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">//值类型接收传入参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone1)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v start\n&quot;</span>, i.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone1)</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v stop&quot;</span>, i.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> tel1 = iphone1&#123;name: <span class="hljs-string">&quot;xiaomi&quot;</span>,&#125;<span class="hljs-keyword">var</span> u1 Usber3 = tel1u1.start()<span class="hljs-comment">//定义指针变量传入  </span><span class="hljs-keyword">var</span> tel2 = &amp;iphone1&#123; name: <span class="hljs-string">&quot;oneplus&quot;</span>,&#125;<span class="hljs-keyword">var</span> u2 Usber3 = tel2u2.start()&#125;</code></pre><h3 id="5-2-指针接收者"><a href="#5-2-指针接收者" class="headerlink" title="5.2 指针接收者"></a>5.2 指针接收者</h3><p>只能接收指针类型的 </p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Usber3 <span class="hljs-keyword">interface</span> &#123;start()stop()&#125;<span class="hljs-keyword">type</span> iphone1 <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">//值类型接收传入参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i iphone1)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v start\n&quot;</span>, i.name)&#125;<span class="hljs-comment">//这里改成指针类型接收传入参数，发现tel1 值类型的传入编译报错 。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *iphone1)</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v stop&quot;</span>, i.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//var tel1 = iphone1&#123;</span><span class="hljs-comment">//name: &quot;xiaomi&quot;,</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//var u1 Usber3 = tel1</span><span class="hljs-comment">//u1.start()  //报错： iphone1 does not implement Usber3 (stop method has pointer receiver)</span><span class="hljs-comment">//定义指针变量传入 这个依然正常。不会报错</span><span class="hljs-keyword">var</span> tel2 = &amp;iphone1&#123;name: <span class="hljs-string">&quot;oneplus&quot;</span>,&#125;<span class="hljs-keyword">var</span> u2 Usber3 = tel2u2.start()u2.stop()  <span class="hljs-comment">//正常调用stop 方法</span>&#125;</code></pre><h3 id="5-3-实现一个组合接收者类型"><a href="#5-3-实现一个组合接收者类型" class="headerlink" title="5.3 实现一个组合接收者类型"></a>5.3 实现一个组合接收者类型</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Animaler <span class="hljs-keyword">interface</span> &#123;GetName() <span class="hljs-keyword">string</span>SetName(<span class="hljs-keyword">string</span>)&#125;<span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> d.Name&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span> <span class="hljs-title">SetName</span><span class="hljs-params">(n <span class="hljs-keyword">string</span>)</span></span> &#123;d.Name = n&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;d1 := &amp;Dog&#123;Name: <span class="hljs-string">&quot;兰博基尼狗&quot;</span>,&#125;<span class="hljs-keyword">var</span> a1 Animaler = d1fmt.Println(a1.GetName())a1.SetName(<span class="hljs-string">&quot;玛莎拉蒂狗&quot;</span>)fmt.Println(a1.GetName())&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">兰博基尼狗</span><span class="hljs-comment">玛莎拉蒂狗</span><span class="hljs-comment">*/</span></code></pre><h2 id="6-一个结构体实现多个接口"><a href="#6-一个结构体实现多个接口" class="headerlink" title="6  一个结构体实现多个接口"></a>6  一个结构体实现多个接口</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> zoo1 <span class="hljs-keyword">interface</span> &#123;getname()&#125;<span class="hljs-keyword">type</span> zoo2 <span class="hljs-keyword">interface</span> &#123;setname(<span class="hljs-keyword">string</span>)&#125;<span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span> <span class="hljs-title">getname</span><span class="hljs-params">()</span></span> &#123;fmt.Println(c.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">setname</span><span class="hljs-params">(n <span class="hljs-keyword">string</span>)</span></span> &#123;c.name = n&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c = &amp;Cat&#123;name: <span class="hljs-string">&quot;小花猫&quot;</span>,&#125;<span class="hljs-keyword">var</span> z1 = cz1.getname()z1.setname(<span class="hljs-string">&quot;小红猫&quot;</span>)z1.getname()&#125;</code></pre><h2 id="7-接口的嵌套"><a href="#7-接口的嵌套" class="headerlink" title="7 接口的嵌套"></a>7 接口的嵌套</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> blue <span class="hljs-keyword">interface</span> &#123;getMode()&#125;<span class="hljs-keyword">type</span> fuyin <span class="hljs-keyword">interface</span> &#123;getColor()&#125;<span class="hljs-comment">//直接嵌套上面俩个接口</span><span class="hljs-keyword">type</span> kq <span class="hljs-keyword">interface</span> &#123;bluefuyin&#125;<span class="hljs-keyword">type</span> qin <span class="hljs-keyword">struct</span> &#123;name  <span class="hljs-keyword">string</span>mode  <span class="hljs-keyword">string</span>color <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q qin)</span> <span class="hljs-title">getMode</span><span class="hljs-params">()</span></span> &#123;fmt.Println(q.mode)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q qin)</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span></span> &#123;fmt.Println(q.color)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> q1 = qin&#123;name:  <span class="hljs-string">&quot;honner&quot;</span>,mode:  <span class="hljs-string">&quot;blues&quot;</span>,color: <span class="hljs-string">&quot;red&quot;</span>,&#125;<span class="hljs-keyword">var</span> k1 kq = q1k1.getMode()k1.getColor()&#125;</code></pre><h2 id="8-空接口针对-切片-结构体类型的取值"><a href="#8-空接口针对-切片-结构体类型的取值" class="headerlink" title="8 空接口针对 切片 结构体类型的取值"></a>8 空接口针对 切片 结构体类型的取值</h2><p>上面空接口会返回动态类型和动态值，这个时候取值是失败的，所以要通过断言的方式判断值到底是什么类型。然后针对类型的使用方法 进行取值</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Addr <span class="hljs-keyword">struct</span> &#123;address <span class="hljs-keyword">string</span>iphone  <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> user1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)user1[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span>user1[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span>user1[<span class="hljs-string">&quot;hobby&quot;</span>] = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;games&quot;</span>, <span class="hljs-string">&quot;睡觉&quot;</span>&#125;<span class="hljs-comment">//切片类型</span><span class="hljs-keyword">if</span> hobbyValue, ok := user1[<span class="hljs-string">&quot;hobby&quot;</span>].([]<span class="hljs-keyword">string</span>); ok &#123;fmt.Println(hobbyValue[<span class="hljs-number">1</span>])    <span class="hljs-comment">//睡觉</span>&#125;  <span class="hljs-comment">//切片类型</span>user1[<span class="hljs-string">&quot;sw&quot;</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)swValue, _ := user1[<span class="hljs-string">&quot;sw&quot;</span>].([]<span class="hljs-keyword">string</span>)swValue[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;180&quot;</span>swValue[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;120&quot;</span><span class="hljs-comment">//结构体类型</span>fmt.Println(user1[<span class="hljs-string">&quot;sw&quot;</span>]) <span class="hljs-comment">//[180 120 ]</span><span class="hljs-keyword">var</span> addr1 = Addr&#123;address: <span class="hljs-string">&quot;bj&quot;</span>,iphone:  <span class="hljs-string">&quot;13310011&quot;</span>,&#125;user1[<span class="hljs-string">&quot;addr&quot;</span>] = addr1addrValue, _ := user1[<span class="hljs-string">&quot;addr&quot;</span>].(Addr)fmt.Println(addrValue.iphone) <span class="hljs-comment">//13310011</span>fmt.Println(addrValue.address) <span class="hljs-comment">//bj</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络网卡介绍</title>
    <link href="/2020/12/13/%E7%BD%91%E7%BB%9C%E7%BD%91%E5%8D%A1/"/>
    <url>/2020/12/13/%E7%BD%91%E7%BB%9C%E7%BD%91%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<p>集成网桥</p><p>br-int: 是有openSwitch虚拟出来的网桥，充当一个虚拟交换机 </p><p>作用: 把它所在的计算节点上的VM都连接到它这个虚拟交换机上面，然后利用下面要介绍的br-tun的穿透功能，实现不同计算节点上的VM连接再同一个逻辑上的虚拟交换机上面的功能</p><p>patch-tun<br>作用： br-int 通过这个接口patch-tun 来连接br-tun 的</p><p>通道网桥</p><p>br-tun: 是openvSwitch 虚拟化出来的网桥，充当一个通道层</p><p>qr: 用于连接租户网络(租户内部ip地址)</p><p>qg: 设备用于连接外部网络(t通过floating IP连接)</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go struct结构体</title>
    <link href="/2020/12/11/Go-struct%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2020/12/11/Go-struct%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>Golang中没有类的概念，Golang中的结构体和其他语言中的类有点类似，和他语言的面向对象相比，Golang语言的结构体具有更高灵活性和扩展性</p><p>Golang中基础数据类型表示一些事物的基本属性，但是当我们想表达一个事物的全部或者部分的属性时候，这时候在用单一的数据类型就无法满足需求了，Golang提供了一种自定义数据类型，可以封装多个基本数据类型， 这种数据类型叫做结构体，英文名称 <code>strcut</code>, 也就是我们可以通过<code>struct</code>来定义自己的类型了</p><h2 id="1-结构体是值类型"><a href="#1-结构体是值类型" class="headerlink" title="1 结构体是值类型"></a>1 结构体是值类型</h2><p><strong>结构体首字母可以大写也可以小写，大写表示这个结构体（包括结构体里面的字段名称也是一样的）是共有的，其他包可以调用，小写是不可以，只可以内部函数自己使用</strong></p><h2 id="2-Golang中-type关键词"><a href="#2-Golang中-type关键词" class="headerlink" title="2 Golang中 type关键词"></a>2 Golang中 type关键词</h2><p>Golang中通过type关键词定义一个结构体，type可以自定义类型和类型别名</p><p>2.1 自定义类型</p><p>在go语言中有一些基本的数据类型，如string 整形，浮点型，布尔等类型，Go语言中可以使用type关键字来定义自定义类型。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span></code></pre><p>上面代码表示： 将myInt 定义为int类型，通过type关键词字的定义。myInt就是一种新的类型，它具有int的特性</p><p>2.2 类型别名</p><p>类型别名规定： TypeAlias 只是Type的别名，本质上TypeAlias与Type是同一个类型  </p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span>               <span class="hljs-comment">//自定义int类型</span><span class="hljs-keyword">type</span> myFn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span> //自定义方法类型</span><span class="hljs-keyword">type</span> myFloat = <span class="hljs-keyword">float64</span>       <span class="hljs-comment">//类型别名 ： 从打印结果可以看到，类型别名打印的还是底层的类型</span><span class="hljs-keyword">var</span> a myInt = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b myFloat = <span class="hljs-number">10.1</span>fmt.Printf(<span class="hljs-string">&quot;a类型： %T\n&quot;</span>, a) <span class="hljs-comment">//打印结果 a类型： main.myInt</span>fmt.Printf(<span class="hljs-string">&quot;b类型： %T\n&quot;</span>, b) <span class="hljs-comment">//打印结果：b类型： float64</span>&#125;</code></pre><h2 id="3-结构体定义和初始化"><a href="#3-结构体定义和初始化" class="headerlink" title="3 结构体定义和初始化"></a>3 结构体定义和初始化</h2><h3 id="3-1-结构体的定义"><a href="#3-1-结构体的定义" class="headerlink" title="3.1 结构体的定义"></a>3.1 结构体的定义</h3><pre><code class="hljs go"><span class="hljs-keyword">type</span> 累姓名 <span class="hljs-keyword">struct</span> &#123;  字段 字段类型  字段 字段类型  ...&#125;</code></pre><h3 id="3-2-结构体实例化"><a href="#3-2-结构体实例化" class="headerlink" title="3.2 结构体实例化"></a>3.2 结构体实例化</h3><p>初始化结构体的七种方法</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>age  <span class="hljs-keyword">int</span>sex  <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> p1 Personp1.name = <span class="hljs-string">&quot;bds&quot;</span>p1.sex = <span class="hljs-string">&quot;nan&quot;</span>p1.age = <span class="hljs-number">20</span>fmt.Printf(<span class="hljs-string">&quot;p1: %v 类型：  %T\n&quot;</span>, p1, p1) <span class="hljs-comment">//value: &#123;bds 20 nan&#125; 类型：  main.Person</span>fmt.Printf(<span class="hljs-string">&quot;p1: %#v 类型： %T\n&quot;</span>, p1, p1) <span class="hljs-comment">//value: main.Person&#123;name:&quot;bds&quot;, age:20, sex:&quot;nan&quot;&#125; 类型：main.Person</span><span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">new</span>(Person)p2.name = <span class="hljs-string">&quot;bds2&quot;</span>p2.sex = <span class="hljs-string">&quot;nan&quot;</span>p2.age = <span class="hljs-number">22</span>fmt.Printf(<span class="hljs-string">&quot;p2值：%#v，类型：%T\n&quot;</span>, p2, p2)<span class="hljs-keyword">var</span> p3 = &amp;Person&#123;&#125;p3.name = <span class="hljs-string">&quot;bds3&quot;</span>p3.sex = <span class="hljs-string">&quot;nan&quot;</span>p3.age = <span class="hljs-number">23</span>fmt.Printf(<span class="hljs-string">&quot;p3值：%#v，类型：%T\n&quot;</span>, p3, p3)<span class="hljs-keyword">var</span> p4 = Person&#123;name: <span class="hljs-string">&quot;bds4&quot;</span>,sex:  <span class="hljs-string">&quot;nan&quot;</span>,age:  <span class="hljs-number">24</span>,&#125;fmt.Printf(<span class="hljs-string">&quot;p4值：%#v，类型：%T\n&quot;</span>, p4, p4)<span class="hljs-keyword">var</span> p5 = &amp;Person&#123;name: <span class="hljs-string">&quot;bds5&quot;</span>,age:  <span class="hljs-number">25</span>,sex:  <span class="hljs-string">&quot;nan&quot;</span>,&#125;fmt.Printf(<span class="hljs-string">&quot;p5值：%#v，类型：%T\n&quot;</span>, p5, p5)<span class="hljs-keyword">var</span> p6 = &amp;Person&#123;name: <span class="hljs-string">&quot;bds6&quot;</span>,&#125;fmt.Printf(<span class="hljs-string">&quot;p6值：%#v，类型：%T\n&quot;</span>, p6, p6)<span class="hljs-keyword">var</span> p7 = &amp;Person&#123;<span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&quot;男&quot;</span>,&#125;fmt.Printf(<span class="hljs-string">&quot;p7值：%#v，类型：%T\n&quot;</span>, p7, p7)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">p1: &#123;bds 20 nan&#125; 类型：  main.Person</span><span class="hljs-comment">p1: main.Person&#123;name:&quot;bds&quot;, age:20, sex:&quot;nan&quot;&#125; 类型： main.Person</span><span class="hljs-comment">p2值：&amp;main.Person&#123;name:&quot;bds2&quot;, age:22, sex:&quot;nan&quot;&#125;，类型：*main.Person</span><span class="hljs-comment">p3值：&amp;main.Person&#123;name:&quot;bds3&quot;, age:23, sex:&quot;nan&quot;&#125;，类型：*main.Person</span><span class="hljs-comment">p4值：main.Person&#123;name:&quot;bds4&quot;, age:24, sex:&quot;nan&quot;&#125;，类型：main.Person</span><span class="hljs-comment">p5值：&amp;main.Person&#123;name:&quot;bds5&quot;, age:25, sex:&quot;nan&quot;&#125;，类型：*main.Person</span><span class="hljs-comment">p6值：&amp;main.Person&#123;name:&quot;bds6&quot;, age:0, sex:&quot;&quot;&#125;，类型：*main.Person</span><span class="hljs-comment">p7值：&amp;main.Person&#123;name:&quot;bds&quot;, age:21, sex:&quot;男&quot;&#125;，类型：*main.Person</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre><h2 id="4-结构体方法和继承者"><a href="#4-结构体方法和继承者" class="headerlink" title="4 结构体方法和继承者"></a>4 结构体方法和继承者</h2><p>在Go语言中，没有类的概念，但是可以给结构体定义方法，就是定义了一个接受者函数，接收者的概念就类似于其他语言中的this 或者self </p><p>方法如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(接收者变量 接受者类型） 方法名字(参数列表)</span> <span class="hljs-params">(返回参数） &#123;</span></span><span class="hljs-function"><span class="hljs-params">函数体</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span></span></code></pre><ul><li><p>接受者变量： 接受者中的参数变量名字在命名时候，官方建议使用接收者类型名字的第一个小写字母，而不是self，this之类的名字，例如Person类型的接收者变量名字应该为p </p></li><li><p>接受者类型： 接收者类型和参数类似，可以是指针类型和非指针类型</p></li><li><p>方法名，参数列表，返回参数 具体格式与函数定义相同</p></li></ul><p>例子： 给结构体Persion 定义一个打印Pricntinfo方法和SetInfo方法</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;Name   <span class="hljs-keyword">string</span>Age    <span class="hljs-keyword">int</span>worker <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">Pringinfo</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;姓名：%v,年龄：%v\n&quot;</span>, p.Name, p.Age)&#125;<span class="hljs-comment">// 因为传入的是指针变量，所以这里修改值，会直接影响原来的结构体里面的值。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">SetInfo</span><span class="hljs-params">()</span></span> &#123;   p.Name = <span class="hljs-string">&quot;fanbu&quot;</span>p.Age = <span class="hljs-number">1</span>p.worker = <span class="hljs-string">&quot;golang&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> p1 = Person&#123;Name:   <span class="hljs-string">&quot;bds1&quot;</span>,Age:    <span class="hljs-number">21</span>,worker: <span class="hljs-string">&quot;linux&quot;</span>,&#125;p1.Pringinfo()p1.SetInfo()p1.Pringinfo()&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">姓名：bds1,年龄：21</span><span class="hljs-comment">姓名：fanbu,年龄：1</span><span class="hljs-comment">*/</span></code></pre><h2 id="5-给自定义类型添加方法"><a href="#5-给自定义类型添加方法" class="headerlink" title="5 给自定义类型添加方法"></a>5 给自定义类型添加方法</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span>   <span class="hljs-comment">//比如我们也可以给myInt 定义方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myInt)</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;我是myInt 自定义方法&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a myInt = <span class="hljs-number">10</span>a.Print()&#125;</code></pre><h2 id="6-结构体的匿名字段和其他类型使用"><a href="#6-结构体的匿名字段和其他类型使用" class="headerlink" title="6 结构体的匿名字段和其他类型使用"></a>6 结构体的匿名字段和其他类型使用</h2><p>结构体允许其成员没有字段名字而只有类型。这种没有名字的字段就成为匿名字段，匿名字段名字必须有唯一性，所以如果一个结构体里面有同样类型的时，就会报错。</p><h3 id="6-1-使用其他数据类型"><a href="#6-1-使用其他数据类型" class="headerlink" title="6.1 使用其他数据类型"></a>6.1 使用其他数据类型</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">/*</span><span class="hljs-comment">结构体字段类型可以是 基本数据类型 ，也可以是 切片， Map 以及 结构体</span><span class="hljs-comment">如果结构体的字段类型是： 指针 slice ，map的零值都是nil 即还没有分配内存空间</span><span class="hljs-comment">如果需要使用这样的字段： 需要先make ，才能使用</span><span class="hljs-comment">*/</span><span class="hljs-keyword">type</span> Person1 <span class="hljs-keyword">struct</span> &#123;Name  <span class="hljs-keyword">string</span>hobby []<span class="hljs-keyword">string</span>map1  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> p1 Person1p1.Name = <span class="hljs-string">&quot;bds&quot;</span>p1.hobby = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)p1.hobby[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;sleep&quot;</span>p1.hobby[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;moving&quot;</span>p1.map1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)p1.map1[<span class="hljs-string">&quot;phone&quot;</span>] = <span class="hljs-string">&quot;1333123123&quot;</span>p1.map1[<span class="hljs-string">&quot;addr&quot;</span>] = <span class="hljs-string">&quot;BeiJing&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%#v&quot;</span>, p1)&#125;<span class="hljs-comment">//main.Person1&#123;Name:&quot;bds&quot;, hobby:[]string&#123;&quot;sleep&quot;, &quot;moving&quot;, &quot;&quot;, &quot;&quot;&#125;, map1:map[string]string&#123;&quot;addr&quot;:&quot;BeiJing&quot;, &quot;phone&quot;:&quot;1333123123&quot;&#125;&#125;</span></code></pre><h3 id="6-2-结构体嵌套"><a href="#6-2-结构体嵌套" class="headerlink" title="6.2 结构体嵌套"></a>6.2 结构体嵌套</h3><p>有名字的嵌套</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person1 <span class="hljs-keyword">struct</span> &#123;Name  <span class="hljs-keyword">string</span>hobby []<span class="hljs-keyword">string</span>map1  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>Body  BodyInfo&#125;<span class="hljs-keyword">type</span> BodyInfo <span class="hljs-keyword">struct</span> &#123;weight <span class="hljs-keyword">string</span>age    <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-keyword">var</span> p2 Person1p2.Name = <span class="hljs-string">&quot;bds1&quot;</span>p2.Body.weight = <span class="hljs-string">&quot;180&quot;</span>   <span class="hljs-comment">//嵌套的结构体赋值通过 点. 操作</span>p2.Body.age = <span class="hljs-number">18</span>       fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, p2)  fmt.&#125;</code></pre><p>匿名嵌套</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person1 <span class="hljs-keyword">struct</span> &#123;Name  <span class="hljs-keyword">string</span>hobby []<span class="hljs-keyword">string</span>map1  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>BodyInfo                    <span class="hljs-comment">//匿名字段  Persion1结构体嵌套BodyInfo结构体</span>&#125;<span class="hljs-keyword">type</span> BodyInfo <span class="hljs-keyword">struct</span> &#123;weight <span class="hljs-keyword">string</span>age    <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-keyword">var</span> p2 Person1p2.Name = <span class="hljs-string">&quot;bds1&quot;</span>p2.BodyInfo.weight = <span class="hljs-string">&quot;180&quot;</span>p2.BodyInfo.age = <span class="hljs-number">18</span>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, p2)fmt.Println(p2.BodyInfo.age)  <span class="hljs-comment">//18 </span>  <span class="hljs-comment">// 如果是匿名字段嵌套，可以直接使用匿名字段里面的字段进行取值。</span>fmt.Println(p2.age)           <span class="hljs-comment">//18 也就是 先在当前结构体查找，找不到去结构体里面查找。然后取值。</span>&#125;</code></pre><h2 id="7-结构体的继承"><a href="#7-结构体的继承" class="headerlink" title="7 结构体的继承"></a>7 结构体的继承</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//父亲结构体</span><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">//儿子结构体 ，继承了父亲的结构体里面的属性和方法</span><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;color <span class="hljs-keyword">string</span>age   <span class="hljs-keyword">int</span>wang  <span class="hljs-keyword">string</span>Animal        <span class="hljs-comment">//其实就是通过嵌套来实现继承</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Animal)</span> <span class="hljs-title">do</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, a.Name)&#125;<span class="hljs-comment">// 继承父亲的 Name属性</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%v 在%v\n&quot;</span>, d.Name, d.wang)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s1 = Dog&#123;wang:  <span class="hljs-string">&quot;旺旺旺&quot;</span>,color: <span class="hljs-string">&quot;writer&quot;</span>,Animal: Animal&#123;Name: <span class="hljs-string">&quot;小花&quot;</span>,&#125;,&#125;fmt.Println(s1)  <span class="hljs-comment">//因为Dog 继承父亲。所以可以用父亲的do方法</span>s1.do()s1.run()&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">&#123;writer 0 旺旺旺 &#123;小花&#125;&#125;</span><span class="hljs-comment">小花 在运动园 </span><span class="hljs-comment">小花 旺旺旺</span><span class="hljs-comment">*/</span></code></pre><h2 id="8-结构体-json数据转换"><a href="#8-结构体-json数据转换" class="headerlink" title="8 结构体 json数据转换"></a>8 结构体 json数据转换</h2><p>比如我们Golang要给app或者小程序提供api接口数据，这个时候就需要涉及到结构体和json之间的相互转换</p><p>Golang Json序列化是指： 把结构体数据转化为json格式的字符串，Golang json的反序列化是指把json数据转为Golang中的结构体对象</p><p>Golang中的序列化和反序列化主要通过encoding/json包中的json.Marshal()和json.Unmarshal()</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;Name  <span class="hljs-keyword">string</span>Age   <span class="hljs-keyword">int</span>class <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s = Stu&#123;Name:  <span class="hljs-string">&quot;bds1&quot;</span>,class: <span class="hljs-string">&quot;高中&quot;</span>,Age:   <span class="hljs-number">18</span>,&#125;fmt.Println(s)stuByte, err := json.Marshal(s)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)&#125; <span class="hljs-keyword">else</span> &#123;jsonStu := <span class="hljs-keyword">string</span>(stuByte)fmt.Println(jsonStu)     <span class="hljs-comment">//转换成字符串</span>&#125;&#125;</code></pre><p>Json 转换为 结构体</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-string">`&#123;&quot;Name&quot;:&quot;bds2&quot;,&quot;Age&quot;:19&#125;`</span><span class="hljs-keyword">var</span> stuJson = Stu&#123;&#125;err1 := json.Unmarshal([]<span class="hljs-keyword">byte</span>(b), &amp;stuJson)<span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;fmt.Println(err1)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(stuJson)fmt.Println(stuJson.Name) &#125;</code></pre><h2 id="9-结构体标签Tag"><a href="#9-结构体标签Tag" class="headerlink" title="9 结构体标签Tag"></a>9 结构体标签Tag</h2><p><code>Tag</code> 是结构体的<code>元信息</code>，可以在运行的时候通过<code>反射</code>的机制读取出来，Tag在结构体字段的后方定义，是一对<code>反引号</code>包裹起来的，具体格式如下： </p><pre><code class="hljs go"><span class="hljs-string">`key:&quot;value&quot; key2:&quot;value2&quot;`</span></code></pre><p>结构体tag是由一个或者多个键值对组成，键与值使用冒号分隔，值用双引号阔起来，同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分割</p><p><strong>注意： 不在key和value之间加上空格</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> stuf <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>  <span class="hljs-comment">//通过tag 来自定义转换成json格式后的key</span>Age  <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> student = stuf&#123;Name: <span class="hljs-string">&quot;bds1&quot;</span>,Age:  <span class="hljs-number">19</span>,&#125;jsonStudent, err := json.Marshal(student)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//通过定义tag标签 我们可以看到最后的json格式的key是 我们结构体中自定义的tag标签里面的key。</span>fmt.Println(<span class="hljs-keyword">string</span>(jsonStudent))   <span class="hljs-comment">//&#123;&quot;name&quot;:&quot;bds1&quot;,&quot;age&quot;:19&#125; </span>&#125;&#125;</code></pre><p>举一个稍微复杂的例子</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> class <span class="hljs-keyword">struct</span> &#123;Name     <span class="hljs-keyword">string</span>    <span class="hljs-string">`json:&quot;name&quot;`</span>Students []student <span class="hljs-string">`json:&quot;stu&quot;`</span>   <span class="hljs-comment">//切片结构体类型</span>&#125;<span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>Age  <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span>Addr <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;address&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c1 = class&#123;Name:     <span class="hljs-string">&quot;一年一班&quot;</span>,Students: <span class="hljs-built_in">make</span>([]student, <span class="hljs-number">0</span>),&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">var</span> stu = student&#123;Name: fmt.Sprintf(<span class="hljs-string">&quot;stu_%v&quot;</span>, i),Age:  <span class="hljs-number">18</span>,Addr: fmt.Sprint(<span class="hljs-string">&quot;Bj_1001&quot;</span>, i),&#125;c1.Students = <span class="hljs-built_in">append</span>(c1.Students, stu)&#125;fmt.Println(c1)JsonClass, err := json.Marshal(c1)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-keyword">string</span>(JsonClass))&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 指针</title>
    <link href="/2020/12/11/Go-%E6%8C%87%E9%92%88/"/>
    <url>/2020/12/11/Go-%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>我们通过变量来存储数据，起始变量的本质是给存储数据的内存地址起一个好的名字，比如我定义一个变量a:=10 这个时候可以直接通过a这个变量来读取内存中的10 这个值，但是在计算机底层a 这隔变量起始对应了一块内存地址</p><h2 id="1-指针"><a href="#1-指针" class="headerlink" title="1 指针"></a>1 指针</h2><p>指针是引用类型</p><p>它也是一个变量，但它是一个特殊的变量，他存储的数据不是一个普通值，而是另一个变量的内存地址</p><pre><code class="hljs go">普通变量 <span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span> 指针变量 <span class="hljs-keyword">var</span> p *<span class="hljs-keyword">int</span> = &amp;a</code></pre><h3 id="1-1-简单代码看一下效果"><a href="#1-1-简单代码看一下效果" class="headerlink" title="1.1 简单代码看一下效果"></a>1.1 简单代码看一下效果</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> p = &amp;afmt.Printf(<span class="hljs-string">&quot;a的值，%v，a的类型： %T，a的地址： %p\n&quot;</span>, a, a, &amp;a)fmt.Printf(<span class="hljs-string">&quot;p的值，%v，p的类型： %T，p的地址： %p&quot;</span>, p, p, &amp;p)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">a的值，10，a的类型： int，a的地址： 0xc0000b2008</span><span class="hljs-comment">p的值，0xc0000b2008，p的类型： *int，p的地址： 0xc0000ac018</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre><h3 id="1-3-通过指针改变值"><a href="#1-3-通过指针改变值" class="headerlink" title="1.3 通过指针改变值"></a>1.3 通过指针改变值</h3><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> p = &amp;afmt.Printf(<span class="hljs-string">&quot;a的值，%v，a的类型： %T，a的地址： %p\n&quot;</span>, a, a, &amp;a)fmt.Printf(<span class="hljs-string">&quot;p的值，%v，p的类型： %T，p的地址： %p\n&quot;</span>, p, p, &amp;p)fmt.Println(p)  <span class="hljs-comment">//a的内存地址</span>fmt.Println(*p) <span class="hljs-comment">//取出变量p对应的内存地址的值 也就是a内存地址存储的值</span>*p = <span class="hljs-number">30</span>fmt.Println(a) <span class="hljs-comment">//打印出30，因为*p 是可以修改值的</span>&#125;</code></pre><h2 id="2-new函数分配内存空间"><a href="#2-new函数分配内存空间" class="headerlink" title="2 new函数分配内存空间"></a>2 new函数分配内存空间</h2><p>new是一个内置的函数，他的函数含义如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span> *<span class="hljs-title">Type</span></span></code></pre><ul><li>Type 表示类型 new函数只是接受一个参数，这个参数是一个类型</li><li>*Type 表示类型指针，new函数返回一个指向该类型的内存地址的指针</li></ul><p><strong>实际开发中new函数不太常用</strong>，使用new函数得到的是一个类型的指针，并且该指针对应的值维该类型零值。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)fmt.Printf(<span class="hljs-string">&quot;值：%v，类型：%T，指针变量对应的值： %v&quot;</span>, b, b, &amp;b) <span class="hljs-comment">//值：0xc000096040，类型：*int，指针变量对应的值： 0xc00008c020</span><span class="hljs-keyword">var</span> c *<span class="hljs-keyword">int</span>c = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)</code></pre><h2 id="3-make-函数分配内存"><a href="#3-make-函数分配内存" class="headerlink" title="3 make 函数分配内存"></a>3 make 函数分配内存</h2><p>make 也是用于内存分配的，区别于new，它只用于slice，map以及channel的内存创建，而且他返回的类型就是这三个类型的本身，而不是他们的指针类型，因为这三中类型就是引用类型，所以就没有必要返回他们的指针了，make函数的函数名如下： </p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">(Type,size ...interType)</span> <span class="hljs-title">Type</span></span></code></pre><p>make 函数是无可取代的，我们在使用的slice和map以及channel的时候，都需要使用make 进行初始化，然后才可以对他们进行操作</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)userinfo[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span>fmt.Println(userinfo)<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>fmt.Println(a)</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go time包使用</title>
    <link href="/2020/12/09/Go-time%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/12/09/Go-time%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-time包使用"><a href="#1-time包使用" class="headerlink" title="1 time包使用"></a>1 time包使用</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;timeNow := time.Now()fmt.Println(timeNow)Year := timeNow.Year()Month := timeNow.Month()Day := timeNow.Day()Hour := timeNow.Hour()Minute := timeNow.Minute()Second := timeNow.Second()fmt.Printf(<span class="hljs-string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, Year, Month, Day, Hour, Minute, Second)<span class="hljs-comment">/*</span><span class="hljs-comment">   年：2006</span><span class="hljs-comment">   月：01</span><span class="hljs-comment">   日：02</span><span class="hljs-comment">   时：03    12小时  15： 24小时</span><span class="hljs-comment">   分：04</span><span class="hljs-comment">   秒：05</span><span class="hljs-comment">*/</span>timeNow1 := time.Now()<span class="hljs-keyword">var</span> str = timeNow1.Format(<span class="hljs-string">&quot;2006/01/02 03:04:05&quot;</span>)<span class="hljs-keyword">var</span> str1 = timeNow1.Format(<span class="hljs-string">&quot;2006/01/02 15:04:05&quot;</span>)fmt.Println(str)  <span class="hljs-comment">//2020/12/09 01:58:02</span>fmt.Println(str1) <span class="hljs-comment">//2020/12/09 13:58:02</span>&#125;</code></pre><h2 id="2-格式化转换"><a href="#2-格式化转换" class="headerlink" title="2 格式化转换"></a>2 格式化转换</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//获取时间戳</span>timeNow := time.Now()unixtime := timeNow.Unix()       <span class="hljs-comment">//获取当前毫秒时间戳</span>unixNatime := timeNow.UnixNano() <span class="hljs-comment">//获取当前纳秒时间戳</span>fmt.Println(unixtime, unixNatime)<span class="hljs-comment">//时间戳转换成日期</span>unixtime1 := <span class="hljs-number">1607493629</span>timeNow1 := time.Unix(<span class="hljs-keyword">int64</span>(unixtime1), <span class="hljs-number">0</span>) <span class="hljs-comment">//注意类型是int64</span><span class="hljs-keyword">var</span> str1 = timeNow1.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)fmt.Println(str1)<span class="hljs-comment">//日期字符串转换为时间戳</span><span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;2020-12-09 14:00:29&quot;</span><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>timeNow2, _ := time.ParseInLocation(tmp, str2, time.Local)fmt.Println(timeNow2)fmt.Println(timeNow2.Unix())&#125;</code></pre><h2 id="3-time定义时间间隔的常量"><a href="#3-time定义时间间隔的常量" class="headerlink" title="3 time定义时间间隔的常量"></a>3 time定义时间间隔的常量</h2><pre><code class="hljs go">time.Second <span class="hljs-comment">//1秒</span>time.Millisecond/ <span class="hljs-comment">//1毫秒</span></code></pre><h2 id="4-时间操作函数"><a href="#4-时间操作函数" class="headerlink" title="4 时间操作函数"></a>4 时间操作函数</h2><pre><code class="hljs go">AddSubEqualBefore After</code></pre><h2 id="5-定时器"><a href="#5-定时器" class="headerlink" title="5 定时器"></a>5 定时器</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//定时器 每隔一秒钟</span>ticker := time.NewTicker(time.Second)n := <span class="hljs-number">5</span><span class="hljs-comment">//ticker.C</span><span class="hljs-keyword">for</span> t := <span class="hljs-keyword">range</span> ticker.C &#123;n--fmt.Println(t)<span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;ticker.Stop()<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-comment">//第二种方法</span><span class="hljs-keyword">for</span> &#123;time.sleep(time.Second)fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go defer panic recover</title>
    <link href="/2020/12/09/Go-defer-panic-recover/"/>
    <url>/2020/12/09/Go-defer-panic-recover/</url>
    
    <content type="html"><![CDATA[<h2 id="1-defer-语句"><a href="#1-defer-语句" class="headerlink" title="1 defer 语句"></a>1 defer 语句</h2><p>Go 语言中的defer 语句会将其后面跟随的语句进行延迟处理，在defer语句的函数即将返回时候，将延迟处理的语句按照defer语句的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行</p><h3 id="1-1-defer-使用"><a href="#1-1-defer-使用" class="headerlink" title="1.1 defer 使用"></a>1.1 defer 使用</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;start&quot;</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">1</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">2</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">3</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-number">4</span>)fmt.Println(<span class="hljs-string">&quot;over&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">start</span><span class="hljs-comment">over</span><span class="hljs-comment">4</span><span class="hljs-comment">3</span><span class="hljs-comment">2</span><span class="hljs-comment">1</span><span class="hljs-comment">*/</span></code></pre><h3 id="1-2-defer-命名返回值和匿名返回值"><a href="#1-2-defer-命名返回值和匿名返回值" class="headerlink" title="1.2 defer 命名返回值和匿名返回值"></a>1.2 defer 命名返回值和匿名返回值</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//调用方法 返回的值是0 ： 匿名返回值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span>  <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;a++&#125;()<span class="hljs-keyword">return</span> a&#125;<span class="hljs-comment">//调用方法 返回的值是1 ： 命名返回值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;a++&#125;()<span class="hljs-keyword">return</span> a&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(f2())&#125;</code></pre><h3 id="1-3-defer-不太好理解的案例"><a href="#1-3-defer-不太好理解的案例" class="headerlink" title="1.3 defer 不太好理解的案例"></a>1.3 defer 不太好理解的案例</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(index <span class="hljs-keyword">string</span>,a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;   ret := a + b   fmt.Println(index,a,b,ret)   <span class="hljs-keyword">return</span> ret&#125;<span class="hljs-comment">//defer: defer在注册要延迟执行的函数时候， 该函数所有的参数都需要确定其值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   a := <span class="hljs-number">1</span>   b := <span class="hljs-number">2</span>   <span class="hljs-keyword">defer</span>  calc(<span class="hljs-string">&quot;addA&quot;</span>,a,calc(<span class="hljs-string">&quot;A&quot;</span>,a,b))   a = <span class="hljs-number">10</span>   <span class="hljs-keyword">defer</span>  calc(<span class="hljs-string">&quot;addB&quot;</span>,a,calc(<span class="hljs-string">&quot;B&quot;</span>,a,b))   b = <span class="hljs-number">20</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">注册顺序</span><span class="hljs-comment">   defer  calc(&quot;addA&quot;,a,calc(&quot;A&quot;,a,b))</span><span class="hljs-comment">   defer  calc(&quot;addB&quot;,a,calc(&quot;B&quot;,a,b))</span><span class="hljs-comment">执行顺序</span><span class="hljs-comment">   defer  calc(&quot;addB&quot;,a,calc(&quot;B&quot;,a,b))</span><span class="hljs-comment">   defer  calc(&quot;addA&quot;,a,calc(&quot;A&quot;,a,b))</span><span class="hljs-comment"> */</span><span class="hljs-comment">// 1. calc(&quot;A&quot;,a,b)  A 1 2 3</span><span class="hljs-comment">// 2. calc(&quot;B&quot;,a,b)  B 10 2 12</span><span class="hljs-comment">// 3. calc(&quot;addB&quot;,a,calc(&quot;B&quot;,a,b))  addB 10 12 22</span><span class="hljs-comment">// 4. calc(&quot;addA&quot;,a,calc(&quot;A&quot;,a,b))  addA 1 3 13   在addA之前定义了a:=1 所以函数参数已经注册生效</span></code></pre><h2 id="2-panic"><a href="#2-panic" class="headerlink" title="2 panic"></a>2 panic</h2><p>panic 可以在任何地方引发 但是recover 只有在defer 调用的函数中有效</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;f1&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;抛出一个异常&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fn1()fn2()   <span class="hljs-comment">//程序执行到这里抛出异常，然后程序退出，不在往下执行</span>fmt.Println(<span class="hljs-string">&quot;over...&quot;</span>)&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;f1&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;err := <span class="hljs-built_in">recover</span>()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;扑捉异常，输出错误，程序继续执行&quot;</span>)&#125;&#125;()<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;抛出一个异常&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fn1()fn2()   <span class="hljs-comment">//程序执行到这里抛出异常，然后程序退出，不在往下执行</span>fmt.Println(<span class="hljs-string">&quot;over...&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">f1</span><span class="hljs-comment">扑捉异常，输出错误，程序继续执行</span><span class="hljs-comment">over...</span><span class="hljs-comment">*/</span></code></pre><h2 id="3-recover"><a href="#3-recover" class="headerlink" title="3 recover"></a>3 recover</h2><p>recover 只有在defer 调用的函数中有效 </p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;err := <span class="hljs-built_in">recover</span>()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;error: &quot;</span>,err)&#125;&#125;()<span class="hljs-keyword">return</span> a/b   <span class="hljs-comment">//除数为0,不符合语法报错，但是不影响程序继续执行</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(fn1(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>))fmt.Println(<span class="hljs-string">&quot;over&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">error:  runtime error: integer divide by zero</span><span class="hljs-comment">0</span><span class="hljs-comment">over</span><span class="hljs-comment">*/</span></code></pre><h2 id="4-defer-panic-recover-结合使用"><a href="#4-defer-panic-recover-结合使用" class="headerlink" title="4  defer panic recover 结合使用"></a>4  defer panic recover 结合使用</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-comment">// error 也是一个数据类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> path == <span class="hljs-string">&quot;main.go&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;文件不存在&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFn</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;e := <span class="hljs-built_in">recover</span>()<span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;通知运维.文件不存在&quot;</span>)&#125;&#125;()funcErr := readFile(<span class="hljs-string">&quot;xxx.go&quot;</span>)<span class="hljs-keyword">if</span> funcErr != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(funcErr)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;myFn()fmt.Println(<span class="hljs-string">&quot;继续执行。。。&quot;</span>)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 函数</title>
    <link href="/2020/12/09/Go-%E5%87%BD%E6%95%B0/"/>
    <url>/2020/12/09/Go-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1 函数定义"></a>1 函数定义</h2><p>函数是组织好的，可重复使用的，用于执行指定任务的代码块，本文介绍go语言函数的相关内容</p><p>Go 语言支持： 函数 ，匿名函数，闭包</p><p>Go 语言中定义函数使用func 关键字 </p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">(函数参数）函数返回值 &#123;</span></span><span class="hljs-function"><span class="hljs-params">函数体</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span></span></code></pre><ul><li>函数名： 由 字母 数字 下划线组成 但是函数名的第一个字母不能是数字，在同一个包内，函数名称，不能重名</li><li>函数参数：参数由参数变量和参数变量的类型组成，多个参数可以使用逗号分隔</li><li>函数返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值，多个返回值必须用()包裹，并且用逗号，分隔</li><li>函数体： 实现指功能的代码块</li></ul><h2 id="2-函数使用案例"><a href="#2-函数使用案例" class="headerlink" title="2 函数使用案例"></a>2 函数使用案例</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumFunc</span><span class="hljs-params">(x <span class="hljs-keyword">int</span> ,y <span class="hljs-keyword">int</span>)</span>   <span class="hljs-title">int</span></span> &#123;sum := x + y<span class="hljs-keyword">return</span> sum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subFunc</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span> )</span> <span class="hljs-title">int</span></span> &#123;      <span class="hljs-comment">//当数据类型是相同的情况下， 可以最后只写一个</span>sub := x - y<span class="hljs-keyword">return</span> sub&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sum1 := sumFunc(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)fmt.Println(sum1)sub1 := subFunc(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)fmt.Println(sub1)&#125;</code></pre><h2 id="3-函数可变参数"><a href="#3-函数可变参数" class="headerlink" title="3 函数可变参数"></a>3 函数可变参数</h2><p>通常可变参数要写在最后一个参数,Go中使用在参数后面加… 来标识</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumFunc1</span><span class="hljs-params">(x ...<span class="hljs-keyword">int</span>)</span></span> &#123;         <span class="hljs-comment">//可变参数： 可以用三个点 ... 来接收多个值</span>fmt.Printf(<span class="hljs-string">&quot;%v,%T\n&quot;</span>,x,x)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumFunc2</span><span class="hljs-params">(x ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;     <span class="hljs-comment">//可变参数： 可以用三个点 ... 来接收多个值</span>sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> x &#123;sum += v&#125;<span class="hljs-keyword">return</span>  sum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>,y ...<span class="hljs-keyword">int</span> )</span>  <span class="hljs-title">int</span></span>  &#123;   <span class="hljs-comment">//传递可变长参数，可变长参数放在关键词后面</span>sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> y &#123;sum += v&#125;<span class="hljs-keyword">return</span> sum&#125;sumFunc1(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">35</span>,<span class="hljs-number">6</span>)sum2 := sumFunc2(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">99</span>)fmt.Println(sum2)  sumCalc1 := calc1(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">88</span>)fmt.Println(sumCalc1)</code></pre><h2 id="4-函数多个返回值"><a href="#4-函数多个返回值" class="headerlink" title="4 函数多个返回值"></a>4 函数多个返回值</h2><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span>  <span class="hljs-params">(<span class="hljs-keyword">int</span> ,<span class="hljs-keyword">int</span> )</span></span> &#123;sum := x + ysub := x - y<span class="hljs-keyword">return</span> sum,sub&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc1</span><span class="hljs-params">(x ,y <span class="hljs-keyword">int</span> )</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>,sub <span class="hljs-keyword">int</span>)</span></span> &#123;sum = x + ysub = x - y<span class="hljs-keyword">return</span> sum ,sub&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sumRes,subRes := calc(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)fmt.Println(sumRes)fmt.Println(subRes)sum1,sub1 := calc1(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)fmt.Println(sum1)fmt.Println(sub1) &#125;</code></pre><h2 id="5-函数的参数和返回值是可选的"><a href="#5-函数的参数和返回值是可选的" class="headerlink" title="5 函数的参数和返回值是可选的"></a>5 函数的参数和返回值是可选的</h2><p>函数的参数和返回值都是可选的。下面我们实现一个参数和返回值都没有的函数</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;test&quot;</span>)&#125;</code></pre><h2 id="6-把排序封装成方法"><a href="#6-把排序封装成方法" class="headerlink" title="6 把排序封装成方法"></a>6 把排序封装成方法</h2><blockquote><p> 实现整形的升序和降序顺序排列,string类型按照字符的首字母进行排序,首字母相同，继续往后一次对比</p></blockquote><h3 id="6-1-int类型升序"><a href="#6-1-int类型升序" class="headerlink" title="6.1 int类型升序"></a>6.1 int类型升序</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortIntAsc</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>;i&lt; <span class="hljs-built_in">len</span>(slice);i++ &#123;<span class="hljs-keyword">for</span> j := i +<span class="hljs-number">1</span> ;j&lt;<span class="hljs-built_in">len</span>(slice) ;j++ &#123;<span class="hljs-keyword">if</span> slice[i] &gt; slice[j] &#123;tmp := slice[i]slice[i] = slice[j]slice[j] = tmp&#125;&#125;&#125;<span class="hljs-keyword">return</span> slice&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">34</span>,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>,<span class="hljs-number">100</span>,<span class="hljs-number">444</span>,<span class="hljs-number">2</span>&#125;sortSlice := sortIntAsc(slice1)fmt.Println(sortSlice)&#125;</code></pre><h3 id="6-2-int类型降序"><a href="#6-2-int类型降序" class="headerlink" title="6.2 int类型降序"></a>6.2 int类型降序</h3><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortIntDes</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>;i&lt; <span class="hljs-built_in">len</span>(slice);i++ &#123;<span class="hljs-keyword">for</span> j := i +<span class="hljs-number">1</span> ;j&lt;<span class="hljs-built_in">len</span>(slice) ;j++ &#123;<span class="hljs-keyword">if</span> slice[i] &lt; slice[j] &#123;tmp := slice[i]slice[i] = slice[j]slice[j] = tmp&#125;&#125;&#125;<span class="hljs-keyword">return</span> slice&#125;</code></pre><h3 id="6-3-map对象-按照key进行排序"><a href="#6-3-map对象-按照key进行排序" class="headerlink" title="6.3 map对象 按照key进行排序"></a>6.3 map对象 按照key进行排序</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapSort</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> sliceKey   []<span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> k,_ := <span class="hljs-keyword">range</span> m &#123;sliceKey = <span class="hljs-built_in">append</span>(sliceKey, k)&#125;sort.Strings(sliceKey)<span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> sliceKey &#123;str += fmt.Sprintf(<span class="hljs-string">&quot;%v=&gt;%v |&quot;</span> ,v,m[v])&#125;<span class="hljs-keyword">return</span> str&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> map1 = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;19&quot;</span>,<span class="hljs-string">&quot;worker&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span>: <span class="hljs-string">&quot;aaa&quot;</span>,&#125;str1 := mapSort(map1)fmt.Println(str1)&#125;<span class="hljs-comment">//age=&gt;19 |sex=&gt;男 |username=&gt;bds |worker=&gt;linux |</span></code></pre><h2 id="7-函数变量作用域"><a href="#7-函数变量作用域" class="headerlink" title="7  函数变量作用域"></a>7  函数变量作用域</h2><p>全局变量: 全局变量是定义在函数外部的变量，他在程序整个运行周期内都有效</p><p>局部变量： 局部变量是定义在函数内部的变量， 函数定义的变量无法在函数外使用</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">var</span> a  = <span class="hljs-string">&quot;全局变量&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;局部变量&quot;</span>fmt.Println(<span class="hljs-string">&quot;run方法a: &quot;</span>,a)fmt.Println(<span class="hljs-string">&quot;run方法b: &quot;</span>,b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;run()fmt.Println(<span class="hljs-string">&quot;main方法a: &quot;</span>,a)<span class="hljs-comment">// fmt.Println(&quot;main方法b: &quot;,b)     //undefine：b 报错</span><span class="hljs-comment">//i 是局部变量，只能在for方法内中使用</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span> ;i++ &#123;fmt.Println(i)&#125;<span class="hljs-comment">//本作用域中相当于全局变量</span><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><span class="hljs-keyword">if</span> flag &#123;fmt.Println(<span class="hljs-string">&quot;true&quot;</span>)&#125;<span class="hljs-comment">// 局部作用域 ，局部变量</span><span class="hljs-keyword">if</span> flag := <span class="hljs-literal">true</span> ;flag &#123;fmt.Println(<span class="hljs-string">&quot;true&quot;</span>)&#125;fmt.Println(flag) <span class="hljs-comment">//undefine: flag</span>&#125;</code></pre><h2 id="8-自定义函数类型"><a href="#8-自定义函数类型" class="headerlink" title="8 自定义函数类型"></a>8 自定义函数类型</h2><p>我们可以使用type关键字来定一个函数类型，具体格式如下： </p><pre><code class="hljs go"><span class="hljs-keyword">type</span> calc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,init)</span> <span class="hljs-title">int</span></span></code></pre><p>上面语句定义了一个calc 类型，他是一个函数类型， 这种函数接收俩个int类型的参数并且返回一个int类型的返回值</p><p>简单来说，凡是满足这个条件的函数都是calc类型的函数，如果是不满足条件强行赋值是会报错的</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//自定义方法类型</span><span class="hljs-keyword">type</span> calc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-comment">//自定义整形类型</span><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x - y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>  &#123;fmt.Println(<span class="hljs-string">&quot;test&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c calcc = addfmt.Printf(<span class="hljs-string">&quot;c的类型: %T\n&quot;</span>,c )  <span class="hljs-comment">//c的类型: main.calc   这里是我们自定义类型</span>f := subfmt.Printf(<span class="hljs-string">&quot;f的类型：%T\n&quot;</span>,f)   <span class="hljs-comment">//f的类型：func(int, int) int  这里是类型推导</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b myInt = <span class="hljs-number">10</span>fmt.Printf(<span class="hljs-string">&quot;%v,%T\n&quot;</span>,a,a)   <span class="hljs-comment">//10,int</span>fmt.Printf(<span class="hljs-string">&quot;%v,%T\n&quot;</span>,b,b)   <span class="hljs-comment">//10,main.myInt</span><span class="hljs-comment">//因为b重新定义了myInt，myInt虽然是始于int定义的，但是还是属于俩个类型，不能相加</span><span class="hljs-comment">//fmt.Println(a+b)  //invalid operation: a + b (mismatched types int and myInt)</span> fmt.Println(a+<span class="hljs-keyword">int</span>(b))         <span class="hljs-comment">//20</span>&#125;</code></pre><h2 id="9-函数作为另一个函数的参数"><a href="#9-函数作为另一个函数的参数" class="headerlink" title="9  函数作为另一个函数的参数"></a>9  函数作为另一个函数的参数</h2><p>9.1 函数作为参数</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> calcType  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span> )</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x - y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>,cb calcType)</span> <span class="hljs-title">int</span></span> &#123;  <span class="hljs-keyword">return</span> cb(a,b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c = dodoValue :=c(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,add)fmt.Println(doValue)  <span class="hljs-comment">//用匿名函数直接作为参数进行传参</span>cValue := c(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x * y&#125;)  &#125;</code></pre><p>9.2 函数作为返回值</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> calcType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x - y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(cmd <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">calcType</span></span> &#123;<span class="hljs-keyword">switch</span> cmd &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<span class="hljs-keyword">return</span> add<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<span class="hljs-keyword">return</span> sub<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span> )</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x * y&#125;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c = do(<span class="hljs-string">&quot;*&quot;</span>)fmt.Println(c(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))&#125;</code></pre><h2 id="10-匿名函数和闭包"><a href="#10-匿名函数和闭包" class="headerlink" title="10 匿名函数和闭包"></a>10 匿名函数和闭包</h2><h3 id="10-1-匿名函数使用"><a href="#10-1-匿名函数使用" class="headerlink" title="10.1 匿名函数使用"></a>10.1 匿名函数使用</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能在像之前那样定义函数了，只能是定义匿名函数，匿名函数就没有函数名字的函数，匿名函数的定义格式如下： </p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(参数)</span><span class="hljs-params">(返回值)</span></span> &#123;  函数体&#125;</code></pre><p>匿名函数因为没有函数名字，所以没办法像普通函数那样被调用，所以匿名函数需要保存到某个变量或者作为立即执行函数</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//通过变量保存匿名函数</span><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x + y&#125;fmt.Println(add(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>))<span class="hljs-comment">//自执行函数，匿名函数定义后面加（）直接执行</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span></span>  &#123;fmt.Println(x * y)&#125;(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)&#125;</code></pre><h3 id="10-2-闭包使用"><a href="#10-2-闭包使用" class="headerlink" title="10.2 闭包使用"></a>10.2 闭包使用</h3><p>闭包可以理解成 定义在一个函数内部的函数，在本质上，闭包是将函数内部和函数外部连接起来的桥梁，或说是函数和其引用环境的组合体，首先我们先看一个例子</p><ul><li>闭包就是指有权访问另外一个函数作用域中的变量的函数</li><li>创建闭包的常见方式就是在一个函数内部创建另外一个函数，通过另外一个函数访问这个函数的局部变量</li></ul><p>注意： 由于闭包里作用域返回的局部变量资源不会被立刻销毁回收，所以可能会占用更多的内存，过度使用闭包会导致性能下降。</p><p>全局变量 </p><ul><li>常驻内存</li><li>污染全局</li></ul><p>局部变量的特点</p><ul><li>非偿住内存</li><li>不污染全局</li></ul><p>闭包：</p><ul><li>可以让一个变量常驻内存</li><li>可以让一个变量不污染全局</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addr</span><span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(s <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>  <span class="hljs-comment">//常驻内存，不污染全局</span><span class="hljs-keyword">var</span> fn1  = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;i += y<span class="hljs-keyword">return</span> i&#125;(y)s = fn1<span class="hljs-keyword">return</span> s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> fn = addr(<span class="hljs-number">3</span>)fmt.Println(fn)fmt.Println(fn)fmt.Println(fn)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">13</span><span class="hljs-comment">13</span><span class="hljs-comment">13</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层http/https笔记</title>
    <link href="/2020/12/06/%E5%BA%94%E7%94%A8%E5%B1%82http-https%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/06/%E5%BA%94%E7%94%A8%E5%B1%82http-https%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP-前沿"><a href="#1-HTTP-前沿" class="headerlink" title="1. HTTP 前沿"></a>1. HTTP 前沿</h2><p>上一个文章我们讲了传输层，接下来开始说说应用层协议，那么最常见的协议就是HTTP协议，我们就从HTTP开始。</p><p>首先 <code>http://www.budongshu.cn</code> 是一个<code>URL</code>,叫做<code>统一资源定位符</code> ，之所以叫做统一，是因为它是有格式的 </p><ul><li><p><code>HTTP</code> ：这个叫做协议</p></li><li><p><code>www.budongshu.cn</code>:  表示一个域名，在互联网上一个位置</p></li></ul><p>还有更详细的URL<code>http://budongshu.cn/archives/</code> 正因为它是统一的，所以浏览器知道如何进行统一的处理</p><h2 id="2-HTTP-请求准备"><a href="#2-HTTP-请求准备" class="headerlink" title="2. HTTP  请求准备"></a>2. HTTP  请求准备</h2><p>浏览器会将<a href="http://www.budongshu.cn/">www.budongshu.cn</a> 这个域名发送给DNS服务器，让它解析为IP地址。有关DNS解析过程后面会说，最后会解析成IP地址，然后建立TCP连接</p><p>因为我们知道HTTP是基于TCP协议的，TCP建立连接，经过三次握手，这个前面我们说过，还有目前http协议大部分都是1.1，默认是开启Keep-Alive的，这样建立连接，就可以多次请求中复用，毕竟TCP建立连接还是挺费劲的。</p><h2 id="3-HTTP-请求的构建"><a href="#3-HTTP-请求的构建" class="headerlink" title="3. HTTP 请求的构建"></a>3. HTTP 请求的构建</h2><p>建立了连接以后，浏览器就要发送 HTTP 的请求。</p><h3 id="3-1-第一部分-请求行"><a href="#3-1-第一部分-请求行" class="headerlink" title="3.1 第一部分 请求行"></a>3.1 第一部分 请求行</h3><p>在请求行中，URL 就是 <a href="http://www.163.com/">http://www.163.com</a> ，版本为 HTTP 1.1。这里要说一下的，就是方法。方法有几种类型。</p><p>请求方法： </p><p><code>GET</code>:  获取数据</p><p><code>POST</code>: 新建数据</p><p><code>PUT</code>:  更新数据</p><p><code>PATCH</code>: 局部更新( 比如只更改数据库里表的一个字段，只更新这字段。但PUT会更新整个库)</p><p><code>DELETE</code>: 删除数据</p><h3 id="3-2-首部字段"><a href="#3-2-首部字段" class="headerlink" title="3.2 首部字段"></a>3.2 首部字段</h3><ul><li><p><code>Accept-Charset</code>: 表示客户端可以接受的字符集。防止传过来的是另外的字符集，从而导致出现乱码。</p></li><li><p><code>Content-Type</code>：是指正文的格式。例如，我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。</p></li><li><p><code>Cache-control</code>：是用来控制缓存的。当客户端发送的请求中包含 <code>max-age</code> 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 <code>max-age </code>值为 0，那么缓存层通常需要将请求转发给应用集群。</p></li><li><p><code>If-Modified-Since</code>：也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回<code>“304 Not Modified”</code>的响应，那客户端就不用下载了，也会节省带宽。</p></li></ul><h2 id="4-HTTP请求的发送"><a href="#4-HTTP请求的发送" class="headerlink" title="4. HTTP请求的发送"></a>4. HTTP请求的发送</h2><p>HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 <code>stream 二进制流</code>的方式传给对方。当然，到了 TCP 层，它会把<code>二进制流</code>变成一个个<code>报文段</code>发送给服务器。</p><p><code>[源地址] [目标地址] [IP头]</code> 通过<code>ARP</code>协议请求目标mac地址，然后不算通过ARP请求MAC地址，替换头部MAC地址找到目标机器</p><p>解析IP地址符合，根据IP头中协议项, 解析TCP的头，里面序列号，看一下是不是我想要的，如果是放去缓存中返回ACK,如果不是丢弃</p><p>TCP头里面还有端口好，发现是HTTP的服务器监听的端口，于是将包发给HTTP服务器，HTTP进程看到，把请求结果返回给客户端</p><h2 id="5-HTTP-返回的构建"><a href="#5-HTTP-返回的构建" class="headerlink" title="5. HTTP 返回的构建"></a>5. HTTP 返回的构建</h2><p>HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。</p><ul><li>状态码:   <ul><li><code>200</code>: 请求正常</li><li><code>301</code>: 跳转URL改变</li><li><code>304</code>: 跳转URL不改变</li><li><code>404</code>: 找不到页面</li><li><code>5xx</code>: 服务器端错误</li><li><code>499</code>: 客户端主动断开</li></ul></li><li>返回首部的<code>key-value</code> (跟上面请求构建差不多)</li></ul><h2 id="6-HTTP-2-0"><a href="#6-HTTP-2-0" class="headerlink" title="6. HTTP 2.0"></a>6. HTTP 2.0</h2><p> HTTP 协议也在不断的进化过程中，在 HTTP1.1 基础上便有了 <code>HTTP 2.0</code></p><p>HTTP1.1 通信问题</p><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。</p><p>为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</p><p>另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。</p><p>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有 Header 帧，用于传输 Header 内容，并且会开启一个新的流。再就是 Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。</p><p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p><p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p><p>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p><h2 id="7-QUIC-协议的“城会玩”"><a href="#7-QUIC-协议的“城会玩”" class="headerlink" title="7. QUIC 协议的“城会玩”"></a>7. QUIC 协议的“城会玩”</h2><p>HTTP 2.0 虽然大大增加了并发性，但还是有问题的。因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。</p><p>当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。</p><p>诞生Google 的 <code>QUIC 协议</code> 基于<code>UDP</code></p><h3 id="7-1-机制一：自定义连接机制"><a href="#7-1-机制一：自定义连接机制" class="headerlink" title="7.1 机制一：自定义连接机制"></a>7.1 机制一：自定义连接机制</h3><p>以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。</p><h3 id="7-2-机制二：自定义重传机制"><a href="#7-2-机制二：自定义重传机制" class="headerlink" title="7.2 机制二：自定义重传机制"></a>7.2 机制二：自定义重传机制</h3><p>QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK  100，就是对第一个包的响应。如果返回 ACK  101 就是对第二个包的响应，RTT 计算相对准确。</p><p>但是这里有一个问题，就是怎么知道包 100 和包 101 发送的是同样的内容呢？QUIC 定义了一个 offset 概念。QUIC 既然是面向连接的，也就像 TCP 一样，是一个数据流，发送的数据在这个数据流里面有个偏移量 offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发；如果来了，按照 offset 拼接，还是能够拼成一个流</p><h3 id="7-3-机制三：无阻塞的多路复用"><a href="#7-3-机制三：无阻塞的多路复用" class="headerlink" title="7.3 机制三：无阻塞的多路复用"></a>7.3 机制三：无阻塞的多路复用</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201206202048376.png" alt="image-20201206202048376"></p><p>同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。</p><h3 id="7-4-机制四：自定义流量控制"><a href="#7-4-机制四：自定义流量控制" class="headerlink" title="7.4 机制四：自定义流量控制"></a>7.4 机制四：自定义流量控制</h3><p>但是 QUIC 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。</p><p>QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201206213410386.png" alt="image-20201206213410386"></p><h2 id="8-HTTPS-协议"><a href="#8-HTTPS-协议" class="headerlink" title="8 HTTPS 协议"></a>8 HTTPS 协议</h2><h3 id="8-1-对称加密"><a href="#8-1-对称加密" class="headerlink" title="8.1 对称加密"></a>8.1 对称加密</h3><p>在对称加密算法中，加密和解密使用的密钥是相同的,也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开</p><p>但是对称加密第一次再互联网传输密钥的时候，可能会有被窃取的风险，所以不太安全</p><p><strong>对称加密效率高，但是解决不了密钥传输问题</strong></p><h3 id="8-2-非对称加密"><a href="#8-2-非对称加密" class="headerlink" title="8.2 非对称加密"></a>8.2 非对称加密</h3><p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。</p><p><strong>非对称加密可以解决这个密钥传输问题</strong>，<strong>但是效率不高</strong></p><h3 id="8-3-数字证书"><a href="#8-3-数字证书" class="headerlink" title="8.3 数字证书"></a>8.3 数字证书</h3><p>非对称加密需要通过证书和权威机构来验证公钥的合法性，由权威部门颁发的称为<code>证书</code>,这个权威机构我们称为 <code>CA（ Certificate Authority）</code>。</p><h4 id="8-3-1-证书内容"><a href="#8-3-1-证书内容" class="headerlink" title="8.3.1 证书内容"></a>8.3.1 证书内容</h4><ul><li>Public-key 是公钥内容</li><li>Subject 就是证书颁发给谁</li><li>Issuer 也即证书是谁颁发</li><li>Signature Algorithm 是签名算法</li><li>Validity 是证书期限</li></ul><p>证书安全性</p><p>权威机构会给证书 卡一个章 称为<code>签名算法</code> </p><h4 id="8-3-2-签名算法"><a href="#8-3-2-签名算法" class="headerlink" title="8.3.2 签名算法:"></a>8.3.2 签名算法:</h4><p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。</p><p>除此之外，还有一种证书，称为 Self-Signed Certificate，就是自己给自己签名。这个给人一种“我就是我，你爱信不信”的感觉。这里我就不多说了。</p><h3 id="8-4-https-流程"><a href="#8-4-https-流程" class="headerlink" title="8.4 https 流程"></a>8.4 https 流程</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201206204530173.png" alt="image-20201206204530173"></p><p><strong>如果客户端不相信这个证书，内部会有这样的验证流程</strong></p><p>当然你不相信这个证书，于是你从自己信任的 CA 仓库中，拿 CA 的证书里面的公钥去解密外卖网站的证书。如果能够成功，则说明外卖网站是可信的。这个过程中，你可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，反正直到一个授信的 CA，就可以了。</p><h3 id="8-5-重放与篡改"><a href="#8-5-重放与篡改" class="headerlink" title="8.5 重放与篡改"></a>8.5 重放与篡改</h3><p>其实，这里还有一些没有解决的问题，例如重放和篡改的问题。</p><p>没错，有了加密和解密，黑客截获了包也打不开了，但是它可以发送 N 次。这个往往通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。</p><p>Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的，请求只接受一次，于是服务器多次收到相同的 Timestamp 和 Nonce，则视为无效即可。</p><p>如果有人想篡改 Timestamp 和 Nonce，还有签名保证不可篡改性，如果改了用签名算法解出来，就对不上了，可以丢弃了。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层TCP/UDP笔记</title>
    <link href="/2020/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82TCP-UDP%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82TCP-UDP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>传输层里比较重要的两个协议，一个是 TCP，一个是 UDP。对于不从事底层开发的人员来讲，或者对于开发应用的人来讲，最常用的就是这两个协议。由于面试的时候，这俩个是会是一起被问到的</p><h3 id="1-TCP-和-UDP-有哪些区别？"><a href="#1-TCP-和-UDP-有哪些区别？" class="headerlink" title="1 TCP 和 UDP 有哪些区别？"></a>1 TCP 和 UDP 有哪些区别？</h3><p>一般面试的时候我问这两个协议的区别，大部分人会回答，TCP 是面向连接的，UDP 是面向无连接的。什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会。为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？</p><h3 id="2-UDP-协议"><a href="#2-UDP-协议" class="headerlink" title="2  UDP 协议"></a>2  UDP 协议</h3><ul><li><p>不保证不丢失，不保证按照顺序到达 </p></li><li><p>基于数据报的，一个一个发，一个一个收</p></li><li><p>随时想发就发 无状态服务</p></li></ul><h3 id="3-UDP-包头"><a href="#3-UDP-包头" class="headerlink" title="3  UDP 包头"></a>3  UDP 包头</h3><p>我们来看一下UDP 包头</p><p>一个包的传输过程，当我发送一个UDP包到达目标主机后，进行MAC地址匹配，发现匹配，摘下MAC地址头部，将剩下包传输给IP层的代码，摘下IP头，看目标IP是否匹配，如果匹配接下来数据报怎么发送? </p><p>由于IP头会存放8位协议，这里面会存放到底是TCP还是UDP 。这里是UDP，然后我们按UDP头的格式，就能从数据里面，将它解析出来，解析出来数据交给下一层去处理  </p><p>处理完传输层的事情，内核的事情就基本完事，里面的数据交给应用程序去处理，一台机器会有好多个程序 </p><p>无论是TCP和UDP 传数据，应用程序都会监听一个端口，也就是这个端口，用来区分应用程序，所以端口不能冲突，然后根据端口号，将数据交给响应的应用程序 </p><p>通过下面图可以看到UDP 包头非常简单</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205172722741.png" alt="image-20201205172722741"></p><h3 id="4-UDP-特点"><a href="#4-UDP-特点" class="headerlink" title="4 UDP 特点"></a>4 UDP 特点</h3><ul><li>沟通简单，不需要三次握手四次断开</li><li>谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据</li><li>它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</li></ul><h3 id="5-UDP-使用场景"><a href="#5-UDP-使用场景" class="headerlink" title="5 UDP 使用场景"></a>5 UDP 使用场景</h3><p><strong>第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</strong></p><p>前面说的通过PXE自动安装系统 下载使用TFTP ,就是基于UDP协议，占有资源少</p><p><strong>第二，不需要一对一沟通，建立连接，而是可以广播的应用</strong></p><p>UDP 的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP 就是一种广播的形式，就是基于 UDP 协议的，而广播包的格式前面说过了。</p><p>在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。</p><p><strong>第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong></p><p>UDP 简单、处理速度快，不像 TCP 那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而 TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。</p><p>当前很多应用都是要求低时延的，它们可不想用 TCP 如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于 TCP。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达</p><h3 id="6-基于UDP的例子"><a href="#6-基于UDP的例子" class="headerlink" title="6 基于UDP的例子"></a>6 基于UDP的例子</h3><p>列举几种“城会玩”的例子。</p><h4 id="6-1-网页或者app的访问"><a href="#6-1-网页或者app的访问" class="headerlink" title="6.1 网页或者app的访问"></a>6.1 网页或者app的访问</h4><p><code>QUIC</code>（全称 Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</p><h4 id="6-2-流媒体协议"><a href="#6-2-流媒体协议" class="headerlink" title="6.2 流媒体协议"></a>6.2 流媒体协议</h4><p>现在直播比较火，直播协议多使用 RTMP，这个协议我们后面的章节也会讲，而这个 RTMP 协议也是基于 TCP 的。TCP 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着，因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。</p><h4 id="6-3-实时游戏"><a href="#6-3-实时游戏" class="headerlink" title="6.3 实时游戏"></a>6.3 实时游戏</h4><p>游戏有一个特点，要求实时性比较高，慢一秒可能就要被别人干掉或者爆头 </p><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响</p><h4 id="6-4-IoT-物联网"><a href="#6-4-IoT-物联网" class="headerlink" title="6.4 IoT 物联网"></a>6.4 IoT 物联网</h4><p>一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大；另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的。</p><h4 id="6-5-移动通信领域"><a href="#6-5-移动通信领域" class="headerlink" title="6.5 移动通信领域"></a>6.5 移动通信领域</h4><p>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的。因为移动网络协议比较复杂，而 GTP 协议本身就包含复杂的手机上线下线的通信协议。如果基于 TCP，TCP 的机制就显得非常多余，这部分协议我会在后面的章节单独讲解。</p><h3 id="7-TCP-协议"><a href="#7-TCP-协议" class="headerlink" title="7 TCP 协议"></a>7 TCP 协议</h3><p>我们讲的 UDP，基本上包括了传输层所必须的端口字段。它就像我们小时候一样简单，相信“网之初，性本善，不丢包，不乱序”。</p><p>后来呢，我们都慢慢长大，了解了社会的残酷，变得复杂而成熟，就像 TCP 协议一样。它之所以这么复杂，那是因为它秉承的是“性恶论”。它天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。</p><h3 id="8-TCP-协议包头格式"><a href="#8-TCP-协议包头格式" class="headerlink" title="8 TCP 协议包头格式"></a>8 TCP 协议包头格式</h3><p>我们先来看 TCP 头的格式。从这个图上可以看出，它比 UDP 复杂得多。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205181353995.png" alt="image-20201205181353995"></p><p>首先，源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。</p><p>接下来是包的序号。为什么要给包编号呢？当然是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。既然是社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。</p><p>还应该有的就是确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。</p><p>TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。</p><p>这有点像如果你在北京，和客户约十点见面，那么你应该清楚堵车是常态，你干预不了，也控制不了，你唯一能做的就是早走。打车不行就改乘地铁，尽力不失约。</p><p>接下来有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>不像小时候，随便一个不认识的小朋友都能玩在一起，人大了，就变得礼貌，优雅而警觉，人与人遇到会互相热情的寒暄，离开会不舍地道别，但是人与人之间的信任会经过多次交互才能建立。</p><p>还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>作为老司机，做事情要有分寸，待人要把握尺度，既能适当提出自己的要求，又不强人所难。除了做流量控制以外，TCP 还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><p>作为老司机，要会自我控制，知进退，知道什么时候应该坚持，什么时候应该让步。</p><p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：</p><ul><li><p>顺序问题 ，稳重不乱；</p></li><li><p>丢包问题，承诺靠谱；</p></li><li><p>连接维护，有始有终；</p></li><li><p>流量控制，把握分寸；拥塞控制</p></li></ul><h3 id="9-TCP-三次握手"><a href="#9-TCP-三次握手" class="headerlink" title="9 TCP 三次握手"></a>9 TCP 三次握手</h3><p>tcp的连接建立 常常称之为 三次握手，比如 </p><p>A：hello 我是A </p><p>B:   收到A的helo ，然后说 我是B hello </p><p>A： 你好B</p><p>也就是说我们都要保证A，B双方的消息有去也有回，就基本可以了。</p><p>三次握手还沟通了一个重要事情，就是<code>TCP包的序号的问题</code></p><p>A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。</p><p>例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。</p><p>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4 微秒加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 TTL，也即生存时间。</p><p>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205185241457.png" alt="image-20201205185241457"></p><h3 id="10-TCP-四次断开"><a href="#10-TCP-四次断开" class="headerlink" title="10 TCP 四次断开"></a>10 TCP 四次断开</h3><p>现在我们说一下四次断开，大家好聚好散，还是朋友</p><p>A:  B 我们分手吧</p><p>B：好，我知道了，分手就分手</p><p>B：A，你好狠心， 分吧分吧，把你的照片还给你 </p><p>A：好的B，照片收到，祝你幸福</p><p>状态时序图</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205190637906.png" alt="image-20201205190637906"></p><p><strong>最后等待2MSL 的原因</strong></p><ol><li><p>有可能A 最后发的ACK B没有收到，那么B会认为我上次给你发的FIN ACK包 A是不是没有收到，等待2MSL ，为了能够让B 再次重发FIN ACK包给A </p></li><li><p>避免端口被新应用占用，收到上个连接中B发过来的包，避免产生混乱</p></li></ol><p>等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等</p><p>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p><h3 id="11-TCP状态机"><a href="#11-TCP状态机" class="headerlink" title="11 TCP状态机"></a>11 TCP状态机</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205190545913.png" alt="image-20201205190545913"></p><h3 id="12-Socket"><a href="#12-Socket" class="headerlink" title="12 Socket"></a>12 Socket</h3><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket</p><h4 id="12-1-Socket-模拟实现"><a href="#12-1-Socket-模拟实现" class="headerlink" title="12.1 Socket 模拟实现"></a>12.1 Socket 模拟实现</h4><p>在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM</p><h4 id="12-2-基于-TCP-协议的-Socket-程序函数调用过程"><a href="#12-2-基于-TCP-协议的-Socket-程序函数调用过程" class="headerlink" title="12.2 基于 TCP 协议的 Socket 程序函数调用过程"></a>12.2 基于 TCP 协议的 Socket 程序函数调用过程</h4><p>我们可以现看一段代码实现</p><pre><code class="hljs python"><span class="hljs-comment">#通过一段代码模拟socker server服务端</span><span class="hljs-comment">#! /usr/bin/python</span><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> socketsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="hljs-comment">#用的是ipv4 并且是tcp</span>server_address = (<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">12345</span>)<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Staring up on %s:%s&quot;</span> %  server_addresssock.bind(server_address)sock.listen(<span class="hljs-number">5</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;waiting ..........&quot;</span>    connetion,client_address = sock.accept()    <span class="hljs-keyword">try</span>:        <span class="hljs-built_in">print</span>  <span class="hljs-string">&quot;Connection from &quot;</span>,client_address        data = connetion.recv(<span class="hljs-number">1024</span>)        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Receive &#x27;%s&#x27;&quot;</span> % data    <span class="hljs-keyword">finally</span>:        connetion.close()</code></pre><p>一般是先调用bind 函数，给这个Socket赋予一个IP地址和端口 </p><p>然后调用listen函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p><p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p><p>客户端代码实现</p><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/python</span><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> socketsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_tcp_status</span>(<span class="hljs-params">ip,port</span>):</span>    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="hljs-comment">#ipv4 tcp协议</span>    server_address = (ip,port)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;connecting to %s:%s&quot;</span> % server_address,port    sock.connect(server_address)        <span class="hljs-comment">#connect方法</span>    message = raw_input(<span class="hljs-string">&quot;pleas input: &quot;</span>)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Sending &#x27;%s&#x27;&quot;</span> % message    sock.sendall(message)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Closing socket&quot;</span>    sock.close()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-built_in">print</span> check_tcp_status(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">12345</span>)     <span class="hljs-comment">#要访问的服务端ip和端口</span></code></pre><p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p><p>这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。</p><p>连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。</p><p>这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。在这个结构里面，主要的是两个队列，一个是发送队列，一个是接收队列。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205205310237.png" alt="image-20201205205310237"></p><h4 id="12-3-基于UDP协议Socket-程序函数调用过程"><a href="#12-3-基于UDP协议Socket-程序函数调用过程" class="headerlink" title="12.3 基于UDP协议Socket 程序函数调用过程"></a>12.3 基于UDP协议Socket 程序函数调用过程</h4><p>对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口</p><h4 id="12-4-服务器连接数"><a href="#12-4-服务器连接数" class="headerlink" title="12.4 服务器连接数"></a>12.4 服务器连接数</h4><p>我们先来算一下理论值，也就是最大连接数，系统会用一个四元组来标识一个 TCP 连接</p><pre><code class="hljs shell">&#123;本机IP, 本机端口, 对端IP, 对端端口&#125;</code></pre><p>服务器的最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，按照上面的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的</p><h4 id="12-5-如果优化程序资源"><a href="#12-5-如果优化程序资源" class="headerlink" title="12.5 如果优化程序资源"></a>12.5 如果优化程序资源</h4><ul><li><p>多进程  </p></li><li><p>多线程</p></li><li><p>IO 多路复用，一个线程维护多个 Socket</p></li><li><p>IO 多路复用，epoll函数事件通知机制</p></li></ul><p><strong>epoll 被称为解决 C10K 问题的利器</strong></p><p>有个 C10K，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器 ,成本比较高，通过epoll 事件callback机制可以解决</p><h3 id="13-TCP-保证可靠关键"><a href="#13-TCP-保证可靠关键" class="headerlink" title="13 TCP 保证可靠关键"></a>13 TCP 保证可靠关键</h3><p>累计确认： TCP为了保证顺序性，会给每一个包起始一个ID，在建立连接的时候，会计算起始ID是什么，然后按照ID顺序，一个一个发送，为了保证不丢包，对于发送的包要应答，接收端收到包后，不是一个一个应答，而是应答某个之前包的ID，表示包我都收到。这种模式叫做<code>累计应答</code> 或者<code>累计确认</code> </p><h4 id="13-1-滑动窗口"><a href="#13-1-滑动窗口" class="headerlink" title="13.1 滑动窗口"></a>13.1 滑动窗口</h4><p>在 TCP 里，接收端会给发送端报一个窗口的大小，叫 <code>Advertised window</code></p><p>为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p><p>发送端缓存里记录的内容 </p><ul><li><p>第一部分：已经发送并且已经确认的包。 </p></li><li><p>第二部分：已经发送但是尚未确认的包。</p></li><li><p>第三部分：尚未发送但是马上准备发送的包。</p></li><li><p>第四部分：尚未发送但是暂时不准备发送的包。</p></li></ul><p>接收端缓存里记录的内容 </p><ul><li><p>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的。</p></li><li><p>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。</p></li><li><p>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</p></li></ul><h4 id="13-2-顺序问题与丢包问题"><a href="#13-2-顺序问题与丢包问题" class="headerlink" title="13.2 顺序问题与丢包问题"></a>13.2 顺序问题与丢包问题</h4><p><strong>超时重试</strong>： 对于每一个发送的包，还没有进行ACK包确认的，都设置一个定时器，超过时间就重新尝试，时间必须大于往返时间RTT,否则也会引起不必要重传，也不宜过长，时间变长，那么访问时间就会变慢了</p><p><strong>超时间加倍</strong>： 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</p><p><strong>快速重传的机制：</strong> </p><p>第一种办法： </p><p>当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段</p><p>第二种办法： </p><p><code>Selective Acknowledgment （SACK）</code> : 这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。</p><h4 id="13-3-流量控制问题"><a href="#13-3-流量控制问题" class="headerlink" title="13.3 流量控制问题"></a>13.3 流量控制问题</h4><p>发送端发送的每一个数据包，服务端都要给一个确认包（ACK）.确认它收到了。 服务端给发送端发送的确认包（ACK包）中，同时会携带一个窗口的大小。 </p><p>这个窗口的大小就代表目前服务器端的处理能力。（接收端最大缓存量-接收已确认但还未被应用层读取的部分）。 这个窗口的大小也是时时刻刻在变化的，可能接收方再发送数据包4的ACK时，窗口大小为9。</p><p>此时应用层的程序疯狂去接收已接收并且已确认的缓存，没准接收方再发送数据包5的ACK时，窗口的大小就变为了14了呢。</p><p><strong>还要注意</strong>： 当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。</p><h4 id="13-4-拥塞控制问题"><a href="#13-4-拥塞控制问题" class="headerlink" title="13.4 拥塞控制问题"></a>13.4 拥塞控制问题</h4><p>也是通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。</p><p>**拥塞控制作用: ** 就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p><p>指数性的增长,线性增长</p><p>我们知道TCP通过一个timer采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。</p><p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。（关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a>》(PDF)</p><p><strong>拥塞控制主要是四个算法：</strong></p><ul><li>1）慢启动；</li><li>2）拥塞避免；</li><li>3）拥塞发生；</li><li>4）快速恢复。</li></ul><p>这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p><p><strong>备注:</strong></p><ul><li>1988年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li><li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li></ul><h4 id="13-5-TCP-BBR-拥塞算法"><a href="#13-5-TCP-BBR-拥塞算法" class="headerlink" title="13.5 TCP BBR 拥塞算法"></a>13.5 TCP BBR 拥塞算法</h4><p>解决拥塞控制带来的俩个问题： </p><p>第一个问题是： 丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。</p><p>第二个问题是：  TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。</p><p>为了优化这两个问题，后来有了 TCP BBR 拥塞算法。它企图找到一个平衡点，就是通过不断地加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。</p><p>参考:<br><a href="https://time.geekbang.org/column/intro/85">https://time.geekbang.org/column/intro/85</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二层到三层知识笔记</title>
    <link href="/2020/12/05/%E4%BA%8C%E5%B1%82%E5%88%B0%E4%B8%89%E5%B1%82%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/%E4%BA%8C%E5%B1%82%E5%88%B0%E4%B8%89%E5%B1%82%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>上个笔记我们知道IP地址的诞生，那么机器一旦有了IP，就可以在网络的环境和其他机器进行沟通了</p><p>如果我们宿舍内俩个人需要通过电脑来玩一个游戏比如cs5， 这时候我们就需要建立一个局域网，让俩台</p><p>电脑能够连在这个局域网中</p><h3 id="1-先来说几个词语解释"><a href="#1-先来说几个词语解释" class="headerlink" title="1 先来说几个词语解释"></a>1 先来说几个词语解释</h3><ul><li><p>全双工：可以同时发送和接收信号</p></li><li><p>半双工：互相协调，都可以想对方发，但是需要协调</p></li><li><p>单工： 永远只能是一方发一方收</p></li></ul><h3 id="2-第一层-物理层"><a href="#2-第一层-物理层" class="headerlink" title="2  第一层 物理层"></a>2  第一层 物理层</h3><p>如何来构建一个小的局域网(LAN) ？如果是三台电脑呢？</p><ol><li>我们可以通过用网线的方式把俩台电脑进行连接上（以前需要用交叉线方式，现在网卡自适应）</li><li>Hub集线器：这个设备有多个扣，可以将多个电脑连接，集线器没有大脑 ，会将收到的每个字节，都复制到其他端口上去（采取的是广播模式）</li></ol><h3 id="3-第二层（数据链路层）"><a href="#3-第二层（数据链路层）" class="headerlink" title="3 第二层（数据链路层）"></a>3 第二层（数据链路层）</h3><p>由于hub采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都可以收到，这就比较麻烦 需要我们来解决几个问题</p><h4 id="3-1-大家都在发，包混乱？谁先发，谁后发？"><a href="#3-1-大家都在发，包混乱？谁先发，谁后发？" class="headerlink" title="3.1 大家都在发，包混乱？谁先发，谁后发？"></a>3.1 大家都在发，包混乱？谁先发，谁后发？</h4><p>首先这是一个MAC 层（第二层，数据链路层）需要来解决的  ,<code>MAC</code> 全称 <code>Medium Access Contron</code> ：媒体访问控制。主要是控制谁先发，谁后发的问题，是通过多路访问协议来实现，通过下面三种方式</p><ul><li>信道划分: 每个车一个车道，各走各的</li><li>轮流协议: 相当于单双号出行</li><li>随机接入协议: 先出门上路，发现堵住了，就回去，然后错过高峰再出来，著名的以太网。用的这个方式</li></ul><h4 id="3-2-这个包是发给谁的？谁应该接收？"><a href="#3-2-这个包是发给谁的？谁应该接收？" class="headerlink" title="3.2  这个包是发给谁的？谁应该接收？"></a>3.2  这个包是发给谁的？谁应该接收？</h4><p>解决这个问题就要涉及到第二层的 <code>网络包格式</code> ，对于以太网 第二层的开始就是目标的MAC地址和源的MAC地址</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205111328317.png" alt="image-20201205111328317"></p><p>接下来是类型，大部分的类型是 IP 数据包，然后 IP 里面包含 TCP、UDP，以及 HTTP 等，这都是里层封装的事情。</p><p>有了这个目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80 </p><p>于是将请求提交给 nginx，nginx 返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。</p><h4 id="3-3-如果发送的时候出现了错误，怎么办"><a href="#3-3-如果发送的时候出现了错误，怎么办" class="headerlink" title="3.3 如果发送的时候出现了错误，怎么办"></a>3.3 如果发送的时候出现了错误，怎么办</h4><p>对于以太网，第二层的最后面是 CRC，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。</p><h4 id="3-4-如果不知道MAC地址-怎么办？"><a href="#3-4-如果不知道MAC地址-怎么办？" class="headerlink" title="3.4 如果不知道MAC地址 怎么办？"></a>3.4 如果不知道MAC地址 怎么办？</h4><p>通过<code>ARP协议</code> 就是已知IP地址，求MAC地址的协议 </p><p>前面我们说过，在一个局域网里面，不知道MAC地址怎么办？基本靠吼，发送一个广播包，谁使这个IP，就谁来回答</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205112054706.png" alt="image-20201205112054706"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205112140702.png" alt="image-20201205112140702"></p><p>为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。</p><h4 id="3-5-局域网"><a href="#3-5-局域网" class="headerlink" title="3.5 局域网"></a>3.5 局域网</h4><p>我们需要一个设备能够记住每个口的电脑MAC ，这样子我能以后在发送包的时候，就可以不用广播，避免了浪费，然后检查一下目标MAC地址，根据策略转发，这个设备是个二层设备，称为 交换机 (简单的解释理解)</p><p>交换机是有学习功能的，当第一次发送数据包的时候，会记录一个端口和MAC的映射关系,所以等过了一段时间，整个网络的结构就有了，这时候就不需要广播了。。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。</p><h3 id="4-交换机"><a href="#4-交换机" class="headerlink" title="4 交换机"></a>4 交换机</h3><h4 id="4-1-首先说明下交换机和hub的区别"><a href="#4-1-首先说明下交换机和hub的区别" class="headerlink" title="4.1 首先说明下交换机和hub的区别"></a>4.1 首先说明下交换机和hub的区别</h4><pre><code class="hljs objectivec">Hub：<span class="hljs-number">1.</span>一个广播域，一个冲突域。<span class="hljs-number">2.</span>传输数据的过程中易产生冲突，带宽利用率不高交换机：<span class="hljs-number">1.</span>在划分vlan的前提下可以实现多个广播域，每个接口都是一个单独的冲突域<span class="hljs-number">2.</span>通过自我学习的方法可以构建出<span class="hljs-built_in">CAM</span>表，并基于<span class="hljs-built_in">CAM</span>进行转发数据。<span class="hljs-number">3.</span>支持生成树算法。可以构建出物理有环，逻辑无环的网络，网络冗余和数据传输效率都甩Hub好几条街。SW是目前组网的基本设备之一。</code></pre><h4 id="4-1-拓扑结构"><a href="#4-1-拓扑结构" class="headerlink" title="4.1 拓扑结构"></a>4.1 拓扑结构</h4><p>其实就是由多个交换机组织起来的一种结构，当然交换机多的时候，难免会产生环路</p><p>就是绕了一圈，从起点又回到起点</p><h4 id="4-2-解决常见的环路问题"><a href="#4-2-解决常见的环路问题" class="headerlink" title="4.2 解决常见的环路问题"></a>4.2 解决常见的环路问题</h4><p>在数据结构中有一个方法叫做<code>最小生成树</code> 有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作<code> STP</code>，全称 <code>Spanning Tree Protocol</code>。</p><p>在STP协议里面有很多概念</p><ul><li>Root Bridge: 根交换机 </li><li>Designated Bridges: 指定交换机</li><li>Bridge Protocal Data Units(BPDU)：网桥协议数据单元</li><li>Priority Vector ： 优先级向量 就是一组 ID 数目 <ul><li>Root Bridge ID </li><li>Root Path Cost</li><li>Bridge ID and Port ID</li></ul></li></ul><h4 id="4-3-如何解决广播问题和安全问题？"><a href="#4-3-如何解决广播问题和安全问题？" class="headerlink" title="4.3 如何解决广播问题和安全问题？"></a>4.3 如何解决广播问题和安全问题？</h4><p>如果机器多了 交换机多了 ，也难免会由广播的问题， 由于我们在同一个广播域里面，遇到一个会抓包的脚本小子，就能够抓到这些包，然后进行分析，可能会看到敏感信息 </p><p><strong>我们有俩种办法</strong></p><ul><li><p>物理隔离： 每个部门单独一台交换机，如果部门人少，交换机口多了就会照成浪费</p></li><li><p>虚拟隔离：<code>VLAN</code>虚拟局域网，在一个交换机会连属于多个局域网的机器 </p></li></ul><p><strong>那么是怎么区分那个局域网呢？</strong></p><p>需要在原来的二层头上加一个TAG 里面由<code>VLAN ID</code> 一共是12位，可以划分<code>4096个VLAN</code></p><p>如果在大型云计算平台公司这显然使不够用的，后面就要引入其他的办法来解决。</p><p>这时候需要交换机支持VLAN功能，然后有一种接口叫做<code>Trunk</code>接口，可以转发任何VLAN的口，交换机之间通过这个口进行连接，从而解决广播问题和安全问题</p><h3 id="5-ICMP-协议"><a href="#5-ICMP-协议" class="headerlink" title="5 ICMP 协议"></a>5 ICMP 协议</h3><p><code>ICMP </code>: 全称 <code>Internet Control Message Protocol</code>，就是互联网控制报文协议</p><p>如果遇到网络不通的时候，就会想到一个命令 ping 一下，</p><p>ping 就是基于ICMP 协议工作的 </p><p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱。</p><p>ICMP 报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为 8，主动请求的应答为 0</p><h4 id="5-1-查询报文类型"><a href="#5-1-查询报文类型" class="headerlink" title="5.1 查询报文类型"></a>5.1 查询报文类型</h4><p>常用的ping就是查询报文类型，是一种主动请求，并且获取主动应答的ICMP协议</p><p>ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><ul><li><p>ping主动请求： ICMP ECHO REQUEST</p></li><li><p>ping主动请求回复： ICMP ECHO REPLY</p></li></ul><p>比原生ICMP多的俩个字段，就是字面意思</p><ul><li><p>标识符</p></li><li><p>序号</p></li></ul><h4 id="5-2-差错报文类型"><a href="#5-2-差错报文类型" class="headerlink" title="5.2 差错报文类型"></a>5.2 差错报文类型</h4><p>报错报文的例子： <strong>终点不可达为 3，源抑制为 4，超时为 11，重定向为 5</strong></p><p>这个解释根据具体场景很好： </p><p><strong>第一种是终点不可达</strong>。小兵：报告主公，您让把粮草送到张将军那里，结果没有送到。如果你是主公，你肯定会问，为啥送不到？具体的原因在代码中表示就是 </p><p>网络不可达代码为 0，主机不可达代码为 1，协议不可达代码为 2，端口不可达代码为 3，需要进行分片但设置了不分片位代码为 4。</p><p>具体的场景就像这样：</p><ul><li>网络不可达：主公，找不到地方呀？主机不可达：主公，找到地方没这个人呀？</li><li>协议不可达：主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说 12345！</li><li>端口不可达：主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。</li><li>需要进行分片但设置了不分片位：主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了</li></ul><p><strong>第二种是源站抑制</strong>，也就是让源站放慢发送速度。小兵：报告主公，您粮草送的太多了吃不完。</p><p><strong>第三种是时间超时</strong>，也就是超过网络包的生存时间还是没到。小兵：报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。</p><p><strong>第四种是路由重定向</strong>，也就是让下次发给另一个路由器。小兵：报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。</p><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><h4 id="5-3-ping-查询报文类型的使用"><a href="#5-3-ping-查询报文类型的使用" class="headerlink" title="5.3 ping 查询报文类型的使用"></a>5.3 ping 查询报文类型的使用</h4><p>假定主机 A 的 IP 地址是 192.168.1.1，主机 B 的 IP 地址是 192.168.1.2，它们都在同一个子网。那当你在主机 A 上运行“ping 192.168.1.2”后，会发生什么呢?</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。</p><p>接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205131429891.png" alt="image-20201205131429891"></p><p><strong>1.5.4 Traceroute：差错报文类型的使用</strong></p><p>所以，Traceroute 的第一个作用就是故意设置特殊的 TTL，， 来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。</p><p><strong>注意每次经过一个路由器，TTL值就会减1</strong></p><p>如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。那大军前行就带一顿饭，试一试走多远会被饿死，然后找个哨探回来报告，那我就知道大军只带一顿饭能走多远了。</p><p>接下来，将 TTL 设置为 2。第一关过了，第二关就“牺牲”了，那我就知道第二关有多远。如此反复，直到到达目的主机。这样，Traceroute 就拿到了所有的路由器 IP。当然，有的路由器压根不会回这个 ICMP。这也是 Traceroute 一个公网的地址，看不到中间路由的原因。</p><p>怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。</p><p>这就相当于故意派人去西天如来那里去请一本《道德经》，结果人家信佛不信道，消息就会被打出来。被打的消息传回来，你就知道西天是能够到达的。为什么不去取《心经》呢？因为 UDP 是无连接的。也就是说这人一派出去，你就得不到任何音信。你无法区别到底是半路走丢了，还是真的信佛遁入空门了，只有让人家打出来，你才会得到消息。</p><p><strong>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU</strong>。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，类型为“需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205131351982.png" alt="image-20201205131351982"></p><h3 id="6-网关"><a href="#6-网关" class="headerlink" title="6 网关"></a>6 网关</h3><p>相当于给网络指一个方向</p><h4 id="6-1-网关"><a href="#6-1-网关" class="headerlink" title="6.1 网关"></a>6.1 网关</h4><p>网关往往是一个路由器，是一个三层转发的设备。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备 </p><h4 id="6-2-静态路由"><a href="#6-2-静态路由" class="headerlink" title="6.2 静态路由"></a>6.2 静态路由</h4><p>静态路由 是人手工配置上的一条条规则，是单向的，缺乏灵活性</p><p>下一跳</p><p>是路由器根据路由表将数据转发到下一个端口地址</p><h4 id="6-3-跨局域网通信"><a href="#6-3-跨局域网通信" class="headerlink" title="6.3 跨局域网通信"></a>6.3 跨局域网通信</h4><p>当我们跨局域网通信的时候,比如使一个业务A访问业务B，俩个服务是俩个网段 </p><p>这时候就需要通过路由器(三层ip)来指路，在路由器上配置一条静态路由指明下一跳地址 </p><p>然后我们通过静态路由进入业务B的局域网，找到业务B，在这个期间MAC地址是要改变的，但是IP地址不变</p><h4 id="6-4-访问公网服务的时候"><a href="#6-4-访问公网服务的时候" class="headerlink" title="6.4 访问公网服务的时候"></a>6.4 访问公网服务的时候</h4><p>当我们跨局域网访问的时候，是需要做NAT 转换的</p><p>很多办公室访问外网的时候，也是被 NAT 过的，因为不可能办公室里面的 IP 也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口 IP 地址。你可以通过 <a href="https://www.whatismyip.com/">https://www.whatismyip.com/</a> 查看自己的出口 IP 地址。</p><h3 id="7-路由器"><a href="#7-路由器" class="headerlink" title="7 路由器"></a>7 路由器</h3><h4 id="7-1配置路由"><a href="#7-1配置路由" class="headerlink" title="7.1配置路由"></a>7.1配置路由</h4><p>路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为路由表。</p><p>一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。</p><ul><li>目的网络：这个包想去哪儿？</li><li>出口设备：将包从哪个口扔出去？</li><li>下一跳网关：下一个路由器的地址。</li></ul><h4 id="7-2-配置路由"><a href="#7-2-配置路由" class="headerlink" title="7.2 配置路由"></a>7.2 配置路由</h4><p>通过 route 命令和 ip route 命令都可以进行查询或者配置。例如，我们设置 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p><h4 id="7-3-策略路由"><a href="#7-3-策略路由" class="headerlink" title="7.3  策略路由"></a>7.3  策略路由</h4><p>可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由</p><pre><code class="hljs shell">ip rule add from 192.168.1.0/24 table 10 ip rule add from 192.168.2.0/24 table 20</code></pre><h4 id="7-3-动态路由算法"><a href="#7-3-动态路由算法" class="headerlink" title="7.3 动态路由算法"></a>7.3 动态路由算法</h4><p>网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。</p><p>动态路由好处： <strong>所以使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化</strong></p><h5 id="7-3-1-距离矢量路由算法"><a href="#7-3-1-距离矢量路由算法" class="headerlink" title="7.3.1  距离矢量路由算法"></a>7.3.1  距离矢量路由算法</h5><p>第一大类的算法称为<code>距离矢量路由（distance vector routing）</code>。它是基于<code> Bellman-Ford</code>算法的。</p><p><strong>第一个问题： 好消息传的快，坏消息传的慢</strong>（也就是收敛慢）</p><p>如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去</p><p>但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了</p><p><strong>第二个问题： 每次发送的时候，发送整个全局路由表</strong></p><p>网络大了，谁也受不了，所以最早的路由协议 RIP 就是这个算法。它适用于小型网络（小于 15 跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了</p><h5 id="7-4-2-链路状态路由算法"><a href="#7-4-2-链路状态路由算法" class="headerlink" title="7.4.2 链路状态路由算法"></a>7.4.2 链路状态路由算法</h5><p>第二大类算法是<code>链路状态路由（link state routing）</code>，基于<code>Dijkstra</code>算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径</p><p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p><h4 id="7-5-动态路由协议"><a href="#7-5-动态路由协议" class="headerlink" title="7.5 动态路由协议"></a>7.5 动态路由协议</h4><h5 id="7-4-1-基于链路状态路由算法的-OSPF"><a href="#7-4-1-基于链路状态路由算法的-OSPF" class="headerlink" title="7.4.1  基于链路状态路由算法的 OSPF"></a>7.4.1  基于链路状态路由算法的 OSPF</h5><p><code>OSPF</code>: Open Shortest Path First，开放式最短路径优先</p><p><code>IGP</code>: 内部网关协议 主要是在数据中心内部，用于路由决策的</p><p>内部网关协议重点就是找到最短的路径，在一个组织内部，路径最短为最优 </p><p>但有时候ospf 可以发现多个最短路径。可以在多个路径中进行<code>负载均衡</code>,这常常被称为</p><p><code>等价路由</code></p><p><strong>这里顺便说下一些电商平台前端架构</strong> </p><p>因为有了等价路由，可以分摊流量，还可以一条路不通的时候，走另外一个条</p><p>相当于既有 <code>高可用</code>，还可以<code>负载均衡</code> 这是一个保障公司网络架构稳定的一个好方案</p><p>那么一般大型公司前端架构就会采用<code>lvs + ospf</code> 方式来接入网络中，为了抗住大流量 </p><p><code>网卡</code>还可以做<code>bond</code> 进行流量进行分担</p><h5 id="7-4-2-基于距离矢量路由算法的-BGP"><a href="#7-4-2-基于距离矢量路由算法的-BGP" class="headerlink" title="7.4.2  基于距离矢量路由算法的 BGP"></a>7.4.2  基于距离矢量路由算法的 BGP</h5><p><code>BGP</code>: 外网路由协议（Border Gateway Protocol，简称 BGP ）</p><p>再网络的世界里面 每个公网成为自治系统<code>AS</code>（Autonomous System）自治系统分几种类型。</p><ul><li><code>Stub AS</code>: 对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。</li><li><code>MultiHomed AS</code>: 可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。</li><li><code>Transit AS</code>: 有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。</li></ul><p>每个自治系统都有边界路由器，通过它和外面的世界建立联系。</p><p><strong>BGP分为俩类</strong></p><ul><li><p>eBGP: 自治系统间， 边界路由器之间使用eBGP广播路由</p></li><li><p>iBGP: 自治系统内部，使用iBGP,使内部的路由器能够找到到达外网目的的最好的边界路由器</p></li></ul><p>BGP 协议使用的算法是路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版。<br>参考:<br><a href="https://time.geekbang.org/column/intro/85">https://time.geekbang.org/column/intro/85</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络通信协议笔记</title>
    <link href="/2020/12/05/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成“协议”，通天塔的计划就失败了</p><p>但是千年以后，有一种叫“程序猿”的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打造这互联网世界的通天塔。如今的世界，正是因为互联网，才连接在一起。   </p><p>只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。</p><h3 id="1-1-当我们输入URL-发生了什么？"><a href="#1-1-当我们输入URL-发生了什么？" class="headerlink" title="1.1 当我们输入URL 发生了什么？"></a>1.1 当我们输入URL 发生了什么？</h3><p>首先我们在浏览器里面输入<a href="https://www.budongshu.cn/">https://www.budongshu.cn</a> 这是一个<code>URL</code>，浏览器不知道它要去的具体地点，也不知道如何访问，于是去<code>DNS</code>(相当于地址薄)中去查找，经过查找后，会得到一个<code>IP</code>地址，相当于是互联网的门牌号</p><p>我们知道了目标地址，浏览器就会打包它的请求，普通的浏览器请求一般是使用<code>http</code>协议，但是对于现在来讲比如购物的请求，是需要加密的，会使用<code>https</code>协议，无论什么协议，最后都会里面写清楚<code>你要买什么 和买多少</code></p><p>DNS,HTTP,HTTPS 所在的层是我们称为： <strong>应用层</strong>。经过应用层封装后，浏览器会将应用层包交给下一层去完成</p><p>通过socket 编程来实现，我们就到了下一层是<strong>传输层</strong></p><p>传输层包括俩个协议，一个是tcp一个是udp，那么对于购物支付来讲，肯定是会使用tcp协议，所谓的面相连接就是，tcp会保证这个包能够到达目的地，如果不能够到达，就会重新发送，直至到达</p><p>tcp协议里面会有俩个端口 ,一个是浏览器监听的随机端口，一个是我要访问的目的地址服务器端监听的端口，</p><p>我们服务器端的操作系统会通过内核来判断，它得到的包应该是属于那个进程</p><p>传输层封装完毕后，浏览器会将包交给操作系统的网络层。网络层的协议是 IP 协议。在 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。</p><p>操作系统知道目标ip后，就会进行判断，这个ip地址是在本地，还是外地呢，从ip地址就可以看出来(ip地址每一段都有规划的，所以可以看出来)，它不属于本地，应该在遥远的地方</p><p>我们去远方就需要，比如要去海外就要去海关，我们去远方就要去<code> 网关</code>, 操作系统再启动的时候，会被DHCP协议配置分配一个随机IP地址以及默认的网关的IP地址10.1.1.1。</p><p>那么操作系统如何将IP地址发送给网关呢？ 在本地通信基本靠吼，于是操作系统大吼一声，谁是网关10.1.1.1啊?</p><p>有人回答，他就是，他在本地地址村东头 </p><ul><li>本地地址： <code>MAC地址</code></li><li>大吼一声： <code>ARP协议</code></li></ul><p>于是操作系统将 IP 包交给了下一层，也就是 MAC 层。网卡再将包发出去。由于这个包里面是有 MAC 地址的，因而它能够到达网关。</p><p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。</p><p>路由器相当于怎么讲呢？比如如果我们国家是一个大的局域网，那么连接俩个国家的通信就是路由器，而在我们国家内部，就可以使用本地的地址MAC进行通信（也就是通过交换机）</p><p>一旦我们出国了，手里拿着源ip和目标IP，应该怎么走，这种沟通的协议称为路由协议，常用的有 OSPF 和 BGP。</p><p>当我们网络包到达下一个国家的时候，还是要使用国家内部MAC地址 ，通过下一个国家的MAC地址，找个下一个国家，然后在问下一步怎么走，一直走到最后一个国家。</p><p>最后一个国家知道这个网络包要去的地方，于是对着这个国家本地地址大吼一声，谁是目标IP？目标服务器就会回复一个MAC地址，网络包过关后，通过这个MAC地址就能找到目标服务器。</p><p>目标服务器发现MAC地址对上了，你找的是我，然后去下MAC头，发送给操作系统的网络层，发现IP也对上了，就取下IP头，IP头里面封装的是TCP协议，然后交给传输层，即TCP层</p><p>在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。</p><p>如果过一段时间还是没到，发送端的 TCP 层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。<code>这个重试绝非你的浏览器重新将下单这个动作重新请求一次</code>。对于浏览器来讲，就发送了一次下单请求，TCP 层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。</p><p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。</p><p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。</p><p>然后通过系统调用通知进程,当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功</p><h3 id="1-2-分层模型"><a href="#1-2-分层模型" class="headerlink" title="1.2 分层模型"></a>1.2 分层模型</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204224331654.png" alt="image-20201204224331654"></p><h3 id="1-3-MAC地址知识补充"><a href="#1-3-MAC地址知识补充" class="headerlink" title="1.3 MAC地址知识补充"></a>1.3 MAC地址知识补充</h3><p> 网卡MAC码是由全球惟一的一个固定组织来分配的，未经认证和授权的厂家无权生产网卡。每块网卡都有一个固定的卡号，并且任何正规厂家生产的网卡上都直接标明了卡号，一般为一组12位的16进制数。其中前6位代表网卡的生产厂商。后面的位数是设备号。当然在操作系统级别改Mac地址又是一种说法</p><h3 id="1-4-网络为什么要分层"><a href="#1-4-网络为什么要分层" class="headerlink" title="1.4 网络为什么要分层"></a>1.4 网络为什么要分层</h3><p>复杂的程序都需要分层，比如我们架构网站<code>前端 后端 缓存 中间件 数据库 存储 </code>  ，我们通过分层使每一层各司其职</p><p>明确自己的职责，这样也不会混乱，还很清晰明了</p><h3 id="1-5-层与层之间的关系"><a href="#1-5-层与层之间的关系" class="headerlink" title="1.5 层与层之间的关系"></a>1.5 层与层之间的关系</h3><h4 id="1-5-1-打个比喻来说明层与层之间的关系"><a href="#1-5-1-打个比喻来说明层与层之间的关系" class="headerlink" title="1.5.1 打个比喻来说明层与层之间的关系"></a>1.5.1 打个比喻来说明层与层之间的关系</h4><p>通信协议就像没有天桥的双子楼，要从A座的24层到达B座24层就得先下楼梯再上楼梯，其他协议也是如此，比如4G</p><p>很像你去找你女朋友。 你=&gt;穿内衣=&gt;穿衣服=&gt;坐车=&gt;转车到地方=&gt;脱衣服=&gt;脱内衣=&gt;见女朋友</p><h4 id="1-5-2-第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？"><a href="#1-5-2-第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？" class="headerlink" title="1.5.2 第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？"></a>1.5.2 第一个问题，TCP在三次握手的时候，IP层和MAC层在做什么？</h4><p>当然使TCP发送每一个消息，都会带着IP层和MAC层，因为TCP每次发送一个消息，IP层和MAC层的所有机制</p><p>都要运行一遍。其实IP层和MAC层也为此忙活好久。</p><p><strong>这里要记住一点：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</strong></p><p>所以，<strong>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。</strong></p><h4 id="1-5-3-第二个问题-知道IP地址就直接发消息，要MAC地址干啥？"><a href="#1-5-3-第二个问题-知道IP地址就直接发消息，要MAC地址干啥？" class="headerlink" title="1.5.3  第二个问题,知道IP地址就直接发消息，要MAC地址干啥？"></a>1.5.3  第二个问题,知道IP地址就直接发消息，要MAC地址干啥？</h4><ol><li>IP是三层协议，必须封装在二层协议（比如以太网协议）中，MAC工作在二层，然后二层协议再通过硬件设备把网络包发出去，所以需要MAC地址（二层地址）。</li><li>IP，Internet Protocol，网络互联协议，它设计出来是为了互联不同的网络的，他的作用是在不同网络之间做寻址。</li><li>所以没有MAC地址消息是发不出去的。</li></ol><h3 id="1-6-IP地址"><a href="#1-6-IP地址" class="headerlink" title="1.6 IP地址"></a>1.6 IP地址</h3><blockquote><p>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码</p></blockquote><p>比如10.1.1.1 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。这样产生的 IP 地址的数量很快就不够用了。因为当时设计 IP 地址的时候，哪知道今天会有这么多的计算机啊！因为不够用，于是就有了 IPv6，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64。这个有 128 位，现在看来是够了，但是未来的事情谁知道呢？</p><h4 id="1-6-1-ip地址被分为五类"><a href="#1-6-1-ip地址被分为五类" class="headerlink" title="1.6.1 ip地址被分为五类"></a>1.6.1 ip地址被分为五类</h4><p>网络号： 用于识别主机所在的网络</p><p>主机号： 用于识别该网络中的主机</p><p>IP地址分为五类,各类可容纳的地址数目不同。</p><p>A类保留给政府机构</p><p>B类分配给中等规模的公司</p><p>C类分配给任何需要的人</p><p>D类用于<a href="http://baike.baidu.com/view/492256.htm">组播</a>   </p><p>E类用于实验 </p><p>A、B、C三类IP地址的特征：当将IP地址写成<a href="http://baike.baidu.com/view/18536.htm">二进制</a>形式时，A类地址的第一位总是0，B类地址的前两位总是10，C类地址的前三位总是110</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204230758874.png"></p><p>在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是网络号，后面一部分是主机号</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204230821087.png" alt="image-20201204230821087"></p><p>这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B 类地址能包含的最大主机数量又太多了。6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</p><h4 id="1-6-2-无类型域间选路（CIDR）"><a href="#1-6-2-无类型域间选路（CIDR）" class="headerlink" title="1.6.2 无类型域间选路（CIDR）"></a>1.6.2 无类型域间选路（CIDR）</h4><p>10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号</p><p>网络地址:  子网范围内的第一个地址</p><p>广播地址:  子网范围内最后一个地址</p><p>网络号： 将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</p><p>主机号： 32  减去 网络号 = 主机号</p><h4 id="1-6-3-私有地址"><a href="#1-6-3-私有地址" class="headerlink" title="1.6.3 私有地址"></a>1.6.3 私有地址</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204234000602.png" alt="image-20201204234000602"></p><p>公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问。</p><h4 id="1-6-4-CIDR-子网划分"><a href="#1-6-4-CIDR-子网划分" class="headerlink" title="1.6.4 CIDR 子网划分"></a>1.6.4 CIDR 子网划分</h4><p>子网划分(subnetting)的优点:<br>1.减少网络流量<br>2.提高网络性能<br>3.简化管理<br>4.易于扩大地理范围</p><p><strong>2^9 = 512</strong></p><p><strong>2^8 = 256</strong></p><p><strong>2^7 = 128</strong>     </p><p><strong>2^6 = 64</strong></p><p><strong>2^5 = 32</strong></p><p><strong>2^3 = 8</strong></p><p><strong>2^0 = 1</strong></p><p>首先，我们看一个考试中常见的题型：一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址。<br>常规办法是把这个主机地址和子网掩码都换算成二进制数，两者进行逻辑与运算后即可得到网络地址。其实大家只要仔细想想，可以得到另一个方法：255.255.255.224的掩码所容纳的IP地址有256－224＝32个（包括网络地址和广播地址）</p><p>那么具有这种掩码的网络地址一定是32的倍数。而网络地址是子网IP地址的开始，广播地址是结束，可使用的主机地址在这个范围内，因此略小于137而又是32的倍数的只有128，所以得出网络地址是202.112.14.128。而广播地址就是下一个网络的网络地址减1。而下一个32的倍数是160，因此可以得到广播地址为202.112.14.159。</p><p>lo 全称是 loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现 </p><h4 id="1-6-5-MAC地址"><a href="#1-6-5-MAC地址" class="headerlink" title="1.6.5 MAC地址"></a>1.6.5 MAC地址</h4><p>在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。</p><p>MAC 地址是一个很容易让人“误解”的地址。因为 MAC 地址号称全局唯一，不会有两个网卡有相同的 MAC 地址，而且网卡自生产出来，就带着这个地址。很多人看到这里就会想，既然这样，整个互联网的通信，全部用 MAC 地址好了，只要知道了对方的 MAC 地址，就可以把信息传过去。这样当然是不行的。 一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能。 而有门牌号码属性的 IP 地址，才是有远程定位功能的。</p><p>所以MAC通信是有范围的，一般使局限在一个局域网里面，同局域网是可以通过MAC来通信的，一旦跨子网 </p><p>那么MAC地址就需要IP来帮忙了。</p><h4 id="1-6-6-网络设备的状态标识"><a href="#1-6-6-网络设备的状态标识" class="headerlink" title="1.6.6 网络设备的状态标识"></a>1.6.6 网络设备的状态标识</h4><p>UP 表示网卡处于启动的状态；</p><p>BROADCAST 表示这个网卡有广播地址，可以发送广播包；</p><p>MULTICAST 表示网卡可以发送多播包；</p><p>LOWER_UP 表示 L1 是启动的，也即网线插着呢 </p><p><strong>MTU1500 是指什么意思呢？是哪一层的概念呢？最大传输单元 MTU 为 1500，这是以太网的默认值。</strong></p><p>我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p><p><strong>qdisc pfifo_fast</strong>  </p><p>qdisc全称： queueing discipline 中文叫做排队队列，内核如果需要通过某个网络接口发送数据包，它都需要按照</p><p>为这个接口配置的 qdisc（排队规则）把数据报加入队列</p><p><strong>pfifo</strong></p><p>最简单的qdiso使 pfifo 他不对进入的数据做人任何的处理，数据报采用先入先出的方式通过队列，pfifo_fast 稍微复杂一点，他的队列包括三个波段(band),在每个波段里面，使用先进先出的规则</p><p>三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。</p><p>数据包是按照服务类型（Type of Service，TOS）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><h3 id="1-7-动态主机配置协议（DHCP）"><a href="#1-7-动态主机配置协议（DHCP）" class="headerlink" title="1.7 动态主机配置协议（DHCP）"></a>1.7 动态主机配置协议（DHCP）</h3><p>动态主机配置协议（Dynamic Host Configuration Protocol），简称 DHCP。</p><h4 id="1-7-1-解析dhcp工作方式"><a href="#1-7-1-解析dhcp工作方式" class="headerlink" title="1.7.1 解析dhcp工作方式"></a>1.7.1 解析dhcp工作方式</h4><p>当一台机器需要通过自己MAC地址，发送一个广播包，目的IP地址255.255.255.255</p><p>广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205012215824.png" alt="image-20201205012215824"></p><h4 id="1-7-2-如果有多个DHCP-server服务器"><a href="#1-7-2-如果有多个DHCP-server服务器" class="headerlink" title="1.7.2 如果有多个DHCP server服务器"></a>1.7.2 如果有多个DHCP server服务器</h4><p>它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。</p><h4 id="1-7-3-IP-地址的收回和续租"><a href="#1-7-3-IP-地址的收回和续租" class="headerlink" title="1.7.3 IP 地址的收回和续租"></a>1.7.3 IP 地址的收回和续租</h4><p>客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。</p><h4 id="1-7-4-预启动执行环境（PXE）"><a href="#1-7-4-预启动执行环境（PXE）" class="headerlink" title="1.7.4 预启动执行环境（PXE）"></a>1.7.4 预启动执行环境（PXE）</h4><p>我们可以通过pxe来实现自动批量安装系统，这事儿其实仔细一想，还是挺有难度的。安装操作系统，应该有个光盘吧。数据中心里不能用光盘吧，想了一个办法就是，可以将光盘里面要安装的操作系统放在一个服务器上，让客户端去下载。但是客户端放在哪里呢？它怎么知道去哪个服务器上下载呢？客户端总得安装在一个操作系统上呀，可是这个客户端本来就是用来安装操作系统的呀？</p><p>其实，这个过程和操作系统启动的过程有点儿像。首先，启动 BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的 MBR 启动扇区，将 GRUB 启动起来；然后将权力交给 GRUB，GRUB 加载内核、加载作为根文件系统的 initramfs 文件；然后将权力交给内核；最后内核启动，初始化整个操作系统</p><p>我们需要DHCP server 有一段这样的配置</p><pre><code class="hljs shell">ddns-update-style interim;ignore client-updates;allow booting;allow bootp;subnet 192.168.1.0 netmask 255.255.255.0&#123;option routers 192.168.1.1;option subnet-mask 255.255.255.0;option time-offset -18000;default-lease-time 21600;max-lease-time 43200;range dynamic-bootp 192.168.1.240 192.168.1.250;filename &quot;pxelinux.0&quot;;       #需要下载的启动文件filenamenext-server 192.168.1.180;   #指向pxe服务器的地址&#125;</code></pre><p>pxe 工作执行流程</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201205011046135.png" alt="image-20201205011046135"></p><p>注意： <strong>安装完成后，将提示重新引导计算机。在重新引导的过程中将BIOS修改回从硬盘启动就可以了。</strong></p><p>参考:<br><a href="https://time.geekbang.org/column/intro/85">https://time.geekbang.org/column/intro/85</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp/ip 协议簇笔记</title>
    <link href="/2020/12/04/tcp-ip-%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/04/tcp-ip-%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>tcp/ip 协议簇它是基于tcp/ip协议，但是它并不仅限于tcp/ip 俩种协议,他是一个协议的泛指 </p><p>它还包括很多其他的协议,同时也分为好多层，同层之间使用相同的协议，这样体现了分层的好处</p><p>每一层只是处理自己层的协议</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204002233544.png" alt="image-20201204002233544"></p><h3 id="网络协议群"><a href="#网络协议群" class="headerlink" title="网络协议群"></a>网络协议群</h3><table><thead><tr><th>协议名称</th><th>具体协议</th></tr></thead><tbody><tr><td>应用协议</td><td>HTTP,SMTP, FTP,TELNET</td></tr><tr><td>传输协议</td><td>TCP/UDP</td></tr><tr><td>网络协议</td><td>IP/ICMP/ARP</td></tr><tr><td>路由控制协议</td><td>RIP/OSPF/BGP</td></tr></tbody></table><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位；</li></ul><p>每个层都会对所发送的数据附加一个首部，在这个首部包含了该层的必要信息，在下一层的角度看，从上一层</p><p>收到的包全部都被认为是本层的数据 </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204002515998.png" alt="image-20201204002515998"></p><h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP</p><p>TCP 提供一种面向连接的，可靠的字节流服务，流就是指不间断的数据结构</p><p>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下</p><p>虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><h3 id="TCP协议机制"><a href="#TCP协议机制" class="headerlink" title="TCP协议机制"></a>TCP协议机制</h3><ol><li><p>在一个tcp连接中，仅仅有俩方进行彼此通信，应用数据被分割成tcp认为最适合发送的数据块</p></li><li><p>当tcp发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段</p></li><li><p>当tcp收到发自tcp连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常推迟几分之一秒 deplayed ack</p></li><li><p>tcp 将保持它首部和数据的检验和 </p></li><li><p>既然tcp报文段作为ip数据报来传输，而IP数据报的到达可能会失序，如果有必要，tcp将对收到的数据进行重新排序</p></li><li><p>将收到的数据以正确的顺序交给应用层</p></li><li><p>基于全双工来进行工作</p></li></ol><h3 id="端口号和通信识别"><a href="#端口号和通信识别" class="headerlink" title="端口号和通信识别"></a>端口号和通信识别</h3><p>用于标记进程 范围在0-65535,通过五元组来识别一个通信</p><ul><li><p>知名端口号： 分布在 0~1023 之间 </p></li><li><p>端口号被正式注册：它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</p></li><li><p>Socket： 是由ip和port组合而成</p></li><li><p>五元组： 源地址，源端口，协议号，目标地址，目标端口</p></li><li><p>MTU: 网络最大传输单元</p></li></ul><h3 id="ip-header-首部"><a href="#ip-header-首部" class="headerlink" title="ip header 首部"></a>ip header 首部</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204005020380.png"></p><ul><li>Version： ip版本号</li><li>HeaderLength： 首部长度，每四个字节当做一个单位，最大位60</li><li>TypeofServer(TOS): 确保某些紧急报文可以优先到达，服务类型 (8bits)</li><li>TotalLength: 报文总长度</li><li>Identification: 每一个ip包都有一个唯一id，如果IP包被再次拆分 那么被拆分的ip包 id都是一致的</li><li>Fragment Offset: 偏移量，分片后，片与片之间的 片偏移量<ul><li>MF: 这个片已经分了好多片</li><li>DF：别分片，说明报文不允许分片</li></ul></li><li>TTL： 定义一个生命周期</li><li>Protocol：标记IP包内层协议类型,TCP 协议号6 ,UDP 的协议号17,ICMP 的协议号1,IGMP 协议号2</li><li>HeaderChecksum： 首部校验，靠tcp重转</li></ul><h3 id="tcp-header-首部"><a href="#tcp-header-首部" class="headerlink" title="tcp header 首部"></a>tcp header 首部</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204005815968.png" alt="image-20201204005815968"></p><ul><li>SequenceNumber: 每次发送报文号码，等待对方进行确认 </li><li>ACknowlegement： 确认报文号码</li><li>Reserved： 预留位</li><li>FIN： 结束标记</li><li>SYN：发送进行同步</li><li>RST: 重置</li><li>PSH： 推送</li><li>ACK:   回复确认报文</li><li>URG: 不缓冲，尽快发送到内核处理</li><li>Urgent Pointer：紧急指针 值为1代表URG生效，值为0代表不生效</li><li>TcpChecksum： tcp的校验码</li><li>有限状态机 FSM Finite State Machine</li></ul><h2 id="tcp-三次握手四次断开"><a href="#tcp-三次握手四次断开" class="headerlink" title="tcp 三次握手四次断开"></a>tcp 三次握手四次断开</h2><p>tcp连接是全双工的，俩个信道，各自断开各自的信道，所以需要四次断开</p><p>最后断开会等待2ml时间,一般是120s</p>]]></content>
    
    
    <categories>
      
      <category>tcp/ip</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 自定义域名和主题</title>
    <link href="/2020/12/03/hexo-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/"/>
    <url>/2020/12/03/hexo-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>在之前已经部署博客环境，用hexo初始化博客项目，并且已经把博客托管到了github上，通过github提供的二级域名进行访问</p><p>我们自己如果有域名，还可以绑定自己的域名进行访问博客，域名可以通过阿里云进行购买</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>这里我们通过阿里云进行购买吧，因为阿里云收购了万网，万网算是国内最大的域名注册商</p><p>购买地址: <a href="https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com">https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com</a></p><p>我这里之前购买过域名 budongshu.cn ,下面准备想使用budongshu.cn来访问这个博客</p><p><code>注意</code>: <strong>现在大部门域名都是需要 实名认证和备案的，备案的话一般需要3天到7天左右</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203102813448.png" alt="image-20201203102813448"></p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>这里面有俩种配置方法，但是原理都是一样的</p><p>通过cname 来配置 我们现在配置一个@的cname解析和www的cname解析 这样我再浏览器里面输入budongshu.cn(配置@的cname解析起的作用)和<a href="http://www.budongshu.cn/">www.budongshu.cn</a> 都会解析到budongshu.github.io 也符合我们的预期效果</p><h3 id="第一种通过cname方式"><a href="#第一种通过cname方式" class="headerlink" title="第一种通过cname方式"></a>第一种通过cname方式</h3><p>配置@的cname解析 ，解析记录值是我现在用的访问域名budongshu.github.io </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203102904219.png"></p><p>配置www的cname解析 ，解析记录值是我现在用的访问域名budongshu.github.io </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103112447.png" alt="image-20201203103112447"></p><p>最后的配置效果</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103333548.png" alt="image-20201203103333548"></p><h3 id="第二种通过解析出来的ip来配置，A记录方式"><a href="#第二种通过解析出来的ip来配置，A记录方式" class="headerlink" title="第二种通过解析出来的ip来配置，A记录方式"></a>第二种通过解析出来的ip来配置，A记录方式</h3><p>先通过ping budongshu.github.io 看一下解析ip是多少，我们这里看到是185.199.111.153 ,那么我们同样可以通过A记录的方式</p><p>来配置跳转</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103428622.png" alt="image-20201203103428622"></p><p>做一个www配置的演示 </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103636825.png" alt="image-20201203103636825"></p><h2 id="在hexo项目里面设置CNAME"><a href="#在hexo项目里面设置CNAME" class="headerlink" title="在hexo项目里面设置CNAME"></a>在hexo项目里面设置CNAME</h2><h3 id="1-1-新建文件CNAME"><a href="#1-1-新建文件CNAME" class="headerlink" title="1.1  新建文件CNAME"></a>1.1  新建文件CNAME</h3><p>在项目下，进入你的博客项目目录，在source 文件夹下面创建 CNAME 文件（没有后缀名的），填写上域名</p><p>可以通过编辑器进行编辑</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104545764.png" alt="image-20201203104545764"></p><h3 id="1-2-部署博客项目到github"><a href="#1-2-部署博客项目到github" class="headerlink" title="1.2 部署博客项目到github"></a>1.2 部署博客项目到github</h3><p> 然后我们部署hexo，通过项目里面的配置会上传到github，这里不明白可以看看我之前hexo 部署文章</p><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g -d</code></pre><h3 id="1-3-Github-要把https选项勾上"><a href="#1-3-Github-要把https选项勾上" class="headerlink" title="1.3 Github 要把https选项勾上"></a>1.3 Github 要把https选项勾上</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203105005191.png" alt="image-20201203105005191"></p><h2 id="用自定义的域名访问"><a href="#用自定义的域名访问" class="headerlink" title="用自定义的域名访问"></a>用自定义的域名访问</h2><p>完成上述步骤之后就可以在浏览器输入自己的域名访问了,因为我们配置了@ 和www 所以通过下面俩种方式访问</p><p><a href="https://budongshu.cn/">https://budongshu.cn</a> 和 <a href="https://www.budongshu.cn/">https://www.budongshu.cn</a> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203105252124.png" alt="image-20201203105252124"></p><h2 id="找一款自己喜欢的主题"><a href="#找一款自己喜欢的主题" class="headerlink" title="找一款自己喜欢的主题"></a>找一款自己喜欢的主题</h2><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a> ,这个里面有很多主题，可以任意挑选一个自己喜欢的主题，点击进去通常都有github地址</p><p>上面有安装和使用方法介绍，我这里选了一个名叫“fluid” 的主题，这是使用地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>下面截图是fluid使用介绍的部分内容</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104039041.png" alt="image-20201203104039041"></p><p> 主题效果</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104225967.png" alt="image-20201203104225967"></p><p>可以看到已经实现自定义主题了，主题这里还有很多可以自己设置的地方呢~</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 切片笔记</title>
    <link href="/2020/12/03/Go-%E5%88%87%E7%89%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/Go-%E5%88%87%E7%89%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是切片-slice"><a href="#什么是切片-slice" class="headerlink" title="什么是切片(slice)"></a>什么是切片(slice)</h2><p>slice和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生panic，但是它比数组更加的灵活，可以自动的进行扩容</p><h2 id="切片本质"><a href="#切片本质" class="headerlink" title="切片本质"></a>切片本质</h2><p>切片是由指针，长度，容量组成，切片并不是数组或者数组指针，它是通过内部指针和相关属性引用数组片段，来实现变长的方案</p><p><code>指针</code>：指向底层数组</p><p><code>长度</code>：表示切片可用元素的个数，也就是会用下标对slice进行访问时候，下标不能超过的长度 </p><p><code>容量</code>:   底层数组的元素个数，容量&gt;=长度，在底层数组不进行扩容的情况下，容量也是slice可以扩张的最大限度</p><h2 id="切片特点"><a href="#切片特点" class="headerlink" title="切片特点"></a>切片特点</h2><p>一个slice 是一个轻量级的数据结构，提供了访问数组子序列元素的功能</p><p>底层引用了一个数组对象，指针指向第一个slice元素对象的底层数组元素的地址 </p><p><code>注意</code>：底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice ,</p><p><strong>两个slice不能用==比较</strong></p><h2 id="切片和数组的区别"><a href="#切片和数组的区别" class="headerlink" title="切片和数组的区别"></a>切片和数组的区别</h2><p>slice切片底层是数组，slice是对数组的封装，它描述了一个数组的片段，俩者都可以用下标来访问元素</p><p>数组是固定长度的，长度定义好后，不能更改 </p><p>切片非常灵活，它可以动态扩容，切片的类型和长度无关</p><h2 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h2><ul><li><p>直接声明： var slice []int </p></li><li><p>字面量： slice1 := []int{1,2,3}</p></li><li><p>make:     slice1 :=make([]int,3,5)</p></li><li><p>new:       slice1 := *new([]int)</p></li><li><p>切片或者数组截取： slice1 := array1[1:4] or slice1 := slice2[1:3]</p></li></ul><h3 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h3><p>第一种直接声明创建的slice 是nil slice ，它的长度和容量都为0，和nil 比较的结果为true</p><pre><code class="hljs go"><span class="hljs-keyword">package</span>  main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s1 []<span class="hljs-keyword">int</span>fmt.Println(s1 == <span class="hljs-literal">nil</span>)&#125;<span class="hljs-comment">//result</span><span class="hljs-literal">true</span></code></pre><p><strong>空切片</strong></p><pre><code class="hljs go">silce := <span class="hljs-built_in">make</span>( []<span class="hljs-keyword">int</span> , <span class="hljs-number">0</span> )slice := []<span class="hljs-keyword">int</span>&#123; &#125;</code></pre><p><code>注意</code>：空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素</p><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code class="hljs go">s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>:<span class="hljs-number">10</span>&#125;s3 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;s4 := []<span class="hljs-keyword">int</span>&#123;&#125;  <span class="hljs-comment">//创建空切片</span>s5 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-number">99</span>: <span class="hljs-number">100</span>&#125;   <span class="hljs-comment">//初始化第100个元素</span>fmt.Println(s2,<span class="hljs-built_in">len</span>(s2),<span class="hljs-built_in">cap</span>(s2))<span class="hljs-comment">//</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>] <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-comment">//s2</span><span class="hljs-comment">//唯一值得注意的是上面的代码例子中使用了索引号,直接赋值 ,这样其他未注明的元素则默认 0 值</span></code></pre><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p><code>make</code>函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等</p><p>如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 <code>make</code> 关键字</p><p>创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 长度为5，容量为10</span>slice[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 索引为2的元素赋值为2</span>fmt.Println(slice)&#125;</code></pre><p>数组切片和切片的切片</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">//定义一个数组</span><span class="hljs-keyword">var</span> s6  = array[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">//[2,3,4] 左闭右开</span><span class="hljs-keyword">var</span> s7  = array[<span class="hljs-number">4</span>:] <span class="hljs-comment">//[5,6,0,0,0,0] </span><span class="hljs-keyword">var</span> s8 = array[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] <span class="hljs-comment">//data[low, high, max] low表示索引开始处闭区间，high表示len开区间，max表示容量开区间 结果分析 [3,4] -&gt; len=2,cap=4 </span>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">//定义一个切片</span>s10 := slice[:<span class="hljs-number">4</span>]  <span class="hljs-comment">//beginIndex如果为空则表示从0开始</span>s11 := slice[<span class="hljs-number">4</span>:]  <span class="hljs-comment">//endIndex如果为空则表示到数组最后一个元素</span><span class="hljs-keyword">var</span> <span class="hljs-number">12</span> = slice[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] <span class="hljs-comment">//data[low, high, max] low表示索引开始处闭区间，high表示len开区间，max表示容量开区间 </span></code></pre><h2 id="append追加元素"><a href="#append追加元素" class="headerlink" title="append追加元素"></a>append追加元素</h2><p>append会返回新的slice，append返回值必须使用否则编译器会报错</p><pre><code class="hljs go">slice := <span class="hljs-built_in">append</span>(slice, elem1, elem2)    <span class="hljs-comment">//可以传入多个元素</span>slice := <span class="hljs-built_in">append</span>(slice, slice_other...)  <span class="hljs-comment">//可以传入一个切片 切片后面要加三个点 ...</span></code></pre><h2 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice1 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>&#125;out := slice1[:]out1 := slice1fmt.Printf(<span class="hljs-string">&quot;out=%v,p=%p\n&quot;</span>,out,&amp;out)fmt.Printf(<span class="hljs-string">&quot;out1=%v,p=%p&quot;</span>,out1,&amp;out1)&#125;<span class="hljs-comment">//output</span>out=[a n],p=<span class="hljs-number">0xc00000c0a0</span>out1=[a n],p=<span class="hljs-number">0xc00000c0c0</span></code></pre><h2 id="copy切片"><a href="#copy切片" class="headerlink" title="copy切片"></a>copy切片</h2><pre><code class="hljs go">由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;array := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">6</span>)n := <span class="hljs-built_in">copy</span>(slice, array)fmt.Println(n,slice)&#125;</code></pre><h2 id="for-range"><a href="#for-range" class="headerlink" title="for- range"></a>for- range</h2><p>for循环会对slice元素值一次拷贝到item。更改item中的值不会改变原slice的元素值</p><pre><code class="hljs go">slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> slice &#123;    item++&#125;fmt.Println(slice)<span class="hljs-comment">//output: [1,2,3]</span></code></pre><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>函数传slice是引用传参，修改被调函数的值，调用函数的slice也会改变。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;    test(slice)    fmt.Println(slice)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span></span> &#123;    a[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>&#125;<span class="hljs-comment">//output [1,100,3]</span></code></pre><h2 id="切片坑和困惑"><a href="#切片坑和困惑" class="headerlink" title="切片坑和困惑"></a>切片坑和困惑</h2><ul><li>切片做函数参数是传引用</li><li>append扩容问题，append 函数会创建一个新的底层数组,拷贝已存在的值和将要被附加的新值</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">s</span><span class="hljs-params">(s []<span class="hljs-keyword">string</span>)</span></span> &#123;    <span class="hljs-comment">//切片是引用传参</span>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;bds:234&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 :=[]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;123&quot;</span>&#125;s(s1)fmt.Println(s1)&#125; <span class="hljs-comment">//output</span>[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>][bds:<span class="hljs-number">234</span>]<span class="hljs-comment">/*</span><span class="hljs-comment">切片做函数参数的时候，是使用传引用（也就是传地址）</span><span class="hljs-comment">相当于是指针指向的内存地址这个引用，由于指向的是同一块内存地址，</span><span class="hljs-comment">所以在函数内部通过s[0] = &quot;bds:234&quot; 修改切片，最后修改成功</span><span class="hljs-comment">*/</span></code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;   y := s[:<span class="hljs-number">1</span>]   <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s  &#123;      y = <span class="hljs-built_in">append</span>(y,v)   &#125;   <span class="hljs-keyword">return</span> y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;   newS := myAppend(s)   fmt.Println(s)   fmt.Println(newS)&#125;<span class="hljs-comment">//output: </span>[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>][<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add2Slice</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, t <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span>&#123;s[<span class="hljs-number">0</span>]++s1 := <span class="hljs-built_in">append</span>(s, t)<span class="hljs-comment">//fmt.Println(&quot;s1&quot;,s1)</span>s[<span class="hljs-number">0</span>]++<span class="hljs-keyword">return</span> s1&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;c := Add2Slice(a, <span class="hljs-number">4</span>)fmt.Println(c)fmt.Println(<span class="hljs-string">&quot;a&quot;</span>, a)b := Add2Slice(a, <span class="hljs-number">5</span>)fmt.Println(b)d := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>&#125;nd := <span class="hljs-built_in">append</span>(d, <span class="hljs-number">3</span>)fmt.Printf(<span class="hljs-string">&quot;d=%v,P = %p\n&quot;</span>, d, &amp;d)fmt.Printf(<span class="hljs-string">&quot;nd=%v,P = %p &quot;</span>, nd, &amp;nd)&#125;<span class="hljs-comment">//output</span>[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]a [<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>][<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>]d=[<span class="hljs-number">1</span>],P = <span class="hljs-number">0xc0000a6080</span>nd=[<span class="hljs-number">1</span> <span class="hljs-number">3</span>],P = <span class="hljs-number">0xc0000a60a0</span> </code></pre><h3 id="群里热心大佬分享一个考题"><a href="#群里热心大佬分享一个考题" class="headerlink" title="群里热心大佬分享一个考题"></a>群里热心大佬分享一个考题</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/17631606914834_.pic_hd.jpg" alt="17631606914834_.pic_hd"></p><pre><code class="hljs go">我的思路：s2 = s1 此时 是相同的内存地址 相当于复制拷贝一份<span class="hljs-built_in">append</span> 操作了 s2 按照<span class="hljs-keyword">go</span>的扩容规则，内存地址改变，指针指向随之发生改变 进入函数s  = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">0</span>) 操作s1 时候， s1被扩容，地址发生改变，所以后面s[i]++操作的是扩容后新地址切片 所以s1 还是 <span class="hljs-number">12</span> slice 形参是传引用 相当于指针变量进行复制一份，但是指针指向的内存地址是相同的 ，所以后面操作s[<span class="hljs-number">0</span>]++ 相当于通过修改了内存地址里面的变量值，所以会s[i]++生效进入函数s  = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">0</span>) 操作s2的时候，根据扩容规则，容量满足，地址没有发生改变，所有后面操作的是原地址切片，值s[i]++ s2 变成<span class="hljs-number">234</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go map笔记</title>
    <link href="/2020/12/03/Go-map%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/Go-map%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-map类型"><a href="#1-map类型" class="headerlink" title="1. map类型"></a>1. map类型</h2><p>map是一个无序的基于key-value的数据结构，复合数据类型，map是引用类型，必须初始化才能使用</p><h2 id="2-map-语法"><a href="#2-map-语法" class="headerlink" title="2. map 语法"></a>2. map 语法</h2><pre><code class="hljs go"><span class="hljs-keyword">map</span>[keyType]ValueType</code></pre><p>其中： </p><ul><li>keyType: 表示键的类型</li><li>ValueType: 表示键对应的值类型</li></ul><p>map类型的变量默认初始值是nil,需要使用make()函数来分配内存，语法： </p><p><strong>make: 用于slice ，map ，和channle 的初始化，相当于申请一块内存空间</strong></p><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]ValueType,[<span class="hljs-built_in">cap</span>])</code></pre><p>其中cap 表示map的容量，该参数不是必须要配置的 </p><h2 id="3-map定义"><a href="#3-map定义" class="headerlink" title="3. map定义"></a>3. map定义</h2><h3 id="3-1-直接声明"><a href="#3-1-直接声明" class="headerlink" title="3.1 直接声明"></a>3.1 直接声明</h3><p>在声明的时候，在进行填充元素</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo1 = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;bds1&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;19&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>,&#125;</code></pre><h3 id="3-2-字面量"><a href="#3-2-字面量" class="headerlink" title="3.2 字面量"></a>3.2 字面量</h3><p>类型推导</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;userinfo2 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;bds2&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>,&#125;  fmt.Println(userinfo2)&#125;</code></pre><h3 id="3-3-make关键字"><a href="#3-3-make关键字" class="headerlink" title="3.3 make关键字"></a>3.3 make关键字</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>,<span class="hljs-number">10</span>)   <span class="hljs-comment">//长度也可以不指定</span>userinfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span><span class="hljs-comment">//进行赋值操作</span>userinfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-string">&quot;18&quot;</span>fmt.Println(userinfo[<span class="hljs-string">&quot;name&quot;</span>])&#125;</code></pre><h2 id="4-map-类型crud"><a href="#4-map-类型crud" class="headerlink" title="4 map 类型crud"></a>4 map 类型crud</h2><p>针对map类型的 增删改查</p><h3 id="4-1-for循环获取键值"><a href="#4-1-for循环获取键值" class="headerlink" title="4.1 for循环获取键值"></a>4.1 for循环获取键值</h3><pre><code class="hljs go"><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> userinfo2 &#123;  fmt.Printf(<span class="hljs-string">&quot;key: %v,value: %v\n&quot;</span>,k,v)&#125;</code></pre><h3 id="4-2-创建和更新map数据"><a href="#4-2-创建和更新map数据" class="headerlink" title="4.2 创建和更新map数据"></a>4.2 创建和更新map数据</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;userinfo := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bds&quot;</span>, <span class="hljs-comment">//创建值操作</span><span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>,&#125;userinfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;dsb&quot;</span>       <span class="hljs-comment">//更新值操作</span>fmt.Println(userinfo)&#125;<span class="hljs-comment">//map[age:21 name:dsb]</span></code></pre><h3 id="4-3-获取和查找map-数据"><a href="#4-3-获取和查找map-数据" class="headerlink" title="4.3 获取和查找map 数据"></a>4.3 获取和查找map 数据</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;userinfo := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;dsb&quot;</span>, <span class="hljs-comment">//创建值操作</span><span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>,&#125;fmt.Println(userinfo)v, ok := userinfo[<span class="hljs-string">&quot;name&quot;</span>]     <span class="hljs-comment">//这里通过一个布尔值判断有没有数据</span>fmt.Println(v,ok)             <span class="hljs-comment">//打印： dsb true</span>v1, ok1 := userinfo[<span class="hljs-string">&quot;xxx&quot;</span>]fmt.Println(v1,ok1)           <span class="hljs-comment">//打印： 空和false</span>&#125;</code></pre><h3 id="4-4-删除map数据"><a href="#4-4-删除map数据" class="headerlink" title="4.4 删除map数据"></a>4.4 删除map数据</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;userinfo := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>,<span class="hljs-string">&quot;height&quot;</span>: <span class="hljs-string">&quot;180&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>,&#125;fmt.Println(userinfo)<span class="hljs-built_in">delete</span>(userinfo,<span class="hljs-string">&quot;sex&quot;</span>)      <span class="hljs-comment">//删除</span>fmt.Println(userinfo)&#125;<span class="hljs-comment">//map[age:21 height:180 name:bds sex:男]</span><span class="hljs-comment">//map[age:21 height:180 name:bds]</span></code></pre><h2 id="5-map类型与其他类型使用"><a href="#5-map类型与其他类型使用" class="headerlink" title="5 map类型与其他类型使用"></a>5 map类型与其他类型使用</h2><h3 id="5-1-元素为map类型的切片"><a href="#5-1-元素为map类型的切片" class="headerlink" title="5.1 元素为map类型的切片"></a>5.1 元素为map类型的切片</h3><p>想要在切片放一系列的<code>信息</code>，这时候我们就可以定一个<code>map</code>类型的<code>切片</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//1 第一种通过make来创建</span><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<span class="hljs-keyword">if</span> userinfo[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;userinfo[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)userinfo[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span>userinfo[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-string">&quot;19&quot;</span>userinfo[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;height&quot;</span>] = <span class="hljs-string">&quot;180&quot;</span>      userinfo[<span class="hljs-number">1</span>] = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;budongshu&quot;</span>,        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>,        <span class="hljs-string">&quot;height&quot;</span>: <span class="hljs-string">&quot;130&quot;</span>,    &#125;&#125;  fmt.Println(userinfo)  <span class="hljs-comment">//[map[age:19 height:180 name:bds] map[age:20 height:130 name:budongshu] map[]]</span>  <span class="hljs-comment">//最后会有一个空map 因为我们定义切片的时候 设置长度为3 </span>      <span class="hljs-comment">// 2 第二种创建方式</span>s1 := []<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bds1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;19&quot;</span>,&#125;&#125;fmt.Println(s1)s1[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;bds2&quot;</span>fmt.Println(s1) &#125;</code></pre><h3 id="5-2-通过for-循环获取切片中的map"><a href="#5-2-通过for-循环获取切片中的map" class="headerlink" title="5.2 通过for 循环获取切片中的map"></a>5.2 通过for 循环获取切片中的map</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 := []<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> &#123;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bds1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;19&quot;</span>,&#125;&#125;fmt.Println(s1)s1[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;bds2&quot;</span>fmt.Println(s1)<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s1 &#123;   fmt.Println(v)   <span class="hljs-keyword">for</span> k,v  :=  <span class="hljs-keyword">range</span> v &#123;      fmt.Printf(<span class="hljs-string">&quot;key: %v,Value: %v\n&quot;</span>,k,v)   &#125; &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">[map[age:19 name:bds1]]</span><span class="hljs-comment">[map[age:19 name:bds2]]</span><span class="hljs-comment">map[age:19 name:bds2]</span><span class="hljs-comment">key: name,Value: bds2</span><span class="hljs-comment">key: age,Value: 19</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-3-map-值为切片类型"><a href="#5-3-map-值为切片类型" class="headerlink" title="5.3 map 值为切片类型"></a>5.3 map 值为切片类型</h3><p>想要在map的值中放一系列<code>属性</code>，这时候我们就可以定一个<code>map</code>类型的<code>值</code>类型为：<code>切片</code></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>)m1[<span class="hljs-string">&quot;bobby&quot;</span>] = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;cf&quot;</span>,<span class="hljs-string">&quot;cs&quot;</span>,<span class="hljs-string">&quot;play game&quot;</span>,<span class="hljs-string">&quot;do girl&quot;</span>,&#125;m1[<span class="hljs-string">&quot;work&quot;</span>] = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;golang&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>,&#125;fmt.Println(m1)<span class="hljs-comment">//map[bobby:[cf cs play game do girl] work:[golang python]]</span></code></pre><p>对上面的数据进行for循环</p><pre><code class="hljs go"><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> m1 &#123;fmt.Println(v)<span class="hljs-keyword">for</span> _,val := <span class="hljs-keyword">range</span> v &#123;fmt.Println(val)&#125;</code></pre><h2 id="6-map类型-引用数据类型"><a href="#6-map类型-引用数据类型" class="headerlink" title="6 map类型 引用数据类型"></a>6 map类型 引用数据类型</h2><p>值类型：改变变量副本值的时候，不会改变变量本身的值 （<code>基本数据类型</code>，<code>数组</code>）</p><p>引用类型： 改变变量副本值的时候，会改变变量本身的值 （<code>切片</code>，<code>map</code>）</p><h2 id="7-map-类型的一些使用"><a href="#7-map-类型的一些使用" class="headerlink" title="7 map 类型的一些使用"></a>7 map 类型的一些使用</h2><h3 id="7-1-按照map的-key-升级"><a href="#7-1-按照map的-key-升级" class="headerlink" title="7.1 按照map的 key 升级"></a>7.1 按照map的 key 升级</h3><p>让其输出map的 key =&gt; value</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sort&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)m1[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>m1[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span>m1[<span class="hljs-number">10</span>] = <span class="hljs-number">1</span>m1[<span class="hljs-number">2</span>] = <span class="hljs-number">40</span>m1[<span class="hljs-number">20</span>] = <span class="hljs-number">3</span>m1[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span><span class="hljs-keyword">var</span> s1  []<span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> key,_ := <span class="hljs-keyword">range</span> m1 &#123;s1 = <span class="hljs-built_in">append</span>(s1,key)&#125; fmt.Println(m1)fmt.Println(s1)sort.Ints(s1)fmt.Println(s1)<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s1&#123;fmt.Printf(<span class="hljs-string">&quot;key: %v,value: %v\n&quot;</span>,v,m1[v])&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">key: 1,value: 10</span><span class="hljs-comment">key: 2,value: 40</span><span class="hljs-comment">key: 3,value: 2</span><span class="hljs-comment">key: 5,value: 5</span><span class="hljs-comment">key: 10,value: 1</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre><h3 id="7-2-计算字符串中单词的次数"><a href="#7-2-计算字符串中单词的次数" class="headerlink" title="7.2 计算字符串中单词的次数"></a>7.2 计算字符串中单词的次数</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&quot;how do you do&quot;</span>s2 := strings.Split(s1,<span class="hljs-string">&quot; &quot;</span>)fmt.Println(s2)map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s2 &#123;map1[v]++&#125;fmt.Println(map1)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">[how do you do]</span><span class="hljs-comment">map[do:2 how:1 you:1]</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubadm1.18部署笔记</title>
    <link href="/2020/12/03/kubadm1-18%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/kubadm1-18%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>系统: CentOS Linux release 7.8.2003 (Core)</p><p>内核:  4.4.241-1.el7.elrepo.x86_64</p><p>k8s版本： 1.18  </p><p>calico：3.17</p><h2 id="升级内核脚本"><a href="#升级内核脚本" class="headerlink" title="升级内核脚本"></a>升级内核脚本</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 载入公钥</span>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<span class="hljs-meta">#</span><span class="bash"> 安装ELRepo</span>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="hljs-meta">#</span><span class="bash"> 载入elrepo-kernel元数据</span>yum --disablerepo=\* --enablerepo=elrepo-kernel repolist<span class="hljs-meta">#</span><span class="bash"> 查看可用的rpm包</span>yum --disablerepo=\* --enablerepo=elrepo-kernel list kernel*<span class="hljs-meta">#</span><span class="bash"> 安装长期支持版本的kernel</span>yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt.x86_64<span class="hljs-meta">#</span><span class="bash"> 删除旧版本工具包</span>yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64 -y<span class="hljs-meta">#</span><span class="bash"> 安装新版本工具包</span>yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64<span class="hljs-meta">#</span><span class="bash">查看默认启动顺序</span>awk -F\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print $2&#125;&#x27; /etc/grub2.cfg<span class="hljs-meta">#</span><span class="bash">默认启动的顺序是从0开始，新内核是从头插入（目前位置在0，而4.4.4的是在1），所以需要选择0。</span>grub2-set-default 0</code></pre><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">yum</span>yum install wget curl openssl openssh lrzsz<span class="hljs-meta">#</span><span class="bash"> 关掉防火墙</span>systemctl stop firewalld &amp;&amp; systemctl disable firewalld<span class="hljs-meta">#</span><span class="bash"> 关掉NetManager网络管理</span>systemctl stop NetworkManager &amp;&amp; systemctl disable NetworkManager <span class="hljs-meta">#</span><span class="bash"> selinux</span>setenforce 0sed -i &quot;s#=enforcing#=disabled#g&quot; /etc/selinux/config<span class="hljs-meta">#</span><span class="bash"> 关闭swap</span>swapoff -a &amp;&amp; sysctl -w vm.swappiness=0sed -ri &#x27;/^[^#]*swap/s@^@#@&#x27; /etc/fstab<span class="hljs-meta">#</span><span class="bash"> 修改yum源</span>sed -e &#x27;s!^#baseurl=!baseurl=!g&#x27;        -e  &#x27;s!^mirrorlist=!#mirrorlist=!g&#x27;        -e &#x27;s!mirror.centos.org!mirrors.ustc.edu.cn!g&#x27;        -i  /etc/yum.repos.d/CentOS-Base.repo<span class="hljs-meta">#</span><span class="bash"> epel源</span>yum install -y epel-release sed -e &#x27;s!^mirrorlist=!#mirrorlist=!g&#x27; -e &#x27;s!^#baseurl=!baseurl=!g&#x27; -e &#x27;s!^metalink!#metalink!g&#x27; -e &#x27;s!//download\.fedoraproject\.org/pub!//mirrors.ustc.edu.cn!g&#x27; -e &#x27;s!http://mirrors\.ustc!https://mirrors.ustc!g&#x27; -i /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel-testing.repo</code></pre><h2 id="yum-安装依赖和工具"><a href="#yum-安装依赖和工具" class="headerlink" title="yum 安装依赖和工具"></a>yum 安装依赖和工具</h2><pre><code class="hljs shell">yum install ipvsadm ipset sysstat conntrack libseccomp  curl git conntrack-tools  psmisc     nfs-utils jq socat  bash-completion ipset ipvsadm  conntrack  libseccomp net-tools crontabs  sysstat  unzip iftop  nload  strace  bind-utils  tcpdump  telnet  lsof htop -y</code></pre><h2 id="系统优化配置"><a href="#系统优化配置" class="headerlink" title="系统优化配置"></a>系统优化配置</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">---ipvs模式需要开机加载下列模块---</span>echo &quot;ipvs模式需要开机加载下列模块&quot;<span class="hljs-meta">cat&gt;</span><span class="bash">/etc/modules-load.d/ipvs.conf&lt;&lt;<span class="hljs-string">EOF</span></span>ip_vsip_vs_rrip_vs_wrrip_vs_shnf_conntrackbr_netfilterEOFsystemctl daemon-reloadsystemctl enable --now systemd-modules-load.service<span class="hljs-meta">#</span><span class="bash">---内核参数</span>cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 10net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1net.ipv4.neigh.default.gc_stale_time = 120net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2net.ipv4.ip_forward = 1net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-arptables = 1net.netfilter.nf_conntrack_max = 2310720fs.inotify.max_user_watches=89100fs.may_detach_mounts = 1fs.file-max = 52706963fs.nr_open = 52706963vm.swappiness = 0vm.overcommit_memory=1vm.panic_on_oom=0EOFsysctl --system<span class="hljs-meta">#</span><span class="bash">---优化设置 journal 日志相关---</span>sed -ri &#x27;s/^\$ModLoad imjournal/#&amp;/&#x27; /etc/rsyslog.confsed -ri &#x27;s/^\$IMJournalStateFile/#&amp;/&#x27; /etc/rsyslog.confsed -ri &#x27;s/^#(DefaultLimitCORE)=/\1=100000/&#x27; /etc/systemd/system.confsed -ri &#x27;s/^#(DefaultLimitNOFILE)=/\1=100000/&#x27; /etc/systemd/system.confsed -ri &#x27;s/^#(UseDNS )yes/\1no/&#x27; /etc/ssh/sshd_config<span class="hljs-meta">#</span><span class="bash">---优化文件最大打开数---</span><span class="hljs-meta">cat&gt;</span><span class="bash">/etc/security/limits.d/kubernetes.conf&lt;&lt;<span class="hljs-string">EOF</span></span>*       soft    nproc   131072*       hard    nproc   131072*       soft    nofile  131072*       hard    nofile  131072root    soft    nproc   131072root    hard    nproc   131072root    soft    nofile  131072root    hard    nofile  131072EOF</code></pre><h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> add yum 源</span>curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.reposed -i &#x27;s#download.docker.com#mirrors.ustc.edu.cn/docker-ce#g&#x27; /etc/yum.repos.d/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> yum</span> yum -y install docker-ce bash-completioncp /usr/share/bash-completion/completions/docker /etc/bash_completion.d/<span class="hljs-meta">#</span><span class="bash"> check 脚本</span>curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh &gt; check-config.shbash ./check-config.sh<span class="hljs-meta">#</span><span class="bash">---设置user_namespace.enable=1---</span>grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</code></pre><h3 id="docker-daemon-json"><a href="#docker-daemon-json" class="headerlink" title="docker daemon.json"></a>docker daemon.json</h3><pre><code class="hljs shell">&#123;    &quot;log-driver&quot;: &quot;json-file&quot;,    &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;,        &quot;max-file&quot;: &quot;3&quot;    &#125;,    &quot;live-restore&quot;: true,    &quot;max-concurrent-downloads&quot;: 10,    &quot;max-concurrent-uploads&quot;: 10,    &quot;storage-driver&quot;: &quot;overlay2&quot;,    &quot;storage-opts&quot;: [        &quot;overlay2.override_kernel_check=true&quot;    ],    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],    &quot;registry-mirrors&quot;: [        &quot;https://docker.mirrors.ustc.edu.cn/&quot;    ]&#125;</code></pre><h3 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h3><pre><code class="hljs shell">systemctl enable --now dockersystemctl start docker</code></pre><h2 id="k8s-安装"><a href="#k8s-安装" class="headerlink" title="k8s 安装"></a>k8s 安装</h2><pre><code class="hljs shell">cat &gt; /etc/yum.repos.d/k8s.repo &lt;&lt;EOF[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF<span class="hljs-meta">#</span><span class="bash"> yum 1.18版本</span>yum install  kubelet-1.18* kubadm-1.18* kubctl-1.18*  -y<span class="hljs-meta">#</span><span class="bash"> k8s 服务启动</span>systemctl daemon-reloadsystemctl restart dockersystemctl enable kubeletsystemctl start kubelet<span class="hljs-meta">#</span><span class="bash"> k8s env</span>export MASTER_IP=10.1.1.21 export APISERVER_NAME=k8s-api<span class="hljs-meta">#</span><span class="bash"> 如果想重置，重新初始化请用下面命令</span> kubeadm reset</code></pre><h2 id="k8s-master节点初始化"><a href="#k8s-master节点初始化" class="headerlink" title="k8s master节点初始化"></a>k8s master节点初始化</h2><pre><code class="hljs shell">kubeadm init       --apiserver-advertise-address 0.0.0.0         --apiserver-bind-port 6443         --cert-dir /etc/kubernetes/pki         --control-plane-endpoint k8s-api         --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers         --kubernetes-version 1.18.12         --pod-network-cidr 10.11.0.0/16         --service-cidr 10.20.0.0/16         --service-dns-domain cluster.local         --upload-certs<span class="hljs-meta">#</span><span class="bash"> </span>rm -f ~/.kube &amp;&amp; mkdir ~/.kubecp -i /etc/kubernets/admin.conf ~/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config</code></pre><h2 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h2><pre><code class="hljs css"><span class="hljs-selector-tag">wget</span> <span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">docs</span><span class="hljs-selector-class">.projectcalico</span><span class="hljs-selector-class">.org</span>/<span class="hljs-selector-tag">v3</span>.17/<span class="hljs-selector-tag">manifests</span>/<span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span><span class="hljs-selector-tag">sed</span> <span class="hljs-selector-tag">-i</span> &quot;<span class="hljs-selector-tag">s</span><span class="hljs-selector-id">#192</span>\.168\.0\.0/16<span class="hljs-selector-id">#10</span>\.10\.0\.0/16#&quot; <span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">apply</span> <span class="hljs-selector-tag">-f</span> <span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span></code></pre><h2 id="kuboard"><a href="#kuboard" class="headerlink" title="kuboard"></a>kuboard</h2><pre><code class="hljs shell">kubectl apply -f https://kuboard.cn/install-script/kuboard.yamlkubectl get pods -l name=kuboard -n kube-systemkubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d &gt; admin-token.txt</code></pre><h2 id="k8s-check"><a href="#k8s-check" class="headerlink" title="k8s check"></a>k8s check</h2><pre><code class="hljs crmsh">kubelet get <span class="hljs-keyword">node</span> <span class="hljs-title"></span><span class="hljs-title">kubelet</span> get pods -A</code></pre><pre><code class="hljs shell">[root@k8s-01-21 ~]# kubectl get nodesNAME        STATUS     ROLES    AGE    VERSIONk8s-01-21   Ready      master   2d1h   v1.18.12k8s-02-22   NotReady   &lt;none&gt;   2d     v1.18.12k8s-03-23   NotReady   &lt;none&gt;   2d     v1.18.12<span class="hljs-meta">#</span><span class="bash"> </span>[root@k8s-01-21 ~]# kubectl get pods -ANAMESPACE     NAME                                       READY   STATUS        RESTARTS   AGEkube-system   calico-kube-controllers-8586758878-9z69l   1/1     Running       2      2dkube-system   calico-node-6wtfx                          1/1     Running       2      2dkube-system   calico-node-9qh4k                          0/1     Running       2      2dkube-system   calico-node-j7qqb                          1/1     Running       0      2dkube-system   coredns-546565776c-bfxtm                   1/1     Running       2      2d1hkube-system   coredns-546565776c-qx9h8                   1/1     Running       2      2d1hkube-system   etcd-k8s-01-21                             1/1     Running       4      2d1hkube-system   kube-apiserver-k8s-01-21                   1/1     Running       6      2d1hkube-system   kube-controller-manager-k8s-01-21          1/1     Running       11     2dkube-system   kube-proxy-28m7c                           1/1     Running       0      2dkube-system   kube-proxy-d6f6h                           1/1     Running       4      2d1hkube-system   kube-proxy-zmvkg                           1/1     Running       0      2dkube-system   kube-scheduler-k8s-01-21                   1/1     Running       11     2d1hkube-system   kuboard-7986796cf8-h8vjt                   1/1     Terminating   0      2dkube-system   kuboard-7986796cf8-k57jj                   1/1     Running       1      7m19skube-system   metrics-server-7f96bbcc66-7pzgp            0/1     Pending       0      7m19skube-system   metrics-server-7f96bbcc66-p48m9            1/1     Terminating   0      2d</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 介绍笔记</title>
    <link href="/2020/12/02/Go%E4%BB%8B%E7%BB%8D%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/02/Go%E4%BB%8B%E7%BB%8D%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-概述"><a href="#Go-概述" class="headerlink" title="Go 概述"></a>Go 概述</h2><p>Go 语言是一门需要编译才能运行的编程语言，也就是说代码在运行之前需要通过编译器生成二进制机器码，包含二进制机器码的文件才能在目标机器上运行，如果我们想要了解 Go 语言的实现原理，理解它的编译过程就是一个没有办法绕过的事情。</p><p>这一节会先对 Go 语言编译的过程进行概述，从顶层介绍编译器执行的几个步骤，随后的几节会分别剖析各个步骤完成的工作和实现原理，同时也会对一些需要预先掌握的知识进行介绍，确保后面的章节能够被更好的理解。</p><h2 id="Go程序规范"><a href="#Go程序规范" class="headerlink" title="Go程序规范"></a>Go程序规范</h2><p>go语言以包作为管理单位</p><p>每个文件必须声明包</p><p>程序必须有一个main包(重要)</p><h2 id="Go工程规范"><a href="#Go工程规范" class="headerlink" title="Go工程规范"></a>Go工程规范</h2><p>go入口，go有且只有一个入口函数main</p><pre><code>一个文件里面只能有一个main函数</code></pre><p>干活 执行函数</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//入口函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-comment">//打印</span><span class="hljs-comment">//&quot;hello go&quot;打印到屏幕，PrintLn()会自动换行</span><span class="hljs-comment">//调用函数，大部分都需要导入包</span><span class="hljs-comment">/*</span><span class="hljs-comment">这也是注释，这是块注释</span><span class="hljs-comment">*/</span>fmt.PrintLn(<span class="hljs-string">&quot;hello go&quot;</span>) <span class="hljs-comment">//go语言语句结尾是没有分号的</span>fmt.PirintLn(<span class="hljs-string">&quot;hello bds&quot;</span>)&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">go</span> build xxx.<span class="hljs-keyword">go</span>  <span class="hljs-comment">//通过编译xxx.go文件 然后生成一个以xx为名字的程序 直接执行xxx程序 输出程序结果</span><span class="hljs-keyword">go</span> run   xxx.<span class="hljs-keyword">go</span>  <span class="hljs-comment">//通过run 不生成程序 执行运行 一次性输出程序结果</span></code></pre><pre><code class="hljs go">###示例➜  main <span class="hljs-keyword">go</span> build hello.<span class="hljs-keyword">go</span>➜  main ./hellohello.中国➜  main lshello     hello.<span class="hljs-keyword">go</span>  value1    value1.<span class="hljs-keyword">go</span>➜  main rm -fr hello➜  main lltotal <span class="hljs-number">3744</span>-rw-r--r--  <span class="hljs-number">1</span> budongshu  staff    <span class="hljs-number">74</span>B <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">04</span> hello.<span class="hljs-keyword">go</span>-rwxr-xr-x  <span class="hljs-number">1</span> budongshu  staff   <span class="hljs-number">1.8</span>M <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span> value1-rw-r--r--  <span class="hljs-number">1</span> budongshu  staff   <span class="hljs-number">124</span>B <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">46</span> value1.<span class="hljs-keyword">go</span>➜  main <span class="hljs-keyword">go</span> run hello.<span class="hljs-keyword">go</span>hello.中国➜  main lshello.<span class="hljs-keyword">go</span>  value1    value1.<span class="hljs-keyword">go</span></code></pre><h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><pre><code class="hljs go">export GOPROXY=https:<span class="hljs-comment">//goproxy.io </span>or$env:GOPROXY = <span class="hljs-string">&quot;https://goproxy.io&quot;</span></code></pre><h2 id="Go数据类型"><a href="#Go数据类型" class="headerlink" title="Go数据类型"></a>Go数据类型</h2><p>计算机用来计算，计算前需要存数，如何存一个数呢</p><p> 数据类型作用: 告诉编译器这个数(变量) 应该以多大的内存存储</p><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>go 语言中函数名 变量名 常量名 类型名 语句标号和包名等所有的命名，都遵循一个简单的</p><p>命名规则: 一个名字必须以一个字母或者下划线开头，后面可以跟任意数量的字母，数字</p><p>或者下划线。大写字母和小写字母是不同的，heapSort Heapsort 是俩个不同的变量名字</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <span class="hljs-comment">//导入包的时候必须要使用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//变量，程序运行期间，可以改变的量</span><span class="hljs-comment">//声明格式: var 变量名 类型; 变量声明了，必须要使用</span><span class="hljs-comment">//声明变量没有初始化的变量，默认值为0</span><span class="hljs-comment">//同一个函数的&#123;&#125;里，声明的变量名是唯一的，不允许同名</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a)<span class="hljs-comment">//可以同时声明多个变量</span><span class="hljs-comment">//var b,c int</span>a = <span class="hljs-number">10</span>     <span class="hljs-comment">//变量的赋值</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a)<span class="hljs-comment">//变量的初始化： 声明变量时候，同时赋值</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span> <span class="hljs-comment">//初始化: 声明变量时，同时赋值(一步到位)</span>b = <span class="hljs-number">20</span>         <span class="hljs-comment">//赋值: 先声明，后赋值</span>fmt.Println(<span class="hljs-string">&quot;b = &quot;</span>,b)<span class="hljs-comment">// 自动推导类型，必须初始化，因为它是通过初始化的值来确定类型</span>c := <span class="hljs-number">30</span><span class="hljs-comment">//%T 打印变量的所属类型</span>fmt.Printf(<span class="hljs-string">&quot;c type is %T\n&quot;</span>,c)&#125;</code></pre><h2 id="Go-基本单元"><a href="#Go-基本单元" class="headerlink" title="Go 基本单元"></a>Go 基本单元</h2><p>Go 语言本身只有 25 个关键字，涵盖了包管理、常量与变量、流程控制、函数调用、数据结构 和并发控制六个方面的语言特性。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>func return</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(argc <span class="hljs-keyword">int</span>, argv []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">float64</span></span> &#123;...<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre><h4 id="内建的打印函数"><a href="#内建的打印函数" class="headerlink" title="内建的打印函数"></a>内建的打印函数</h4><pre><code class="hljs autoit"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print</span><span class="hljs-params">(args ...T)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">println</span><span class="hljs-params">(args ...T)</span></span></code></pre><h4 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h4><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">er</span></span>主函数</code></pre><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><pre><code class="hljs javascript">条件控制<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">continue</span> <span class="hljs-keyword">switch</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">default</span> fallthrough</code></pre><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><pre><code class="hljs ada"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span></code></pre><h4 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h4><pre><code class="hljs ada"><span class="hljs-keyword">goto</span></code></pre><h2 id="Go-基本类型"><a href="#Go-基本类型" class="headerlink" title="Go 基本类型"></a>Go 基本类型</h2><h3 id="原始的数值类型包括"><a href="#原始的数值类型包括" class="headerlink" title="原始的数值类型包括"></a>原始的数值类型包括</h3><pre><code class="hljs go"><span class="hljs-keyword">bool</span>, <span class="hljs-keyword">uint</span>, <span class="hljs-keyword">uint8</span>, <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span>, <span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span></code></pre><h3 id="常量-const-与变量-var"><a href="#常量-const-与变量-var" class="headerlink" title="常量 const 与变量 var"></a>常量 const 与变量 var</h3><pre><code class="hljs go"><span class="hljs-keyword">const</span> (    name       = <span class="hljs-string">&quot;val&quot;</span>    PI <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.1415926</span>)<span class="hljs-keyword">var</span> (    age = <span class="hljs-number">18</span>)</code></pre><p>变量除了使用 <code>var</code> 来进行声明外，还可以在函数内部通过 <code>:=</code> 进行声明</p><h2 id="数据容器与高级类型"><a href="#数据容器与高级类型" class="headerlink" title="数据容器与高级类型"></a>数据容器与高级类型</h2><ul><li>字符串</li><li>切片和数组</li><li>接口</li><li>指针与零值</li></ul><h2 id="Go-并发与同步"><a href="#Go-并发与同步" class="headerlink" title="Go 并发与同步"></a>Go 并发与同步</h2><ul><li>Channel</li><li>Select</li><li>Go 块</li></ul><h2 id="Go-错误处理"><a href="#Go-错误处理" class="headerlink" title="Go 错误处理"></a>Go 错误处理</h2><pre><code class="hljs routeros">type <span class="hljs-builtin-name">error</span><span class="hljs-built_in"> interface </span>&#123;<span class="hljs-builtin-name">Error</span>() string&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo+Gitee写博客和个人博客图床</title>
    <link href="/2020/11/26/Typora-PicGo-Gitee%E5%86%99%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/11/26/Typora-PicGo-Gitee%E5%86%99%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>： 在我们编写个人博客的时候，针对图片的保存一直是一个问题，因为图片是保存在本地，一旦博客进行分享，那么图片就会丢失，所以这里给大家介绍一个靠谱，稳定，又方便的方式实现个人图床，就是Picgo + Gitee 还有结合Typora进行写markdown博客，Typora支持PicGo上传图片，学会使用这几个工具，写博客会方便，简单很多。</p><h3 id="软件需知"><a href="#软件需知" class="headerlink" title="软件需知"></a>软件需知</h3><blockquote><p>首先电脑必须安装nodejs环境(node ,npm)</p></blockquote><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><ul><li><code>Typora</code>: Markdown工具，写Markdown文件的神器，简洁、方便、免费</li><li><code>PicGo</code> 开源的图片管理工具，可以自己上传图片到各种图床</li><li><code>gitee-uploader</code>: PicGo依赖这个插件进行上传到<code>gitee</code> 仓库</li><li><code>gitee码云</code>: 借助<code>gitee</code> 码云建立自己的仓库，构建<strong>免费</strong>图床，国内速度快</li></ul><h4 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h4><ul><li><p><code>Typora</code>:  Typora Beta 0.9.9.35.2</p></li><li><p><code>Picgo</code>:  v2.3.0-beta.3 + </p></li><li><p><code>gitee-uploader</code>:  1.1.2 </p></li><li><p><code>gitee</code>: 申请 gitee 码云平台账号 </p></li></ul><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p><code>nodejs</code> 下载地址: <a href="https://npm.taobao.org/mirrors/node/v12.20.0/">https://npm.taobao.org/mirrors/node/v12.20.0/</a></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126000352762.png" alt="image-20201126000352762"></p><h3 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h3><p>详情请看github地址： <a href="https://github.com/Molunerfinn/">https://github.com/Molunerfinn/</a></p><h4 id="Picgo下载"><a href="#Picgo下载" class="headerlink" title="Picgo下载"></a>Picgo下载</h4><ul><li>稳定版本</li></ul><p><a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.2.2">https://github.com/Molunerfinn/PicGo/releases/tag/v2.2.2</a>   </p><ul><li>测试体验版本，可能存在bug </li></ul><p><a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.3/PicGo-2.3.0-beta.3.dmg">https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.3/PicGo-2.3.0-beta.3.dmg</a></p><ul><li>百度云地址（上面俩个版本我都放到了百度云，提供下载）</li></ul><p>链接: <a href="https://pan.baidu.com/s/1KmgzO6PzUFeehAec6R8LeQ">https://pan.baidu.com/s/1KmgzO6PzUFeehAec6R8LeQ</a> 提取码: gwhg </p><h4 id="Picgo-安装"><a href="#Picgo-安装" class="headerlink" title="Picgo 安装"></a>Picgo 安装</h4><blockquote><p>我这里安装版本是最新Picgo-2.3.0</p></blockquote><p>如果遇到下面报错，请根据提示，进行安装nodejs  </p><p><code>nodejs</code> 下载地址：<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201125235825678.png" alt="image-20201125235825678"></p><h4 id="Picgo-安装成功后，然后右键打开详细窗口"><a href="#Picgo-安装成功后，然后右键打开详细窗口" class="headerlink" title="Picgo 安装成功后，然后右键打开详细窗口"></a>Picgo 安装成功后，然后右键打开详细窗口</h4><blockquote><p> 选择gitee</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003056438.png"></p><p><strong>然后右键点击软件(mac),打开详细窗口,然后选择插件设置 安装gitee-uploader</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126011800964.png" alt="image-20201126011800964"></p><p><strong>这里需要填写上传到gitee仓库的一些认证条件，下面会进行讲解</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003043875.png" alt="image-20201126003043875"></p><h3 id="gitee-注册申请"><a href="#gitee-注册申请" class="headerlink" title="gitee 注册申请"></a>gitee 注册申请</h3><p><code>gitee</code> 地址： <a href="https://gitee.com/login">https://gitee.com/login</a> </p><h4 id="gitee注册登录"><a href="#gitee注册登录" class="headerlink" title="gitee注册登录"></a>gitee注册登录</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126001439621.png" alt="image-20201126001439621"></p><h4 id="gitee-建立自己的图片仓库"><a href="#gitee-建立自己的图片仓库" class="headerlink" title="gitee 建立自己的图片仓库"></a>gitee 建立自己的图片仓库</h4><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126001652453.png" alt="image-20201126001652453"  /><h4 id="gitee-设置仓库信息"><a href="#gitee-设置仓库信息" class="headerlink" title="gitee 设置仓库信息"></a>gitee 设置仓库信息</h4><blockquote><p> 最后选择进行创建</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002327936.png" alt="image-20201126002327936"></p><h4 id="gitee的私人令牌token-生成"><a href="#gitee的私人令牌token-生成" class="headerlink" title="gitee的私人令牌token 生成"></a>gitee的私人令牌token 生成</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003911644.png" alt="image-20201126003911644"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002749069.png" alt="image-20201126002749069"></p><p>这是我的token令牌，进行复制后面会PicGo会用到</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002859007.png" alt="image-20201126002859007"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126011329717.png" alt="image-20201126011329717"></p><ul><li><p><code>repo</code>:  比如我的仓库地址: <a href="https://gitee.com/budongshu/blogimage">https://gitee.com/budongshu/blogimage</a>     去掉<a href="https://gitee.com/">https://gitee.com/</a>   </p></li><li><p><code>token</code>: 就是上面获取的私人令牌token  </p></li><li><p><code>path</code>：建立一个文件夹来保存图片，这里设置好后，仓库里面会自动创建这个目录</p></li></ul><p><strong>现在就可以上传图片了</strong></p><h3 id="Typora-设置支持PicGo"><a href="#Typora-设置支持PicGo" class="headerlink" title="Typora 设置支持PicGo"></a>Typora 设置支持PicGo</h3><blockquote><p>设置Typora工具，当插入图片的时候，触发上传图片操作，然后上传服务选择PicGo.app来支持</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126101750352.png" alt="image-20201126101750352"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126101135224.png" alt="image-20201126101135224"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 小白搭建自己个人博客</title>
    <link href="/2020/11/26/hexo%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/11/26/hexo%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>通过hexo 可以搭建属于的免费博客，不需要敲代码，不需要花钱，并且还很好看，但是需要稍稍花上一点时间，当然只要按照文档，一步一步操作，就可以收获属于自己的博客啦</p><h3 id="需要的工具介绍"><a href="#需要的工具介绍" class="headerlink" title="需要的工具介绍"></a>需要的工具介绍</h3><p><code>nodejs</code>: 包含俩个命令 <code>node</code> <code>npm</code></p><p><code>hexo</code>: 快速、简洁且高效的博客框架,支持markdown 插件和扩展性很好</p><p><code>git</code>：需要安装git 通过git 命令来操作github </p><p><code>github</code>账号：申请注册一个github账号，github提供了一个github pages功能可以支持站点</p><p>软件版本： </p><p><code>nodejs</code>： v12.20.0 建立使用这个版本，最新版本使用hexo的时候，可能会有bug</p><h3 id="开始搭建并部署博客"><a href="#开始搭建并部署博客" class="headerlink" title="开始搭建并部署博客"></a>开始搭建并部署博客</h3><h4 id="nodejs-操作"><a href="#nodejs-操作" class="headerlink" title="nodejs 操作"></a>nodejs 操作</h4><h5 id="windows-用户-安装nodejs"><a href="#windows-用户-安装nodejs" class="headerlink" title="windows 用户 安装nodejs"></a>windows 用户 安装nodejs</h5><blockquote><p> windows用户这里需要安装git来操作</p></blockquote><p>Git的官方下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> </p><p>下载完成之后点击安装，然后通过打开Git Bash 这个软件来敲下面的命令</p><p><strong>临时更换npm 源 (为了后面快速下载安装hexo，更换为国内的源)</strong></p><pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span>npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">get</span> registry看看终端显示信息，如果看到这行信息，说明配置成功: https:<span class="hljs-comment">//registry.npm.taobao.org/</span></code></pre><h5 id="mac-用户-打开终端-安装nodejs"><a href="#mac-用户-打开终端-安装nodejs" class="headerlink" title="mac 用户 打开终端 安装nodejs"></a>mac 用户 打开终端 安装nodejs</h5><p><strong>下载安装 然后通过命令检测下安装版本</strong></p><p>下载地址： <a href="https://npm.taobao.org/mirrors/node/v12.20.0/">https://npm.taobao.org/mirrors/node/v12.20.0/</a></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node -v</span>v12.20.0(base)<span class="hljs-meta">$</span><span class="bash"> npm -v</span>6.14.8</code></pre><p><strong>临时更换npm 源 (为了后面快速下载安装hexo，更换为国内的源)</strong></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org</span><span class="hljs-meta">$</span><span class="bash"> npm config get registry</span>https://registry.npm.taobao.org/</code></pre><h4 id="hexo-操作"><a href="#hexo-操作" class="headerlink" title="hexo 操作"></a>hexo 操作</h4><h5 id="windows用户-安装初始化hexo"><a href="#windows用户-安装初始化hexo" class="headerlink" title="windows用户 安装初始化hexo"></a>windows用户 安装初始化hexo</h5><blockquote><p> 通过npm来安装hexo，下面前俩个命令安装需要一点时间，blog目录就是博客目录，根据自己情况选择目录</p></blockquote><pre><code class="hljs shell">npm install hexo-cli -g  hexo init blog            cd blognpm install       hexo server</code></pre><p>然后会看到这样的信息</p><pre><code class="hljs pgsql"><span class="hljs-keyword">INFO</span>  Validating config<span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.</code></pre><p>本地访问<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客网站了</p><h5 id="mac-用户-打开终端-安装初始化hexo"><a href="#mac-用户-打开终端-安装初始化hexo" class="headerlink" title="mac 用户 打开终端 安装初始化hexo"></a>mac 用户 打开终端 安装初始化hexo</h5><blockquote><p> 通过npm来安装hexo(mac用户加上sudo),下面前俩个命令安装需要一点时间，blog目录就是博客目录,根据自己情况选择目录</p></blockquote><pre><code class="hljs shell">sudo npm install hexo-cli -g  #安装需要一点时间hexo init blog   #hexo 初始化安装 需要一点时间 这个blog以后就是自己的博客目录啦 文章都会放在这里面cd blog          #进入博客目录npm install      #npm 安装一些插件hexo server      #启动hexo服务INFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126122858805.png" alt="image-20201126122858805"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126122742048.png" alt="image-20201126122742048"></p><p>本地访问<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客网站了</p><p><strong>注意： 后面不在区分windows和 mac 用户，只要是敲命令的操作，命令都是通用的，命令不要敲错就OK。</strong></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了</p><h4 id="github-操作"><a href="#github-操作" class="headerlink" title="github 操作"></a>github 操作</h4><h5 id="github-申请账号注册"><a href="#github-申请账号注册" class="headerlink" title="github 申请账号注册"></a>github 申请账号注册</h5><p>github 注册地址： <a href="https://github.com/join?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/&amp;source=header-home">https://github.com/join?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=%2F&amp;source=header-home</a></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126113312838.png" alt="image-20201126113312838"></p><h5 id="github-登录-新建仓库"><a href="#github-登录-新建仓库" class="headerlink" title="github 登录 新建仓库"></a><strong>github 登录 新建仓库</strong></h5><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126113604379.png" alt="image-20201126113604379"></p><p><strong>github 只能是托管同名代码下 一个静态站点</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126114123119.png" alt="image-20201126114123119"></p><p><strong>这里要注意： 我们要更改下默认仓库分支名字 由 main 改为master</strong> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126133223895.png" alt="image-20201126133223895"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126133359800.png" alt="image-20201126133359800"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如: 你能看到我 说明部署成功~</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126114759280.png" alt="image-20201126114759280"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115032215.png" alt="image-20201126115032215"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115049350.png" alt="image-20201126115049350"></p><p>这个时候打开 <a href="http://你的用户名.github.io/">http://你的用户名.github.io</a> 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 <a href="http://你的用户名.github.io/">http://你的用户名.github.io</a> 看到你自己的博客啦！ 比如我的就是 <a href="http://budongshu.github.io/">http://budongshu.github.io</a> 了。</p><p>![image-20201126115126800](<a href="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115126800.png">https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115126800.png</a></p><h4 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h4><p>首先windows用户打开Git-Bash工具 mac 用户打开终端 操作命令都是一样的</p><p>执行以下命令全局配置一下本地账户</p><pre><code class="hljs shell">git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot;</code></pre><p>生成一对密钥 SSH key</p><pre><code class="hljs shell">ssh-keygen -t rsa</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126120840429.png" alt="image-20201126120840429"></p><p>首次使用还需要确认并添加主机到本机ssh 信任列表 下面可以看到success 返回成功</p><pre><code class="hljs shell">ssh -T git@github.com</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121227120.png" alt="image-20201126121227120"></p><p>查看刚刚生成公钥 最后要把这个公钥复制粘贴到github上去</p><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121614857.png" alt="image-20201126121614857"></p><p>然后登录github 在github 上添加刚刚生成的ssh key 把公钥复制粘贴上去</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121337851.png" alt="image-20201126121337851"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121412755.png" alt="image-20201126121412755"></p><h4 id="部署到github-仓库"><a href="#部署到github-仓库" class="headerlink" title="部署到github 仓库"></a>部署到github 仓库</h4><p>这个时候我们把本地hexo 和github pages部署已经完成了，接下来我们要把本地的hexo静态站点部署到github pages中，然后通过github pages 我们就可以在互联网上浏览到博客了。</p><h4 id="部署之前需要更改hexo-配置-和安装部署插件"><a href="#部署之前需要更改hexo-配置-和安装部署插件" class="headerlink" title="部署之前需要更改hexo 配置 和安装部署插件"></a>部署之前需要更改hexo 配置 和安装部署插件</h4><p>第一: 进入blog 目录，打开仓库_config.yml 配置文件，拉到文件末尾，填上如下配置（也可同时部署到多个仓库，比如也可以支持gitee ）：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意: 这个文件是有格式的，不同层级按照缩进俩个空格，比如： 下面github 根据上面repo 就是俩个空格</span><span class="hljs-meta">#</span><span class="bash"> Deployment</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span>deploy:  type: git  branch: main  repo:     github: https://github.com/budongshu/budongshu.github.io.git #仓库名字改成自己的</code></pre><p>第二: 要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><pre><code class="hljs shell">npm install hexo-deployer-git --save</code></pre><p>第三: 最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><pre><code class="hljs shell">hexo g -d</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126123828399.png" alt="image-20201126123828399"></p><p>稍等一会，在浏览器访问网址： <a href="https://你的用户名.github.io/">https://你的用户名.github.io</a> 就会看到你的博客 </p><h4 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h4><table><thead><tr><th align="left">命令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">hexo clean</td><td align="left">清除所有生成的页面文件</td></tr><tr><td align="left">hexo g</td><td align="left">生成页面</td></tr><tr><td align="left">hexo deploy</td><td align="left">推送部署到远程服务器</td></tr><tr><td align="left">hexo n xxx</td><td align="left">新建一篇名为xxx的文章</td></tr></tbody></table><h4 id="写一遍博客-发布到网上"><a href="#写一遍博客-发布到网上" class="headerlink" title="写一遍博客 发布到网上"></a>写一遍博客 发布到网上</h4><pre><code class="hljs shell">hexo new &#x27;第一遍文章&#x27;</code></pre><p>执行完成后可以在 /source/_posts 下看到一个“<code>第一遍文章.md</code>” 的文章文件 .md 就是 Markdown 格式的文件 </p><p>具体用法可以在网上找一下，语法还是比较简单的。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135451904.png" alt="image-20201126135451904"></p><p>然后按照markdown语法 编辑<code>第一遍文章.md</code> ，推荐markdown 工具: <code>Typora</code> 进行编辑</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135355292.png" alt="image-20201126135355292"></p><p>编辑完成保存，然后进行发布，注意： 一定要在blog目录下执行命令</p><pre><code class="hljs shell">cd ~/blog hexo clean &amp;&amp; hexo g -d</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135245477.png" alt="image-20201126135245477"></p><h3 id="更换主题fluid"><a href="#更换主题fluid" class="headerlink" title="更换主题fluid"></a>更换主题fluid</h3><pre><code class="hljs shell">cd ~/bloggit clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</code></pre><p>在_config.yml 配置文件中，替换theme 参数，我们 把原来的注释掉加#，然后新增一行theme:  fluid</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Extensions</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Plugins: https://hexo.io/plugins/</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Themes: https://hexo.io/themes/</span></span><span class="hljs-meta">#</span><span class="bash">theme: landscape</span>theme: fluid</code></pre><h4 id="配置主题fluid"><a href="#配置主题fluid" class="headerlink" title="配置主题fluid"></a>配置主题fluid</h4><p>新建about 关于页面</p><pre><code class="hljs shell">hexo new page about</code></pre><h4 id="随便编写介绍自己的about-页面内容"><a href="#随便编写介绍自己的about-页面内容" class="headerlink" title="随便编写介绍自己的about 页面内容"></a>随便编写介绍自己的about 页面内容</h4><pre><code class="hljs shell">---title: aboutdate: 2020-11-26 16:47:37layout: about---`email`: bdstravel@126.com</code></pre>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
