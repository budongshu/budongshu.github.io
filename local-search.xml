<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>tcp/ip 协议簇笔记</title>
    <link href="/2020/12/04/tcp-ip-%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/04/tcp-ip-%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>tcp/ip 协议簇它是基于tcp/ip协议，但是它并不仅限于tcp/ip 俩种协议,他是一个协议的泛指 </p><p>它还包括很多其他的协议,同时也分为好多层，同层之间使用相同的协议，这样体现了分层的好处</p><p>每一层只是处理自己层的协议</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204002233544.png" alt="image-20201204002233544"></p><h3 id="网络协议群"><a href="#网络协议群" class="headerlink" title="网络协议群"></a>网络协议群</h3><table><thead><tr><th>协议名称</th><th>具体协议</th></tr></thead><tbody><tr><td>应用协议</td><td>HTTP,SMTP, FTP,TELNET</td></tr><tr><td>传输协议</td><td>TCP/UDP</td></tr><tr><td>网络协议</td><td>IP/ICMP/ARP</td></tr><tr><td>路由控制协议</td><td>RIP/OSPF/BGP</td></tr></tbody></table><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位；</li></ul><p>每个层都会对所发送的数据附加一个首部，在这个首部包含了该层的必要信息，在下一层的角度看，从上一层</p><p>收到的包全部都被认为是本层的数据 </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204002515998.png" alt="image-20201204002515998"></p><h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP</p><p>TCP 提供一种面向连接的，可靠的字节流服务，流就是指不间断的数据结构</p><p>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下</p><p>虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><h3 id="TCP协议机制"><a href="#TCP协议机制" class="headerlink" title="TCP协议机制"></a>TCP协议机制</h3><ol><li><p>在一个tcp连接中，仅仅有俩方进行彼此通信，应用数据被分割成tcp认为最适合发送的数据块</p></li><li><p>当tcp发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段</p></li><li><p>当tcp收到发自tcp连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常推迟几分之一秒 deplayed ack</p></li><li><p>tcp 将保持它首部和数据的检验和 </p></li><li><p>既然tcp报文段作为ip数据报来传输，而IP数据报的到达可能会失序，如果有必要，tcp将对收到的数据进行重新排序</p></li><li><p>将收到的数据以正确的顺序交给应用层</p></li><li><p>基于全双工来进行工作</p></li></ol><h3 id="端口号和通信识别"><a href="#端口号和通信识别" class="headerlink" title="端口号和通信识别"></a>端口号和通信识别</h3><p>用于标记进程 范围在0-65535,通过五元组来识别一个通信</p><ul><li><p>知名端口号： 分布在 0~1023 之间 </p></li><li><p>端口号被正式注册：它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</p></li><li><p>Socket： 是由ip和port组合而成</p></li><li><p>五元组： 源地址，源端口，协议号，目标地址，目标端口</p></li><li><p>MTU: 网络最大传输单元</p></li></ul><h3 id="ip-header-首部"><a href="#ip-header-首部" class="headerlink" title="ip header 首部"></a>ip header 首部</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204005020380.png"></p><ul><li>Version： ip版本号</li><li>HeaderLength： 首部长度，每四个字节当做一个单位，最大位60</li><li>TypeofServer(TOS): 确保某些紧急报文可以优先到达，服务类型 (8bits)</li><li>TotalLength: 报文总长度</li><li>Identification: 每一个ip包都有一个唯一id，如果IP包被再次拆分 那么被拆分的ip包 id都是一致的</li><li>Fragment Offset: 偏移量，分片后，片与片之间的 片偏移量<ul><li>MF: 这个片已经分了好多片</li><li>DF：别分片，说明报文不允许分片</li></ul></li><li>TTL： 定义一个生命周期</li><li>Protocol：标记IP包内层协议类型,TCP 协议号6 ,UDP 的协议号17,ICMP 的协议号1,IGMP 协议号2</li><li>HeaderChecksum： 首部校验，靠tcp重转</li></ul><h3 id="tcp-header-首部"><a href="#tcp-header-首部" class="headerlink" title="tcp header 首部"></a>tcp header 首部</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201204005815968.png" alt="image-20201204005815968"></p><ul><li>SequenceNumber: 每次发送报文号码，等待对方进行确认 </li><li>ACknowlegement： 确认报文号码</li><li>Reserved： 预留位</li><li>FIN： 结束标记</li><li>SYN：发送进行同步</li><li>RST: 重置</li><li>PSH： 推送</li><li>ACK:   回复确认报文</li><li>URG: 不缓冲，尽快发送到内核处理</li><li>Urgent Pointer：紧急指针 值为1代表URG生效，值为0代表不生效</li><li>TcpChecksum： tcp的校验码</li><li>有限状态机 FSM Finite State Machine</li></ul><h2 id="tcp-三次握手四次断开"><a href="#tcp-三次握手四次断开" class="headerlink" title="tcp 三次握手四次断开"></a>tcp 三次握手四次断开</h2><p>tcp连接是全双工的，俩个信道，各自断开各自的信道，所以需要四次断开</p><p>最后断开会等待2ml时间,一般是120s</p>]]></content>
    
    
    <categories>
      
      <category>tcp/ip</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 自定义域名和主题</title>
    <link href="/2020/12/03/hexo-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/"/>
    <url>/2020/12/03/hexo-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>在之前已经部署博客环境，用hexo初始化博客项目，并且已经把博客托管到了github上，通过github提供的二级域名进行访问</p><p>我们自己如果有域名，还可以绑定自己的域名进行访问博客，域名可以通过阿里云进行购买</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>这里我们通过阿里云进行购买吧，因为阿里云收购了万网，万网算是国内最大的域名注册商</p><p>购买地址: <a href="https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com">https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com</a></p><p>我这里之前购买过域名 budongshu.cn ,下面准备想使用budongshu.cn来访问这个博客</p><p><code>注意</code>: <strong>现在大部门域名都是需要 实名认证和备案的，备案的话一般需要3天到7天左右</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203102813448.png" alt="image-20201203102813448"></p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>这里面有俩种配置方法，但是原理都是一样的</p><p>通过cname 来配置 我们现在配置一个@的cname解析和www的cname解析 这样我再浏览器里面输入budongshu.cn(配置@的cname解析起的作用)和<a href="http://www.budongshu.cn/">www.budongshu.cn</a> 都会解析到budongshu.github.io 也符合我们的预期效果</p><h3 id="第一种通过cname方式"><a href="#第一种通过cname方式" class="headerlink" title="第一种通过cname方式"></a>第一种通过cname方式</h3><p>配置@的cname解析 ，解析记录值是我现在用的访问域名budongshu.github.io </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203102904219.png"></p><p>配置www的cname解析 ，解析记录值是我现在用的访问域名budongshu.github.io </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103112447.png" alt="image-20201203103112447"></p><p>最后的配置效果</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103333548.png" alt="image-20201203103333548"></p><h3 id="第二种通过解析出来的ip来配置，A记录方式"><a href="#第二种通过解析出来的ip来配置，A记录方式" class="headerlink" title="第二种通过解析出来的ip来配置，A记录方式"></a>第二种通过解析出来的ip来配置，A记录方式</h3><p>先通过ping budongshu.github.io 看一下解析ip是多少，我们这里看到是185.199.111.153 ,那么我们同样可以通过A记录的方式</p><p>来配置跳转</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103428622.png" alt="image-20201203103428622"></p><p>做一个www配置的演示 </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203103636825.png" alt="image-20201203103636825"></p><h2 id="在hexo项目里面设置CNAME"><a href="#在hexo项目里面设置CNAME" class="headerlink" title="在hexo项目里面设置CNAME"></a>在hexo项目里面设置CNAME</h2><h3 id="1-1-新建文件CNAME"><a href="#1-1-新建文件CNAME" class="headerlink" title="1.1  新建文件CNAME"></a>1.1  新建文件CNAME</h3><p>在项目下，进入你的博客项目目录，在source 文件夹下面创建 CNAME 文件（没有后缀名的），填写上域名</p><p>可以通过编辑器进行编辑</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104545764.png" alt="image-20201203104545764"></p><h3 id="1-2-部署博客项目到github"><a href="#1-2-部署博客项目到github" class="headerlink" title="1.2 部署博客项目到github"></a>1.2 部署博客项目到github</h3><p> 然后我们部署hexo，通过项目里面的配置会上传到github，这里不明白可以看看我之前hexo 部署文章</p><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g -d</code></pre><h3 id="1-3-Github-要把https选项勾上"><a href="#1-3-Github-要把https选项勾上" class="headerlink" title="1.3 Github 要把https选项勾上"></a>1.3 Github 要把https选项勾上</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203105005191.png" alt="image-20201203105005191"></p><h2 id="用自定义的域名访问"><a href="#用自定义的域名访问" class="headerlink" title="用自定义的域名访问"></a>用自定义的域名访问</h2><p>完成上述步骤之后就可以在浏览器输入自己的域名访问了,因为我们配置了@ 和www 所以通过下面俩种方式访问</p><p><a href="https://budongshu.cn/">https://budongshu.cn</a> 和 <a href="https://www.budongshu.cn/">https://www.budongshu.cn</a> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203105252124.png" alt="image-20201203105252124"></p><h2 id="找一款自己喜欢的主题"><a href="#找一款自己喜欢的主题" class="headerlink" title="找一款自己喜欢的主题"></a>找一款自己喜欢的主题</h2><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a> ,这个里面有很多主题，可以任意挑选一个自己喜欢的主题，点击进去通常都有github地址</p><p>上面有安装和使用方法介绍，我这里选了一个名叫“fluid” 的主题，这是使用地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>下面截图是fluid使用介绍的部分内容</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104039041.png" alt="image-20201203104039041"></p><p> 主题效果</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/image-20201203104225967.png" alt="image-20201203104225967"></p><p>可以看到已经实现自定义主题了，主题这里还有很多可以自己设置的地方呢~</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 切片笔记</title>
    <link href="/2020/12/03/Go-%E5%88%87%E7%89%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/Go-%E5%88%87%E7%89%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是切片-slice"><a href="#什么是切片-slice" class="headerlink" title="什么是切片(slice)"></a>什么是切片(slice)</h2><p>slice和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生panic，但是它比数组更加的灵活，可以自动的进行扩容</p><h2 id="切片本质"><a href="#切片本质" class="headerlink" title="切片本质"></a>切片本质</h2><p>切片是由指针，长度，容量组成，切片并不是数组或者数组指针，它是通过内部指针和相关属性引用数组片段，来实现变长的方案</p><p><code>指针</code>：指向底层数组</p><p><code>长度</code>：表示切片可用元素的个数，也就是会用下标对slice进行访问时候，下标不能超过的长度 </p><p><code>容量</code>:   底层数组的元素个数，容量&gt;=长度，在底层数组不进行扩容的情况下，容量也是slice可以扩张的最大限度</p><h2 id="切片特点"><a href="#切片特点" class="headerlink" title="切片特点"></a>切片特点</h2><p>一个slice 是一个轻量级的数据结构，提供了访问数组子序列元素的功能</p><p>底层引用了一个数组对象，指针指向第一个slice元素对象的底层数组元素的地址 </p><p><code>注意</code>：底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice ,</p><p><strong>两个slice不能用==比较</strong></p><h2 id="切片和数组的区别"><a href="#切片和数组的区别" class="headerlink" title="切片和数组的区别"></a>切片和数组的区别</h2><p>slice切片底层是数组，slice是对数组的封装，它描述了一个数组的片段，俩者都可以用下标来访问元素</p><p>数组是固定长度的，长度定义好后，不能更改 </p><p>切片非常灵活，它可以动态扩容，切片的类型和长度无关</p><h2 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h2><ul><li><p>直接声明： var slice []int </p></li><li><p>字面量： slice1 := []int{1,2,3}</p></li><li><p>make:     slice1 :=make([]int,3,5)</p></li><li><p>new:       slice1 := *new([]int)</p></li><li><p>切片或者数组截取： slice1 := array1[1:4] or slice1 := slice2[1:3]</p></li></ul><h3 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h3><p>第一种直接声明创建的slice 是nil slice ，它的长度和容量都为0，和nil 比较的结果为true</p><pre><code class="hljs go"><span class="hljs-keyword">package</span>  main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s1 []<span class="hljs-keyword">int</span>fmt.Println(s1 == <span class="hljs-literal">nil</span>)&#125;<span class="hljs-comment">//result</span><span class="hljs-literal">true</span></code></pre><p><strong>空切片</strong></p><pre><code class="hljs go">silce := <span class="hljs-built_in">make</span>( []<span class="hljs-keyword">int</span> , <span class="hljs-number">0</span> )slice := []<span class="hljs-keyword">int</span>&#123; &#125;</code></pre><p><code>注意</code>：空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素</p><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code class="hljs go">s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>:<span class="hljs-number">10</span>&#125;s3 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;s4 := []<span class="hljs-keyword">int</span>&#123;&#125;  <span class="hljs-comment">//创建空切片</span>s5 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-number">99</span>: <span class="hljs-number">100</span>&#125;   <span class="hljs-comment">//初始化第100个元素</span>fmt.Println(s2,<span class="hljs-built_in">len</span>(s2),<span class="hljs-built_in">cap</span>(s2))<span class="hljs-comment">//</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>] <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-comment">//s2</span><span class="hljs-comment">//唯一值得注意的是上面的代码例子中使用了索引号,直接赋值 ,这样其他未注明的元素则默认 0 值</span></code></pre><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p><code>make</code>函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等</p><p>如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 <code>make</code> 关键字</p><p>创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 长度为5，容量为10</span>slice[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 索引为2的元素赋值为2</span>fmt.Println(slice)&#125;</code></pre><p>数组切片和切片的切片</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">//定义一个数组</span><span class="hljs-keyword">var</span> s6  = array[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">//[2,3,4] 左闭右开</span><span class="hljs-keyword">var</span> s7  = array[<span class="hljs-number">4</span>:] <span class="hljs-comment">//[5,6,0,0,0,0] </span><span class="hljs-keyword">var</span> s8 = array[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] <span class="hljs-comment">//data[low, high, max] low表示索引开始处闭区间，high表示len开区间，max表示容量开区间 结果分析 [3,4] -&gt; len=2,cap=4 </span>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">//定义一个切片</span>s10 := slice[:<span class="hljs-number">4</span>]  <span class="hljs-comment">//beginIndex如果为空则表示从0开始</span>s11 := slice[<span class="hljs-number">4</span>:]  <span class="hljs-comment">//endIndex如果为空则表示到数组最后一个元素</span><span class="hljs-keyword">var</span> <span class="hljs-number">12</span> = slice[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] <span class="hljs-comment">//data[low, high, max] low表示索引开始处闭区间，high表示len开区间，max表示容量开区间 </span></code></pre><h2 id="append追加元素"><a href="#append追加元素" class="headerlink" title="append追加元素"></a>append追加元素</h2><p>append会返回新的slice，append返回值必须使用否则编译器会报错</p><pre><code class="hljs go">slice := <span class="hljs-built_in">append</span>(slice, elem1, elem2)    <span class="hljs-comment">//可以传入多个元素</span>slice := <span class="hljs-built_in">append</span>(slice, slice_other...)  <span class="hljs-comment">//可以传入一个切片 切片后面要加三个点 ...</span></code></pre><h2 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slice1 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>&#125;out := slice1[:]out1 := slice1fmt.Printf(<span class="hljs-string">&quot;out=%v,p=%p\n&quot;</span>,out,&amp;out)fmt.Printf(<span class="hljs-string">&quot;out1=%v,p=%p&quot;</span>,out1,&amp;out1)&#125;<span class="hljs-comment">//output</span>out=[a n],p=<span class="hljs-number">0xc00000c0a0</span>out1=[a n],p=<span class="hljs-number">0xc00000c0c0</span></code></pre><h2 id="copy切片"><a href="#copy切片" class="headerlink" title="copy切片"></a>copy切片</h2><pre><code class="hljs go">由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;array := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">6</span>)n := <span class="hljs-built_in">copy</span>(slice, array)fmt.Println(n,slice)&#125;</code></pre><h2 id="for-range"><a href="#for-range" class="headerlink" title="for- range"></a>for- range</h2><p>for循环会对slice元素值一次拷贝到item。更改item中的值不会改变原slice的元素值</p><pre><code class="hljs go">slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> slice &#123;    item++&#125;fmt.Println(slice)<span class="hljs-comment">//output: [1,2,3]</span></code></pre><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>函数传slice是引用传参，修改被调函数的值，调用函数的slice也会改变。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;    test(slice)    fmt.Println(slice)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span></span> &#123;    a[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>&#125;<span class="hljs-comment">//output [1,100,3]</span></code></pre><h2 id="切片坑和困惑"><a href="#切片坑和困惑" class="headerlink" title="切片坑和困惑"></a>切片坑和困惑</h2><ul><li>切片做函数参数是传引用</li><li>append扩容问题，append 函数会创建一个新的底层数组,拷贝已存在的值和将要被附加的新值</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">s</span><span class="hljs-params">(s []<span class="hljs-keyword">string</span>)</span></span> &#123;    <span class="hljs-comment">//切片是引用传参</span>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;bds:234&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 :=[]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;123&quot;</span>&#125;s(s1)fmt.Println(s1)&#125; <span class="hljs-comment">//output</span>[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>][bds:<span class="hljs-number">234</span>]<span class="hljs-comment">/*</span><span class="hljs-comment">切片做函数参数的时候，是使用传引用（也就是传地址）</span><span class="hljs-comment">相当于是指针指向的内存地址这个引用，由于指向的是同一块内存地址，</span><span class="hljs-comment">所以在函数内部通过s[0] = &quot;bds:234&quot; 修改切片，最后修改成功</span><span class="hljs-comment">*/</span></code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;   y := s[:<span class="hljs-number">1</span>]   <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s  &#123;      y = <span class="hljs-built_in">append</span>(y,v)   &#125;   <span class="hljs-keyword">return</span> y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;   newS := myAppend(s)   fmt.Println(s)   fmt.Println(newS)&#125;<span class="hljs-comment">//output: </span>[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>][<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add2Slice</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, t <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span>&#123;s[<span class="hljs-number">0</span>]++s1 := <span class="hljs-built_in">append</span>(s, t)<span class="hljs-comment">//fmt.Println(&quot;s1&quot;,s1)</span>s[<span class="hljs-number">0</span>]++<span class="hljs-keyword">return</span> s1&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;c := Add2Slice(a, <span class="hljs-number">4</span>)fmt.Println(c)fmt.Println(<span class="hljs-string">&quot;a&quot;</span>, a)b := Add2Slice(a, <span class="hljs-number">5</span>)fmt.Println(b)d := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>&#125;nd := <span class="hljs-built_in">append</span>(d, <span class="hljs-number">3</span>)fmt.Printf(<span class="hljs-string">&quot;d=%v,P = %p\n&quot;</span>, d, &amp;d)fmt.Printf(<span class="hljs-string">&quot;nd=%v,P = %p &quot;</span>, nd, &amp;nd)&#125;<span class="hljs-comment">//output</span>[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]a [<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>][<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>]d=[<span class="hljs-number">1</span>],P = <span class="hljs-number">0xc0000a6080</span>nd=[<span class="hljs-number">1</span> <span class="hljs-number">3</span>],P = <span class="hljs-number">0xc0000a60a0</span> </code></pre><h3 id="群里热心大佬分享一个考题"><a href="#群里热心大佬分享一个考题" class="headerlink" title="群里热心大佬分享一个考题"></a>群里热心大佬分享一个考题</h3><p><img src="https://gitee.com/budongshu/blogimg/raw/master/image/17631606914834_.pic_hd.jpg" alt="17631606914834_.pic_hd"></p><pre><code class="hljs go">我的思路：s2 = s1 此时 是相同的内存地址 相当于复制拷贝一份<span class="hljs-built_in">append</span> 操作了 s2 按照<span class="hljs-keyword">go</span>的扩容规则，内存地址改变，指针指向随之发生改变 进入函数s  = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">0</span>) 操作s1 时候， s1被扩容，地址发生改变，所以后面s[i]++操作的是扩容后新地址切片 所以s1 还是 <span class="hljs-number">12</span> slice 形参是传引用 相当于指针变量进行复制一份，但是指针指向的内存地址是相同的 ，所以后面操作s[<span class="hljs-number">0</span>]++ 相当于通过修改了内存地址里面的变量值，所以会s[i]++生效进入函数s  = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">0</span>) 操作s2的时候，根据扩容规则，容量满足，地址没有发生改变，所有后面操作的是原地址切片，值s[i]++ s2 变成<span class="hljs-number">234</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go map笔记</title>
    <link href="/2020/12/03/Go-map%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/Go-map%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a>map类型</h2><p>无序的基于key-value的数据结构，复合数据类型，map是引用类型，必须初始化才能使用</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p><code>map[KeyType]ValueType</code></p><p>直接声明</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;username&quot;</span> = <span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>  = <span class="hljs-string">&quot;20&quot;</span>,&#125;</code></pre><p>字面量</p><pre><code class="hljs go">userinfo := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;username&quot;</span> = <span class="hljs-string">&quot;bds&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>  = <span class="hljs-string">&quot;20&quot;</span>,&#125;</code></pre><p>make关键字</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>,<span class="hljs-number">10</span>) #指定长度Userinfo[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;bds&quot;</span>   <span class="hljs-comment">//初始化赋值操作</span>Userinfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-string">&quot;20&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubadm1.18部署笔记</title>
    <link href="/2020/12/03/kubadm1-18%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/03/kubadm1-18%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>系统: CentOS Linux release 7.8.2003 (Core)</p><p>内核:  4.4.241-1.el7.elrepo.x86_64</p><p>k8s版本： 1.18  </p><p>calico：3.17</p><h2 id="升级内核脚本"><a href="#升级内核脚本" class="headerlink" title="升级内核脚本"></a>升级内核脚本</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 载入公钥</span>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<span class="hljs-meta">#</span><span class="bash"> 安装ELRepo</span>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="hljs-meta">#</span><span class="bash"> 载入elrepo-kernel元数据</span>yum --disablerepo=\* --enablerepo=elrepo-kernel repolist<span class="hljs-meta">#</span><span class="bash"> 查看可用的rpm包</span>yum --disablerepo=\* --enablerepo=elrepo-kernel list kernel*<span class="hljs-meta">#</span><span class="bash"> 安装长期支持版本的kernel</span>yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt.x86_64<span class="hljs-meta">#</span><span class="bash"> 删除旧版本工具包</span>yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64 -y<span class="hljs-meta">#</span><span class="bash"> 安装新版本工具包</span>yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64<span class="hljs-meta">#</span><span class="bash">查看默认启动顺序</span>awk -F\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print $2&#125;&#x27; /etc/grub2.cfg<span class="hljs-meta">#</span><span class="bash">默认启动的顺序是从0开始，新内核是从头插入（目前位置在0，而4.4.4的是在1），所以需要选择0。</span>grub2-set-default 0</code></pre><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">yum</span>yum install wget curl openssl openssh lrzsz<span class="hljs-meta">#</span><span class="bash"> 关掉防火墙</span>systemctl stop firewalld &amp;&amp; systemctl disable firewalld<span class="hljs-meta">#</span><span class="bash"> 关掉NetManager网络管理</span>systemctl stop NetworkManager &amp;&amp; systemctl disable NetworkManager <span class="hljs-meta">#</span><span class="bash"> selinux</span>setenforce 0sed -i &quot;s#=enforcing#=disabled#g&quot; /etc/selinux/config<span class="hljs-meta">#</span><span class="bash"> 关闭swap</span>swapoff -a &amp;&amp; sysctl -w vm.swappiness=0sed -ri &#x27;/^[^#]*swap/s@^@#@&#x27; /etc/fstab<span class="hljs-meta">#</span><span class="bash"> 修改yum源</span>sed -e &#x27;s!^#baseurl=!baseurl=!g&#x27;        -e  &#x27;s!^mirrorlist=!#mirrorlist=!g&#x27;        -e &#x27;s!mirror.centos.org!mirrors.ustc.edu.cn!g&#x27;        -i  /etc/yum.repos.d/CentOS-Base.repo<span class="hljs-meta">#</span><span class="bash"> epel源</span>yum install -y epel-release sed -e &#x27;s!^mirrorlist=!#mirrorlist=!g&#x27; -e &#x27;s!^#baseurl=!baseurl=!g&#x27; -e &#x27;s!^metalink!#metalink!g&#x27; -e &#x27;s!//download\.fedoraproject\.org/pub!//mirrors.ustc.edu.cn!g&#x27; -e &#x27;s!http://mirrors\.ustc!https://mirrors.ustc!g&#x27; -i /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel-testing.repo</code></pre><h2 id="yum-安装依赖和工具"><a href="#yum-安装依赖和工具" class="headerlink" title="yum 安装依赖和工具"></a>yum 安装依赖和工具</h2><pre><code class="hljs shell">yum install ipvsadm ipset sysstat conntrack libseccomp  curl git conntrack-tools  psmisc     nfs-utils jq socat  bash-completion ipset ipvsadm  conntrack  libseccomp net-tools crontabs  sysstat  unzip iftop  nload  strace  bind-utils  tcpdump  telnet  lsof htop -y</code></pre><h2 id="系统优化配置"><a href="#系统优化配置" class="headerlink" title="系统优化配置"></a>系统优化配置</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">---ipvs模式需要开机加载下列模块---</span>echo &quot;ipvs模式需要开机加载下列模块&quot;<span class="hljs-meta">cat&gt;</span><span class="bash">/etc/modules-load.d/ipvs.conf&lt;&lt;<span class="hljs-string">EOF</span></span>ip_vsip_vs_rrip_vs_wrrip_vs_shnf_conntrackbr_netfilterEOFsystemctl daemon-reloadsystemctl enable --now systemd-modules-load.service<span class="hljs-meta">#</span><span class="bash">---内核参数</span>cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 10net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1net.ipv4.neigh.default.gc_stale_time = 120net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2net.ipv4.ip_forward = 1net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-arptables = 1net.netfilter.nf_conntrack_max = 2310720fs.inotify.max_user_watches=89100fs.may_detach_mounts = 1fs.file-max = 52706963fs.nr_open = 52706963vm.swappiness = 0vm.overcommit_memory=1vm.panic_on_oom=0EOFsysctl --system<span class="hljs-meta">#</span><span class="bash">---优化设置 journal 日志相关---</span>sed -ri &#x27;s/^\$ModLoad imjournal/#&amp;/&#x27; /etc/rsyslog.confsed -ri &#x27;s/^\$IMJournalStateFile/#&amp;/&#x27; /etc/rsyslog.confsed -ri &#x27;s/^#(DefaultLimitCORE)=/\1=100000/&#x27; /etc/systemd/system.confsed -ri &#x27;s/^#(DefaultLimitNOFILE)=/\1=100000/&#x27; /etc/systemd/system.confsed -ri &#x27;s/^#(UseDNS )yes/\1no/&#x27; /etc/ssh/sshd_config<span class="hljs-meta">#</span><span class="bash">---优化文件最大打开数---</span><span class="hljs-meta">cat&gt;</span><span class="bash">/etc/security/limits.d/kubernetes.conf&lt;&lt;<span class="hljs-string">EOF</span></span>*       soft    nproc   131072*       hard    nproc   131072*       soft    nofile  131072*       hard    nofile  131072root    soft    nproc   131072root    hard    nproc   131072root    soft    nofile  131072root    hard    nofile  131072EOF</code></pre><h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> add yum 源</span>curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.reposed -i &#x27;s#download.docker.com#mirrors.ustc.edu.cn/docker-ce#g&#x27; /etc/yum.repos.d/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> yum</span> yum -y install docker-ce bash-completioncp /usr/share/bash-completion/completions/docker /etc/bash_completion.d/<span class="hljs-meta">#</span><span class="bash"> check 脚本</span>curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh &gt; check-config.shbash ./check-config.sh<span class="hljs-meta">#</span><span class="bash">---设置user_namespace.enable=1---</span>grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</code></pre><h3 id="docker-daemon-json"><a href="#docker-daemon-json" class="headerlink" title="docker daemon.json"></a>docker daemon.json</h3><pre><code class="hljs shell">&#123;    &quot;log-driver&quot;: &quot;json-file&quot;,    &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;,        &quot;max-file&quot;: &quot;3&quot;    &#125;,    &quot;live-restore&quot;: true,    &quot;max-concurrent-downloads&quot;: 10,    &quot;max-concurrent-uploads&quot;: 10,    &quot;storage-driver&quot;: &quot;overlay2&quot;,    &quot;storage-opts&quot;: [        &quot;overlay2.override_kernel_check=true&quot;    ],    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],    &quot;registry-mirrors&quot;: [        &quot;https://docker.mirrors.ustc.edu.cn/&quot;    ]&#125;</code></pre><h3 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h3><pre><code class="hljs shell">systemctl enable --now dockersystemctl start docker</code></pre><h2 id="k8s-安装"><a href="#k8s-安装" class="headerlink" title="k8s 安装"></a>k8s 安装</h2><pre><code class="hljs shell">cat &gt; /etc/yum.repos.d/k8s.repo &lt;&lt;EOF[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF<span class="hljs-meta">#</span><span class="bash"> yum 1.18版本</span>yum install  kubelet-1.18* kubadm-1.18* kubctl-1.18*  -y<span class="hljs-meta">#</span><span class="bash"> k8s 服务启动</span>systemctl daemon-reloadsystemctl restart dockersystemctl enable kubeletsystemctl start kubelet<span class="hljs-meta">#</span><span class="bash"> k8s env</span>export MASTER_IP=10.1.1.21 export APISERVER_NAME=k8s-api<span class="hljs-meta">#</span><span class="bash"> 如果想重置，重新初始化请用下面命令</span> kubeadm reset</code></pre><h2 id="k8s-master节点初始化"><a href="#k8s-master节点初始化" class="headerlink" title="k8s master节点初始化"></a>k8s master节点初始化</h2><pre><code class="hljs shell">kubeadm init       --apiserver-advertise-address 0.0.0.0         --apiserver-bind-port 6443         --cert-dir /etc/kubernetes/pki         --control-plane-endpoint k8s-api         --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers         --kubernetes-version 1.18.12         --pod-network-cidr 10.11.0.0/16         --service-cidr 10.20.0.0/16         --service-dns-domain cluster.local         --upload-certs<span class="hljs-meta">#</span><span class="bash"> </span>rm -f ~/.kube &amp;&amp; mkdir ~/.kubecp -i /etc/kubernets/admin.conf ~/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config</code></pre><h2 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h2><pre><code class="hljs css"><span class="hljs-selector-tag">wget</span> <span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">docs</span><span class="hljs-selector-class">.projectcalico</span><span class="hljs-selector-class">.org</span>/<span class="hljs-selector-tag">v3</span>.17/<span class="hljs-selector-tag">manifests</span>/<span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span><span class="hljs-selector-tag">sed</span> <span class="hljs-selector-tag">-i</span> &quot;<span class="hljs-selector-tag">s</span><span class="hljs-selector-id">#192</span>\.168\.0\.0/16<span class="hljs-selector-id">#10</span>\.10\.0\.0/16#&quot; <span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">apply</span> <span class="hljs-selector-tag">-f</span> <span class="hljs-selector-tag">calico</span><span class="hljs-selector-class">.yaml</span></code></pre><h2 id="kuboard"><a href="#kuboard" class="headerlink" title="kuboard"></a>kuboard</h2><pre><code class="hljs shell">kubectl apply -f https://kuboard.cn/install-script/kuboard.yamlkubectl get pods -l name=kuboard -n kube-systemkubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d &gt; admin-token.txt</code></pre><h2 id="k8s-check"><a href="#k8s-check" class="headerlink" title="k8s check"></a>k8s check</h2><pre><code class="hljs crmsh">kubelet get <span class="hljs-keyword">node</span> <span class="hljs-title"></span><span class="hljs-title">kubelet</span> get pods -A</code></pre><pre><code class="hljs shell">[root@k8s-01-21 ~]# kubectl get nodesNAME        STATUS     ROLES    AGE    VERSIONk8s-01-21   Ready      master   2d1h   v1.18.12k8s-02-22   NotReady   &lt;none&gt;   2d     v1.18.12k8s-03-23   NotReady   &lt;none&gt;   2d     v1.18.12<span class="hljs-meta">#</span><span class="bash"> </span>[root@k8s-01-21 ~]# kubectl get pods -ANAMESPACE     NAME                                       READY   STATUS        RESTARTS   AGEkube-system   calico-kube-controllers-8586758878-9z69l   1/1     Running       2      2dkube-system   calico-node-6wtfx                          1/1     Running       2      2dkube-system   calico-node-9qh4k                          0/1     Running       2      2dkube-system   calico-node-j7qqb                          1/1     Running       0      2dkube-system   coredns-546565776c-bfxtm                   1/1     Running       2      2d1hkube-system   coredns-546565776c-qx9h8                   1/1     Running       2      2d1hkube-system   etcd-k8s-01-21                             1/1     Running       4      2d1hkube-system   kube-apiserver-k8s-01-21                   1/1     Running       6      2d1hkube-system   kube-controller-manager-k8s-01-21          1/1     Running       11     2dkube-system   kube-proxy-28m7c                           1/1     Running       0      2dkube-system   kube-proxy-d6f6h                           1/1     Running       4      2d1hkube-system   kube-proxy-zmvkg                           1/1     Running       0      2dkube-system   kube-scheduler-k8s-01-21                   1/1     Running       11     2d1hkube-system   kuboard-7986796cf8-h8vjt                   1/1     Terminating   0      2dkube-system   kuboard-7986796cf8-k57jj                   1/1     Running       1      7m19skube-system   metrics-server-7f96bbcc66-7pzgp            0/1     Pending       0      7m19skube-system   metrics-server-7f96bbcc66-p48m9            1/1     Terminating   0      2d</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go介绍笔记</title>
    <link href="/2020/12/02/Go%E4%BB%8B%E7%BB%8D%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/02/Go%E4%BB%8B%E7%BB%8D%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-概述"><a href="#Go-概述" class="headerlink" title="Go 概述"></a>Go 概述</h2><p>Go 语言是一门需要编译才能运行的编程语言，也就是说代码在运行之前需要通过编译器生成二进制机器码，包含二进制机器码的文件才能在目标机器上运行，如果我们想要了解 Go 语言的实现原理，理解它的编译过程就是一个没有办法绕过的事情。</p><p>这一节会先对 Go 语言编译的过程进行概述，从顶层介绍编译器执行的几个步骤，随后的几节会分别剖析各个步骤完成的工作和实现原理，同时也会对一些需要预先掌握的知识进行介绍，确保后面的章节能够被更好的理解。</p><h2 id="Go程序规范"><a href="#Go程序规范" class="headerlink" title="Go程序规范"></a>Go程序规范</h2><p>go语言以包作为管理单位</p><p>每个文件必须声明包</p><p>程序必须有一个main包(重要)</p><h2 id="Go工程规范"><a href="#Go工程规范" class="headerlink" title="Go工程规范"></a>Go工程规范</h2><p>go入口，go有且只有一个入口函数main</p><pre><code>一个文件里面只能有一个main函数</code></pre><p>干活 执行函数</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//入口函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-comment">//打印</span><span class="hljs-comment">//&quot;hello go&quot;打印到屏幕，PrintLn()会自动换行</span><span class="hljs-comment">//调用函数，大部分都需要导入包</span><span class="hljs-comment">/*</span><span class="hljs-comment">这也是注释，这是块注释</span><span class="hljs-comment">*/</span>fmt.PrintLn(<span class="hljs-string">&quot;hello go&quot;</span>) <span class="hljs-comment">//go语言语句结尾是没有分号的</span>fmt.PirintLn(<span class="hljs-string">&quot;hello bds&quot;</span>)&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">go</span> build xxx.<span class="hljs-keyword">go</span>  <span class="hljs-comment">//通过编译xxx.go文件 然后生成一个以xx为名字的程序 直接执行xxx程序 输出程序结果</span><span class="hljs-keyword">go</span> run   xxx.<span class="hljs-keyword">go</span>  <span class="hljs-comment">//通过run 不生成程序 执行运行 一次性输出程序结果</span></code></pre><pre><code class="hljs go">###示例➜  main <span class="hljs-keyword">go</span> build hello.<span class="hljs-keyword">go</span>➜  main ./hellohello.中国➜  main lshello     hello.<span class="hljs-keyword">go</span>  value1    value1.<span class="hljs-keyword">go</span>➜  main rm -fr hello➜  main lltotal <span class="hljs-number">3744</span>-rw-r--r--  <span class="hljs-number">1</span> budongshu  staff    <span class="hljs-number">74</span>B <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">04</span> hello.<span class="hljs-keyword">go</span>-rwxr-xr-x  <span class="hljs-number">1</span> budongshu  staff   <span class="hljs-number">1.8</span>M <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span> value1-rw-r--r--  <span class="hljs-number">1</span> budongshu  staff   <span class="hljs-number">124</span>B <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">46</span> value1.<span class="hljs-keyword">go</span>➜  main <span class="hljs-keyword">go</span> run hello.<span class="hljs-keyword">go</span>hello.中国➜  main lshello.<span class="hljs-keyword">go</span>  value1    value1.<span class="hljs-keyword">go</span></code></pre><h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><pre><code class="hljs go">export GOPROXY=https:<span class="hljs-comment">//goproxy.io </span>or$env:GOPROXY = <span class="hljs-string">&quot;https://goproxy.io&quot;</span></code></pre><h2 id="Go数据类型"><a href="#Go数据类型" class="headerlink" title="Go数据类型"></a>Go数据类型</h2><p>计算机用来计算，计算前需要存数，如何存一个数呢</p><p> 数据类型作用: 告诉编译器这个数(变量) 应该以多大的内存存储</p><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>go 语言中函数名 变量名 常量名 类型名 语句标号和包名等所有的命名，都遵循一个简单的</p><p>命名规则: 一个名字必须以一个字母或者下划线开头，后面可以跟任意数量的字母，数字</p><p>或者下划线。大写字母和小写字母是不同的，heapSort Heapsort 是俩个不同的变量名字</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <span class="hljs-comment">//导入包的时候必须要使用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//变量，程序运行期间，可以改变的量</span><span class="hljs-comment">//声明格式: var 变量名 类型; 变量声明了，必须要使用</span><span class="hljs-comment">//声明变量没有初始化的变量，默认值为0</span><span class="hljs-comment">//同一个函数的&#123;&#125;里，声明的变量名是唯一的，不允许同名</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a)<span class="hljs-comment">//可以同时声明多个变量</span><span class="hljs-comment">//var b,c int</span>a = <span class="hljs-number">10</span>     <span class="hljs-comment">//变量的赋值</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a)<span class="hljs-comment">//变量的初始化： 声明变量时候，同时赋值</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span> <span class="hljs-comment">//初始化: 声明变量时，同时赋值(一步到位)</span>b = <span class="hljs-number">20</span>         <span class="hljs-comment">//赋值: 先声明，后赋值</span>fmt.Println(<span class="hljs-string">&quot;b = &quot;</span>,b)<span class="hljs-comment">// 自动推导类型，必须初始化，因为它是通过初始化的值来确定类型</span>c := <span class="hljs-number">30</span><span class="hljs-comment">//%T 打印变量的所属类型</span>fmt.Printf(<span class="hljs-string">&quot;c type is %T\n&quot;</span>,c)&#125;</code></pre><h2 id="Go-基本单元"><a href="#Go-基本单元" class="headerlink" title="Go 基本单元"></a>Go 基本单元</h2><p>Go 语言本身只有 25 个关键字，涵盖了包管理、常量与变量、流程控制、函数调用、数据结构 和并发控制六个方面的语言特性。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>func return</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(argc <span class="hljs-keyword">int</span>, argv []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">float64</span></span> &#123;...<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre><h4 id="内建的打印函数"><a href="#内建的打印函数" class="headerlink" title="内建的打印函数"></a>内建的打印函数</h4><pre><code class="hljs autoit"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print</span><span class="hljs-params">(args ...T)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">println</span><span class="hljs-params">(args ...T)</span></span></code></pre><h4 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h4><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">er</span></span>主函数</code></pre><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><pre><code class="hljs javascript">条件控制<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">continue</span> <span class="hljs-keyword">switch</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">default</span> fallthrough</code></pre><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><pre><code class="hljs ada"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span></code></pre><h4 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h4><pre><code class="hljs ada"><span class="hljs-keyword">goto</span></code></pre><h2 id="Go-基本类型"><a href="#Go-基本类型" class="headerlink" title="Go 基本类型"></a>Go 基本类型</h2><h3 id="原始的数值类型包括"><a href="#原始的数值类型包括" class="headerlink" title="原始的数值类型包括"></a>原始的数值类型包括</h3><pre><code class="hljs go"><span class="hljs-keyword">bool</span>, <span class="hljs-keyword">uint</span>, <span class="hljs-keyword">uint8</span>, <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span>, <span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span></code></pre><h3 id="常量-const-与变量-var"><a href="#常量-const-与变量-var" class="headerlink" title="常量 const 与变量 var"></a>常量 const 与变量 var</h3><pre><code class="hljs go"><span class="hljs-keyword">const</span> (    name       = <span class="hljs-string">&quot;val&quot;</span>    PI <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.1415926</span>)<span class="hljs-keyword">var</span> (    age = <span class="hljs-number">18</span>)</code></pre><p>变量除了使用 <code>var</code> 来进行声明外，还可以在函数内部通过 <code>:=</code> 进行声明</p><h2 id="数据容器与高级类型"><a href="#数据容器与高级类型" class="headerlink" title="数据容器与高级类型"></a>数据容器与高级类型</h2><ul><li>字符串</li><li>切片和数组</li><li>接口</li><li>指针与零值</li></ul><h2 id="Go-并发与同步"><a href="#Go-并发与同步" class="headerlink" title="Go 并发与同步"></a>Go 并发与同步</h2><ul><li>Channel</li><li>Select</li><li>Go 块</li></ul><h2 id="Go-错误处理"><a href="#Go-错误处理" class="headerlink" title="Go 错误处理"></a>Go 错误处理</h2><pre><code class="hljs routeros">type <span class="hljs-builtin-name">error</span><span class="hljs-built_in"> interface </span>&#123;<span class="hljs-builtin-name">Error</span>() string&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo+Gitee写博客和个人博客图床</title>
    <link href="/2020/11/26/Typora-PicGo-Gitee%E5%86%99%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/11/26/Typora-PicGo-Gitee%E5%86%99%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>： 在我们编写个人博客的时候，针对图片的保存一直是一个问题，因为图片是保存在本地，一旦博客进行分享，那么图片就会丢失，所以这里给大家介绍一个靠谱，稳定，又方便的方式实现个人图床，就是Picgo + Gitee 还有结合Typora进行写markdown博客，Typora支持PicGo上传图片，学会使用这几个工具，写博客会方便，简单很多。</p><h3 id="软件需知"><a href="#软件需知" class="headerlink" title="软件需知"></a>软件需知</h3><blockquote><p>首先电脑必须安装nodejs环境(node ,npm)</p></blockquote><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><ul><li><code>Typora</code>: Markdown工具，写Markdown文件的神器，简洁、方便、免费</li><li><code>PicGo</code> 开源的图片管理工具，可以自己上传图片到各种图床</li><li><code>gitee-uploader</code>: PicGo依赖这个插件进行上传到<code>gitee</code> 仓库</li><li><code>gitee码云</code>: 借助<code>gitee</code> 码云建立自己的仓库，构建<strong>免费</strong>图床，国内速度快</li></ul><h4 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h4><ul><li><p><code>Typora</code>:  Typora Beta 0.9.9.35.2</p></li><li><p><code>Picgo</code>:  v2.3.0-beta.3 + </p></li><li><p><code>gitee-uploader</code>:  1.1.2 </p></li><li><p><code>gitee</code>: 申请 gitee 码云平台账号 </p></li></ul><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p><code>nodejs</code> 下载地址: <a href="https://npm.taobao.org/mirrors/node/v12.20.0/">https://npm.taobao.org/mirrors/node/v12.20.0/</a></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126000352762.png" alt="image-20201126000352762"></p><h3 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h3><p>详情请看github地址： <a href="https://github.com/Molunerfinn/">https://github.com/Molunerfinn/</a></p><h4 id="Picgo下载"><a href="#Picgo下载" class="headerlink" title="Picgo下载"></a>Picgo下载</h4><ul><li>稳定版本</li></ul><p><a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.2.2">https://github.com/Molunerfinn/PicGo/releases/tag/v2.2.2</a>   </p><ul><li>测试体验版本，可能存在bug </li></ul><p><a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.3/PicGo-2.3.0-beta.3.dmg">https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.3/PicGo-2.3.0-beta.3.dmg</a></p><ul><li>百度云地址（上面俩个版本我都放到了百度云，提供下载）</li></ul><p>链接: <a href="https://pan.baidu.com/s/1KmgzO6PzUFeehAec6R8LeQ">https://pan.baidu.com/s/1KmgzO6PzUFeehAec6R8LeQ</a> 提取码: gwhg </p><h4 id="Picgo-安装"><a href="#Picgo-安装" class="headerlink" title="Picgo 安装"></a>Picgo 安装</h4><blockquote><p>我这里安装版本是最新Picgo-2.3.0</p></blockquote><p>如果遇到下面报错，请根据提示，进行安装nodejs  </p><p><code>nodejs</code> 下载地址：<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201125235825678.png" alt="image-20201125235825678"></p><h4 id="Picgo-安装成功后，然后右键打开详细窗口"><a href="#Picgo-安装成功后，然后右键打开详细窗口" class="headerlink" title="Picgo 安装成功后，然后右键打开详细窗口"></a>Picgo 安装成功后，然后右键打开详细窗口</h4><blockquote><p> 选择gitee</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003056438.png"></p><p><strong>然后右键点击软件(mac),打开详细窗口,然后选择插件设置 安装gitee-uploader</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126011800964.png" alt="image-20201126011800964"></p><p><strong>这里需要填写上传到gitee仓库的一些认证条件，下面会进行讲解</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003043875.png" alt="image-20201126003043875"></p><h3 id="gitee-注册申请"><a href="#gitee-注册申请" class="headerlink" title="gitee 注册申请"></a>gitee 注册申请</h3><p><code>gitee</code> 地址： <a href="https://gitee.com/login">https://gitee.com/login</a> </p><h4 id="gitee注册登录"><a href="#gitee注册登录" class="headerlink" title="gitee注册登录"></a>gitee注册登录</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126001439621.png" alt="image-20201126001439621"></p><h4 id="gitee-建立自己的图片仓库"><a href="#gitee-建立自己的图片仓库" class="headerlink" title="gitee 建立自己的图片仓库"></a>gitee 建立自己的图片仓库</h4><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126001652453.png" alt="image-20201126001652453"  /><h4 id="gitee-设置仓库信息"><a href="#gitee-设置仓库信息" class="headerlink" title="gitee 设置仓库信息"></a>gitee 设置仓库信息</h4><blockquote><p> 最后选择进行创建</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002327936.png" alt="image-20201126002327936"></p><h4 id="gitee的私人令牌token-生成"><a href="#gitee的私人令牌token-生成" class="headerlink" title="gitee的私人令牌token 生成"></a>gitee的私人令牌token 生成</h4><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126003911644.png" alt="image-20201126003911644"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002749069.png" alt="image-20201126002749069"></p><p>这是我的token令牌，进行复制后面会PicGo会用到</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126002859007.png" alt="image-20201126002859007"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126011329717.png" alt="image-20201126011329717"></p><ul><li><p><code>repo</code>:  比如我的仓库地址: <a href="https://gitee.com/budongshu/blogimage">https://gitee.com/budongshu/blogimage</a>     去掉<a href="https://gitee.com/">https://gitee.com/</a>   </p></li><li><p><code>token</code>: 就是上面获取的私人令牌token  </p></li><li><p><code>path</code>：建立一个文件夹来保存图片，这里设置好后，仓库里面会自动创建这个目录</p></li></ul><p><strong>现在就可以上传图片了</strong></p><h3 id="Typora-设置支持PicGo"><a href="#Typora-设置支持PicGo" class="headerlink" title="Typora 设置支持PicGo"></a>Typora 设置支持PicGo</h3><blockquote><p>设置Typora工具，当插入图片的时候，触发上传图片操作，然后上传服务选择PicGo.app来支持</p></blockquote><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126101750352.png" alt="image-20201126101750352"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126101135224.png" alt="image-20201126101135224"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 小白搭建自己个人博客</title>
    <link href="/2020/11/26/hexo%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/11/26/hexo%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>通过hexo 可以搭建属于的免费博客，不需要敲代码，不需要花钱，并且还很好看，但是需要稍稍花上一点时间，当然只要按照文档，一步一步操作，就可以收获属于自己的博客啦</p><h3 id="需要的工具介绍"><a href="#需要的工具介绍" class="headerlink" title="需要的工具介绍"></a>需要的工具介绍</h3><p><code>nodejs</code>: 包含俩个命令 <code>node</code> <code>npm</code></p><p><code>hexo</code>: 快速、简洁且高效的博客框架,支持markdown 插件和扩展性很好</p><p><code>git</code>：需要安装git 通过git 命令来操作github </p><p><code>github</code>账号：申请注册一个github账号，github提供了一个github pages功能可以支持站点</p><p>软件版本： </p><p><code>nodejs</code>： v12.20.0 建立使用这个版本，最新版本使用hexo的时候，可能会有bug</p><h3 id="开始搭建并部署博客"><a href="#开始搭建并部署博客" class="headerlink" title="开始搭建并部署博客"></a>开始搭建并部署博客</h3><h4 id="nodejs-操作"><a href="#nodejs-操作" class="headerlink" title="nodejs 操作"></a>nodejs 操作</h4><h5 id="windows-用户-安装nodejs"><a href="#windows-用户-安装nodejs" class="headerlink" title="windows 用户 安装nodejs"></a>windows 用户 安装nodejs</h5><blockquote><p> windows用户这里需要安装git来操作</p></blockquote><p>Git的官方下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> </p><p>下载完成之后点击安装，然后通过打开Git Bash 这个软件来敲下面的命令</p><p><strong>临时更换npm 源 (为了后面快速下载安装hexo，更换为国内的源)</strong></p><pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span>npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">get</span> registry看看终端显示信息，如果看到这行信息，说明配置成功: https:<span class="hljs-comment">//registry.npm.taobao.org/</span></code></pre><h5 id="mac-用户-打开终端-安装nodejs"><a href="#mac-用户-打开终端-安装nodejs" class="headerlink" title="mac 用户 打开终端 安装nodejs"></a>mac 用户 打开终端 安装nodejs</h5><p><strong>下载安装 然后通过命令检测下安装版本</strong></p><p>下载地址： <a href="https://npm.taobao.org/mirrors/node/v12.20.0/">https://npm.taobao.org/mirrors/node/v12.20.0/</a></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node -v</span>v12.20.0(base)<span class="hljs-meta">$</span><span class="bash"> npm -v</span>6.14.8</code></pre><p><strong>临时更换npm 源 (为了后面快速下载安装hexo，更换为国内的源)</strong></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org</span><span class="hljs-meta">$</span><span class="bash"> npm config get registry</span>https://registry.npm.taobao.org/</code></pre><h4 id="hexo-操作"><a href="#hexo-操作" class="headerlink" title="hexo 操作"></a>hexo 操作</h4><h5 id="windows用户-安装初始化hexo"><a href="#windows用户-安装初始化hexo" class="headerlink" title="windows用户 安装初始化hexo"></a>windows用户 安装初始化hexo</h5><blockquote><p> 通过npm来安装hexo，下面前俩个命令安装需要一点时间，blog目录就是博客目录，根据自己情况选择目录</p></blockquote><pre><code class="hljs shell">npm install hexo-cli -g  hexo init blog            cd blognpm install       hexo server</code></pre><p>然后会看到这样的信息</p><pre><code class="hljs pgsql"><span class="hljs-keyword">INFO</span>  Validating config<span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.</code></pre><p>本地访问<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客网站了</p><h5 id="mac-用户-打开终端-安装初始化hexo"><a href="#mac-用户-打开终端-安装初始化hexo" class="headerlink" title="mac 用户 打开终端 安装初始化hexo"></a>mac 用户 打开终端 安装初始化hexo</h5><blockquote><p> 通过npm来安装hexo(mac用户加上sudo),下面前俩个命令安装需要一点时间，blog目录就是博客目录,根据自己情况选择目录</p></blockquote><pre><code class="hljs shell">sudo npm install hexo-cli -g  #安装需要一点时间hexo init blog   #hexo 初始化安装 需要一点时间 这个blog以后就是自己的博客目录啦 文章都会放在这里面cd blog          #进入博客目录npm install      #npm 安装一些插件hexo server      #启动hexo服务INFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126122858805.png" alt="image-20201126122858805"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126122742048.png" alt="image-20201126122742048"></p><p>本地访问<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到博客网站了</p><p><strong>注意： 后面不在区分windows和 mac 用户，只要是敲命令的操作，命令都是通用的，命令不要敲错就OK。</strong></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了</p><h4 id="github-操作"><a href="#github-操作" class="headerlink" title="github 操作"></a>github 操作</h4><h5 id="github-申请账号注册"><a href="#github-申请账号注册" class="headerlink" title="github 申请账号注册"></a>github 申请账号注册</h5><p>github 注册地址： <a href="https://github.com/join?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=/&amp;source=header-home">https://github.com/join?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=%2F&amp;source=header-home</a></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126113312838.png" alt="image-20201126113312838"></p><h5 id="github-登录-新建仓库"><a href="#github-登录-新建仓库" class="headerlink" title="github 登录 新建仓库"></a><strong>github 登录 新建仓库</strong></h5><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126113604379.png" alt="image-20201126113604379"></p><p><strong>github 只能是托管同名代码下 一个静态站点</strong></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126114123119.png" alt="image-20201126114123119"></p><p><strong>这里要注意： 我们要更改下默认仓库分支名字 由 main 改为master</strong> </p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126133223895.png" alt="image-20201126133223895"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126133359800.png" alt="image-20201126133359800"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如: 你能看到我 说明部署成功~</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126114759280.png" alt="image-20201126114759280"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115032215.png" alt="image-20201126115032215"></p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115049350.png" alt="image-20201126115049350"></p><p>这个时候打开 <a href="http://你的用户名.github.io/">http://你的用户名.github.io</a> 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 <a href="http://你的用户名.github.io/">http://你的用户名.github.io</a> 看到你自己的博客啦！ 比如我的就是 <a href="http://budongshu.github.io/">http://budongshu.github.io</a> 了。</p><p>![image-20201126115126800](<a href="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115126800.png">https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126115126800.png</a></p><h4 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h4><p>首先windows用户打开Git-Bash工具 mac 用户打开终端 操作命令都是一样的</p><p>执行以下命令全局配置一下本地账户</p><pre><code class="hljs shell">git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot;</code></pre><p>生成一对密钥 SSH key</p><pre><code class="hljs shell">ssh-keygen -t rsa</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126120840429.png" alt="image-20201126120840429"></p><p>首次使用还需要确认并添加主机到本机ssh 信任列表 下面可以看到success 返回成功</p><pre><code class="hljs shell">ssh -T git@github.com</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121227120.png" alt="image-20201126121227120"></p><p>查看刚刚生成公钥 最后要把这个公钥复制粘贴到github上去</p><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121614857.png" alt="image-20201126121614857"></p><p>然后登录github 在github 上添加刚刚生成的ssh key 把公钥复制粘贴上去</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121337851.png" alt="image-20201126121337851"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126121412755.png" alt="image-20201126121412755"></p><h4 id="部署到github-仓库"><a href="#部署到github-仓库" class="headerlink" title="部署到github 仓库"></a>部署到github 仓库</h4><p>这个时候我们把本地hexo 和github pages部署已经完成了，接下来我们要把本地的hexo静态站点部署到github pages中，然后通过github pages 我们就可以在互联网上浏览到博客了。</p><h4 id="部署之前需要更改hexo-配置-和安装部署插件"><a href="#部署之前需要更改hexo-配置-和安装部署插件" class="headerlink" title="部署之前需要更改hexo 配置 和安装部署插件"></a>部署之前需要更改hexo 配置 和安装部署插件</h4><p>第一: 进入blog 目录，打开仓库_config.yml 配置文件，拉到文件末尾，填上如下配置（也可同时部署到多个仓库，比如也可以支持gitee ）：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意: 这个文件是有格式的，不同层级按照缩进俩个空格，比如： 下面github 根据上面repo 就是俩个空格</span><span class="hljs-meta">#</span><span class="bash"> Deployment</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span>deploy:  type: git  branch: main  repo:     github: https://github.com/budongshu/budongshu.github.io.git #仓库名字改成自己的</code></pre><p>第二: 要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><pre><code class="hljs shell">npm install hexo-deployer-git --save</code></pre><p>第三: 最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><pre><code class="hljs shell">hexo g -d</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126123828399.png" alt="image-20201126123828399"></p><p>稍等一会，在浏览器访问网址： <a href="https://你的用户名.github.io/">https://你的用户名.github.io</a> 就会看到你的博客 </p><h4 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h4><table><thead><tr><th align="left">命令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">hexo clean</td><td align="left">清除所有生成的页面文件</td></tr><tr><td align="left">hexo g</td><td align="left">生成页面</td></tr><tr><td align="left">hexo deploy</td><td align="left">推送部署到远程服务器</td></tr><tr><td align="left">hexo n xxx</td><td align="left">新建一篇名为xxx的文章</td></tr></tbody></table><h4 id="写一遍博客-发布到网上"><a href="#写一遍博客-发布到网上" class="headerlink" title="写一遍博客 发布到网上"></a>写一遍博客 发布到网上</h4><pre><code class="hljs shell">hexo new &#x27;第一遍文章&#x27;</code></pre><p>执行完成后可以在 /source/_posts 下看到一个“<code>第一遍文章.md</code>” 的文章文件 .md 就是 Markdown 格式的文件 </p><p>具体用法可以在网上找一下，语法还是比较简单的。</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135451904.png" alt="image-20201126135451904"></p><p>然后按照markdown语法 编辑<code>第一遍文章.md</code> ，推荐markdown 工具: <code>Typora</code> 进行编辑</p><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135355292.png" alt="image-20201126135355292"></p><p>编辑完成保存，然后进行发布，注意： 一定要在blog目录下执行命令</p><pre><code class="hljs shell">cd ~/blog hexo clean &amp;&amp; hexo g -d</code></pre><p><img src="https://gitee.com/budongshu/blogimg/raw/master/img/image-20201126135245477.png" alt="image-20201126135245477"></p><h3 id="更换主题fluid"><a href="#更换主题fluid" class="headerlink" title="更换主题fluid"></a>更换主题fluid</h3><pre><code class="hljs shell">cd ~/bloggit clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</code></pre><p>在_config.yml 配置文件中，替换theme 参数，我们 把原来的注释掉加#，然后新增一行theme:  fluid</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Extensions</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Plugins: https://hexo.io/plugins/</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Themes: https://hexo.io/themes/</span></span><span class="hljs-meta">#</span><span class="bash">theme: landscape</span>theme: fluid</code></pre><h4 id="配置主题fluid"><a href="#配置主题fluid" class="headerlink" title="配置主题fluid"></a>配置主题fluid</h4><p>新建about 关于页面</p><pre><code class="hljs shell">hexo new page about</code></pre><h4 id="随便编写介绍自己的about-页面内容"><a href="#随便编写介绍自己的about-页面内容" class="headerlink" title="随便编写介绍自己的about 页面内容"></a>随便编写介绍自己的about 页面内容</h4><pre><code class="hljs shell">---title: aboutdate: 2020-11-26 16:47:37layout: about---`email`: bdstravel@126.com</code></pre>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
